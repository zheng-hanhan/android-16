// automatically generated by the FlatBuffers compiler, do not modify


#ifndef FLATBUFFERS_GENERATED_HOSTMESSAGES_CHRE_FBS_H_
#define FLATBUFFERS_GENERATED_HOSTMESSAGES_CHRE_FBS_H_

#include "flatbuffers/flatbuffers.h"

namespace chre {
namespace fbs {

struct NanoappMessage;
struct NanoappMessageBuilder;
struct NanoappMessageT;

struct MessageDeliveryStatus;
struct MessageDeliveryStatusBuilder;
struct MessageDeliveryStatusT;

struct HubInfoRequest;
struct HubInfoRequestBuilder;
struct HubInfoRequestT;

struct HubInfoResponse;
struct HubInfoResponseBuilder;
struct HubInfoResponseT;

struct NanoappListRequest;
struct NanoappListRequestBuilder;
struct NanoappListRequestT;

struct NanoappRpcService;
struct NanoappRpcServiceBuilder;
struct NanoappRpcServiceT;

struct NanoappListEntry;
struct NanoappListEntryBuilder;
struct NanoappListEntryT;

struct NanoappListResponse;
struct NanoappListResponseBuilder;
struct NanoappListResponseT;

struct LoadNanoappRequest;
struct LoadNanoappRequestBuilder;
struct LoadNanoappRequestT;

struct LoadNanoappResponse;
struct LoadNanoappResponseBuilder;
struct LoadNanoappResponseT;

struct NanoappTokenDatabaseInfo;
struct NanoappTokenDatabaseInfoBuilder;
struct NanoappTokenDatabaseInfoT;

struct UnloadNanoappRequest;
struct UnloadNanoappRequestBuilder;
struct UnloadNanoappRequestT;

struct UnloadNanoappResponse;
struct UnloadNanoappResponseBuilder;
struct UnloadNanoappResponseT;

struct LogMessage;
struct LogMessageBuilder;
struct LogMessageT;

struct TimeSyncMessage;
struct TimeSyncMessageBuilder;
struct TimeSyncMessageT;

struct DebugDumpRequest;
struct DebugDumpRequestBuilder;
struct DebugDumpRequestT;

struct DebugDumpData;
struct DebugDumpDataBuilder;
struct DebugDumpDataT;

struct DebugDumpResponse;
struct DebugDumpResponseBuilder;
struct DebugDumpResponseT;

struct TimeSyncRequest;
struct TimeSyncRequestBuilder;
struct TimeSyncRequestT;

struct LowPowerMicAccessRequest;
struct LowPowerMicAccessRequestBuilder;
struct LowPowerMicAccessRequestT;

struct LowPowerMicAccessRelease;
struct LowPowerMicAccessReleaseBuilder;
struct LowPowerMicAccessReleaseT;

struct SettingChangeMessage;
struct SettingChangeMessageBuilder;
struct SettingChangeMessageT;

struct LogMessageV2;
struct LogMessageV2Builder;
struct LogMessageV2T;

struct SelfTestRequest;
struct SelfTestRequestBuilder;
struct SelfTestRequestT;

struct SelfTestResponse;
struct SelfTestResponseBuilder;
struct SelfTestResponseT;

struct HostEndpointConnected;
struct HostEndpointConnectedBuilder;
struct HostEndpointConnectedT;

struct HostEndpointDisconnected;
struct HostEndpointDisconnectedBuilder;
struct HostEndpointDisconnectedT;

struct MetricLog;
struct MetricLogBuilder;
struct MetricLogT;

struct BatchedMetricLog;
struct BatchedMetricLogBuilder;
struct BatchedMetricLogT;

struct NanConfigurationRequest;
struct NanConfigurationRequestBuilder;
struct NanConfigurationRequestT;

struct NanConfigurationUpdate;
struct NanConfigurationUpdateBuilder;
struct NanConfigurationUpdateT;

struct DebugConfiguration;
struct DebugConfigurationBuilder;
struct DebugConfigurationT;

struct PulseRequest;
struct PulseRequestBuilder;
struct PulseRequestT;

struct PulseResponse;
struct PulseResponseBuilder;
struct PulseResponseT;

struct LeCocChannelInfo;
struct LeCocChannelInfoBuilder;
struct LeCocChannelInfoT;

struct BtSocketOpen;
struct BtSocketOpenBuilder;
struct BtSocketOpenT;

struct BtSocketOpenResponse;
struct BtSocketOpenResponseBuilder;
struct BtSocketOpenResponseT;

struct BtSocketClose;
struct BtSocketCloseBuilder;
struct BtSocketCloseT;

struct BtSocketCloseResponse;
struct BtSocketCloseResponseBuilder;
struct BtSocketCloseResponseT;

struct BtSocketCapabilitiesRequest;
struct BtSocketCapabilitiesRequestBuilder;
struct BtSocketCapabilitiesRequestT;

struct BtSocketLeCocCapabilities;
struct BtSocketLeCocCapabilitiesBuilder;
struct BtSocketLeCocCapabilitiesT;

struct BtSocketRfcommCapabilities;
struct BtSocketRfcommCapabilitiesBuilder;
struct BtSocketRfcommCapabilitiesT;

struct BtSocketCapabilitiesResponse;
struct BtSocketCapabilitiesResponseBuilder;
struct BtSocketCapabilitiesResponseT;

struct VendorHubInfo;
struct VendorHubInfoBuilder;
struct VendorHubInfoT;

struct MessageHub;
struct MessageHubBuilder;
struct MessageHubT;

struct RegisterMessageHub;
struct RegisterMessageHubBuilder;
struct RegisterMessageHubT;

struct UnregisterMessageHub;
struct UnregisterMessageHubBuilder;
struct UnregisterMessageHubT;

struct EndpointId;
struct EndpointIdBuilder;
struct EndpointIdT;

struct Service;
struct ServiceBuilder;
struct ServiceT;

struct EndpointInfo;
struct EndpointInfoBuilder;
struct EndpointInfoT;

struct RegisterEndpoint;
struct RegisterEndpointBuilder;
struct RegisterEndpointT;

struct AddServiceToEndpoint;
struct AddServiceToEndpointBuilder;
struct AddServiceToEndpointT;

struct EndpointReady;
struct EndpointReadyBuilder;
struct EndpointReadyT;

struct UnregisterEndpoint;
struct UnregisterEndpointBuilder;
struct UnregisterEndpointT;

struct GetMessageHubsAndEndpointsRequest;
struct GetMessageHubsAndEndpointsRequestBuilder;
struct GetMessageHubsAndEndpointsRequestT;

struct GetMessageHubsAndEndpointsResponse;
struct GetMessageHubsAndEndpointsResponseBuilder;
struct GetMessageHubsAndEndpointsResponseT;

struct OpenEndpointSessionRequest;
struct OpenEndpointSessionRequestBuilder;
struct OpenEndpointSessionRequestT;

struct EndpointSessionOpened;
struct EndpointSessionOpenedBuilder;
struct EndpointSessionOpenedT;

struct EndpointSessionClosed;
struct EndpointSessionClosedBuilder;
struct EndpointSessionClosedT;

struct EndpointSessionMessage;
struct EndpointSessionMessageBuilder;
struct EndpointSessionMessageT;

struct EndpointSessionMessageDeliveryStatus;
struct EndpointSessionMessageDeliveryStatusBuilder;
struct EndpointSessionMessageDeliveryStatusT;

struct HostAddress;

struct MessageContainer;
struct MessageContainerBuilder;
struct MessageContainerT;

/// An enum describing the setting type.
enum class Setting : int8_t {
  LOCATION = 0,
  WIFI_AVAILABLE = 1,
  AIRPLANE_MODE = 2,
  MICROPHONE = 3,
  BLE_AVAILABLE = 4,
  MIN = LOCATION,
  MAX = BLE_AVAILABLE
};

inline const Setting (&EnumValuesSetting())[5] {
  static const Setting values[] = {
    Setting::LOCATION,
    Setting::WIFI_AVAILABLE,
    Setting::AIRPLANE_MODE,
    Setting::MICROPHONE,
    Setting::BLE_AVAILABLE
  };
  return values;
}

inline const char * const *EnumNamesSetting() {
  static const char * const names[6] = {
    "LOCATION",
    "WIFI_AVAILABLE",
    "AIRPLANE_MODE",
    "MICROPHONE",
    "BLE_AVAILABLE",
    nullptr
  };
  return names;
}

inline const char *EnumNameSetting(Setting e) {
  if (flatbuffers::IsOutRange(e, Setting::LOCATION, Setting::BLE_AVAILABLE)) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesSetting()[index];
}

/// An enum describing the state of a setting.
enum class SettingState : int8_t {
  DISABLED = 0,
  ENABLED = 1,
  MIN = DISABLED,
  MAX = ENABLED
};

inline const SettingState (&EnumValuesSettingState())[2] {
  static const SettingState values[] = {
    SettingState::DISABLED,
    SettingState::ENABLED
  };
  return values;
}

inline const char * const *EnumNamesSettingState() {
  static const char * const names[3] = {
    "DISABLED",
    "ENABLED",
    nullptr
  };
  return names;
}

inline const char *EnumNameSettingState(SettingState e) {
  if (flatbuffers::IsOutRange(e, SettingState::DISABLED, SettingState::ENABLED)) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesSettingState()[index];
}

enum class LogLevel : int8_t {
  ERROR = 1,
  WARNING = 2,
  INFO = 3,
  DEBUG = 4,
  VERBOSE = 5,
  MIN = ERROR,
  MAX = VERBOSE
};

inline const LogLevel (&EnumValuesLogLevel())[5] {
  static const LogLevel values[] = {
    LogLevel::ERROR,
    LogLevel::WARNING,
    LogLevel::INFO,
    LogLevel::DEBUG,
    LogLevel::VERBOSE
  };
  return values;
}

inline const char * const *EnumNamesLogLevel() {
  static const char * const names[6] = {
    "ERROR",
    "WARNING",
    "INFO",
    "DEBUG",
    "VERBOSE",
    nullptr
  };
  return names;
}

inline const char *EnumNameLogLevel(LogLevel e) {
  if (flatbuffers::IsOutRange(e, LogLevel::ERROR, LogLevel::VERBOSE)) return "";
  const size_t index = static_cast<size_t>(e) - static_cast<size_t>(LogLevel::ERROR);
  return EnumNamesLogLevel()[index];
}

enum class LogType : int8_t {
  STRING = 0,
  TOKENIZED = 1,
  BLUETOOTH = 2,
  NANOAPP_TOKENIZED = 3,
  MIN = STRING,
  MAX = NANOAPP_TOKENIZED
};

inline const LogType (&EnumValuesLogType())[4] {
  static const LogType values[] = {
    LogType::STRING,
    LogType::TOKENIZED,
    LogType::BLUETOOTH,
    LogType::NANOAPP_TOKENIZED
  };
  return values;
}

inline const char * const *EnumNamesLogType() {
  static const char * const names[5] = {
    "STRING",
    "TOKENIZED",
    "BLUETOOTH",
    "NANOAPP_TOKENIZED",
    nullptr
  };
  return names;
}

inline const char *EnumNameLogType(LogType e) {
  if (flatbuffers::IsOutRange(e, LogType::STRING, LogType::NANOAPP_TOKENIZED)) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesLogType()[index];
}

enum class BtSnoopDirection : int8_t {
  INCOMING_FROM_BT_CONTROLLER = 0,
  OUTGOING_TO_ARBITER = 1,
  MIN = INCOMING_FROM_BT_CONTROLLER,
  MAX = OUTGOING_TO_ARBITER
};

inline const BtSnoopDirection (&EnumValuesBtSnoopDirection())[2] {
  static const BtSnoopDirection values[] = {
    BtSnoopDirection::INCOMING_FROM_BT_CONTROLLER,
    BtSnoopDirection::OUTGOING_TO_ARBITER
  };
  return values;
}

inline const char * const *EnumNamesBtSnoopDirection() {
  static const char * const names[3] = {
    "INCOMING_FROM_BT_CONTROLLER",
    "OUTGOING_TO_ARBITER",
    nullptr
  };
  return names;
}

inline const char *EnumNameBtSnoopDirection(BtSnoopDirection e) {
  if (flatbuffers::IsOutRange(e, BtSnoopDirection::INCOMING_FROM_BT_CONTROLLER, BtSnoopDirection::OUTGOING_TO_ARBITER)) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesBtSnoopDirection()[index];
}

enum class ChannelInfo : uint8_t {
  NONE = 0,
  LeCocChannelInfo = 1,
  MIN = NONE,
  MAX = LeCocChannelInfo
};

inline const ChannelInfo (&EnumValuesChannelInfo())[2] {
  static const ChannelInfo values[] = {
    ChannelInfo::NONE,
    ChannelInfo::LeCocChannelInfo
  };
  return values;
}

inline const char * const *EnumNamesChannelInfo() {
  static const char * const names[3] = {
    "NONE",
    "LeCocChannelInfo",
    nullptr
  };
  return names;
}

inline const char *EnumNameChannelInfo(ChannelInfo e) {
  if (flatbuffers::IsOutRange(e, ChannelInfo::NONE, ChannelInfo::LeCocChannelInfo)) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesChannelInfo()[index];
}

template<typename T> struct ChannelInfoTraits {
  static const ChannelInfo enum_value = ChannelInfo::NONE;
};

template<> struct ChannelInfoTraits<chre::fbs::LeCocChannelInfo> {
  static const ChannelInfo enum_value = ChannelInfo::LeCocChannelInfo;
};

struct ChannelInfoUnion {
  ChannelInfo type;
  void *value;

  ChannelInfoUnion() : type(ChannelInfo::NONE), value(nullptr) {}
  ChannelInfoUnion(ChannelInfoUnion&& u) FLATBUFFERS_NOEXCEPT :
    type(ChannelInfo::NONE), value(nullptr)
    { std::swap(type, u.type); std::swap(value, u.value); }
  ChannelInfoUnion(const ChannelInfoUnion &);
  ChannelInfoUnion &operator=(const ChannelInfoUnion &u)
    { ChannelInfoUnion t(u); std::swap(type, t.type); std::swap(value, t.value); return *this; }
  ChannelInfoUnion &operator=(ChannelInfoUnion &&u) FLATBUFFERS_NOEXCEPT
    { std::swap(type, u.type); std::swap(value, u.value); return *this; }
  ~ChannelInfoUnion() { Reset(); }

  void Reset();

#ifndef FLATBUFFERS_CPP98_STL
  template <typename T>
  void Set(T&& val) {
    using RT = typename std::remove_reference<T>::type;
    Reset();
    type = ChannelInfoTraits<typename RT::TableType>::enum_value;
    if (type != ChannelInfo::NONE) {
      value = new RT(std::forward<T>(val));
    }
  }
#endif  // FLATBUFFERS_CPP98_STL

  static void *UnPack(const void *obj, ChannelInfo type, const flatbuffers::resolver_function_t *resolver);
  flatbuffers::Offset<void> Pack(flatbuffers::FlatBufferBuilder &_fbb, const flatbuffers::rehasher_function_t *_rehasher = nullptr) const;

  chre::fbs::LeCocChannelInfoT *AsLeCocChannelInfo() {
    return type == ChannelInfo::LeCocChannelInfo ?
      reinterpret_cast<chre::fbs::LeCocChannelInfoT *>(value) : nullptr;
  }
  const chre::fbs::LeCocChannelInfoT *AsLeCocChannelInfo() const {
    return type == ChannelInfo::LeCocChannelInfo ?
      reinterpret_cast<const chre::fbs::LeCocChannelInfoT *>(value) : nullptr;
  }
};

bool VerifyChannelInfo(flatbuffers::Verifier &verifier, const void *obj, ChannelInfo type);
bool VerifyChannelInfoVector(flatbuffers::Verifier &verifier, const flatbuffers::Vector<flatbuffers::Offset<void>> *values, const flatbuffers::Vector<uint8_t> *types);

enum class BtSocketOpenStatus : int8_t {
  SUCCESS = 0,
  FAILURE = 1,
  MIN = SUCCESS,
  MAX = FAILURE
};

inline const BtSocketOpenStatus (&EnumValuesBtSocketOpenStatus())[2] {
  static const BtSocketOpenStatus values[] = {
    BtSocketOpenStatus::SUCCESS,
    BtSocketOpenStatus::FAILURE
  };
  return values;
}

inline const char * const *EnumNamesBtSocketOpenStatus() {
  static const char * const names[3] = {
    "SUCCESS",
    "FAILURE",
    nullptr
  };
  return names;
}

inline const char *EnumNameBtSocketOpenStatus(BtSocketOpenStatus e) {
  if (flatbuffers::IsOutRange(e, BtSocketOpenStatus::SUCCESS, BtSocketOpenStatus::FAILURE)) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesBtSocketOpenStatus()[index];
}

enum class MessageHubDetails : uint8_t {
  NONE = 0,
  HubInfoResponse = 1,
  VendorHubInfo = 2,
  MIN = NONE,
  MAX = VendorHubInfo
};

inline const MessageHubDetails (&EnumValuesMessageHubDetails())[3] {
  static const MessageHubDetails values[] = {
    MessageHubDetails::NONE,
    MessageHubDetails::HubInfoResponse,
    MessageHubDetails::VendorHubInfo
  };
  return values;
}

inline const char * const *EnumNamesMessageHubDetails() {
  static const char * const names[4] = {
    "NONE",
    "HubInfoResponse",
    "VendorHubInfo",
    nullptr
  };
  return names;
}

inline const char *EnumNameMessageHubDetails(MessageHubDetails e) {
  if (flatbuffers::IsOutRange(e, MessageHubDetails::NONE, MessageHubDetails::VendorHubInfo)) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesMessageHubDetails()[index];
}

template<typename T> struct MessageHubDetailsTraits {
  static const MessageHubDetails enum_value = MessageHubDetails::NONE;
};

template<> struct MessageHubDetailsTraits<chre::fbs::HubInfoResponse> {
  static const MessageHubDetails enum_value = MessageHubDetails::HubInfoResponse;
};

template<> struct MessageHubDetailsTraits<chre::fbs::VendorHubInfo> {
  static const MessageHubDetails enum_value = MessageHubDetails::VendorHubInfo;
};

struct MessageHubDetailsUnion {
  MessageHubDetails type;
  void *value;

  MessageHubDetailsUnion() : type(MessageHubDetails::NONE), value(nullptr) {}
  MessageHubDetailsUnion(MessageHubDetailsUnion&& u) FLATBUFFERS_NOEXCEPT :
    type(MessageHubDetails::NONE), value(nullptr)
    { std::swap(type, u.type); std::swap(value, u.value); }
  MessageHubDetailsUnion(const MessageHubDetailsUnion &);
  MessageHubDetailsUnion &operator=(const MessageHubDetailsUnion &u)
    { MessageHubDetailsUnion t(u); std::swap(type, t.type); std::swap(value, t.value); return *this; }
  MessageHubDetailsUnion &operator=(MessageHubDetailsUnion &&u) FLATBUFFERS_NOEXCEPT
    { std::swap(type, u.type); std::swap(value, u.value); return *this; }
  ~MessageHubDetailsUnion() { Reset(); }

  void Reset();

#ifndef FLATBUFFERS_CPP98_STL
  template <typename T>
  void Set(T&& val) {
    using RT = typename std::remove_reference<T>::type;
    Reset();
    type = MessageHubDetailsTraits<typename RT::TableType>::enum_value;
    if (type != MessageHubDetails::NONE) {
      value = new RT(std::forward<T>(val));
    }
  }
#endif  // FLATBUFFERS_CPP98_STL

  static void *UnPack(const void *obj, MessageHubDetails type, const flatbuffers::resolver_function_t *resolver);
  flatbuffers::Offset<void> Pack(flatbuffers::FlatBufferBuilder &_fbb, const flatbuffers::rehasher_function_t *_rehasher = nullptr) const;

  chre::fbs::HubInfoResponseT *AsHubInfoResponse() {
    return type == MessageHubDetails::HubInfoResponse ?
      reinterpret_cast<chre::fbs::HubInfoResponseT *>(value) : nullptr;
  }
  const chre::fbs::HubInfoResponseT *AsHubInfoResponse() const {
    return type == MessageHubDetails::HubInfoResponse ?
      reinterpret_cast<const chre::fbs::HubInfoResponseT *>(value) : nullptr;
  }
  chre::fbs::VendorHubInfoT *AsVendorHubInfo() {
    return type == MessageHubDetails::VendorHubInfo ?
      reinterpret_cast<chre::fbs::VendorHubInfoT *>(value) : nullptr;
  }
  const chre::fbs::VendorHubInfoT *AsVendorHubInfo() const {
    return type == MessageHubDetails::VendorHubInfo ?
      reinterpret_cast<const chre::fbs::VendorHubInfoT *>(value) : nullptr;
  }
};

bool VerifyMessageHubDetails(flatbuffers::Verifier &verifier, const void *obj, MessageHubDetails type);
bool VerifyMessageHubDetailsVector(flatbuffers::Verifier &verifier, const flatbuffers::Vector<flatbuffers::Offset<void>> *values, const flatbuffers::Vector<uint8_t> *types);

/// An enum describing the type of an endpoint.
enum class EndpointType : uint8_t {
  INVALID = 0,
  /// The endpoint is part of the Android Framework
  FRAMEWORK = 1,
  /// The endpoint is an Android app
  APP = 2,
  /// The endpoint is a native Android program
  NATIVE = 3,
  /// The endpoint is a nanoapp
  NANOAPP = 4,
  /// A generic, non-nanoapp endpoint
  GENERIC = 5,
  MIN = INVALID,
  MAX = GENERIC
};

inline const EndpointType (&EnumValuesEndpointType())[6] {
  static const EndpointType values[] = {
    EndpointType::INVALID,
    EndpointType::FRAMEWORK,
    EndpointType::APP,
    EndpointType::NATIVE,
    EndpointType::NANOAPP,
    EndpointType::GENERIC
  };
  return values;
}

inline const char * const *EnumNamesEndpointType() {
  static const char * const names[7] = {
    "INVALID",
    "FRAMEWORK",
    "APP",
    "NATIVE",
    "NANOAPP",
    "GENERIC",
    nullptr
  };
  return names;
}

inline const char *EnumNameEndpointType(EndpointType e) {
  if (flatbuffers::IsOutRange(e, EndpointType::INVALID, EndpointType::GENERIC)) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesEndpointType()[index];
}

enum class RpcFormat : uint8_t {
  /// Fully custom format
  CUSTOM = 0,
  /// Stable AIDL defined interface using Binder marshalling
  AIDL = 1,
  /// Pigweed RPC defined interface using Protobuf marshalling
  PW_RPC = 2,
  MIN = CUSTOM,
  MAX = PW_RPC
};

inline const RpcFormat (&EnumValuesRpcFormat())[3] {
  static const RpcFormat values[] = {
    RpcFormat::CUSTOM,
    RpcFormat::AIDL,
    RpcFormat::PW_RPC
  };
  return values;
}

inline const char * const *EnumNamesRpcFormat() {
  static const char * const names[4] = {
    "CUSTOM",
    "AIDL",
    "PW_RPC",
    nullptr
  };
  return names;
}

inline const char *EnumNameRpcFormat(RpcFormat e) {
  if (flatbuffers::IsOutRange(e, RpcFormat::CUSTOM, RpcFormat::PW_RPC)) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesRpcFormat()[index];
}

/// "Reason"s for stopping an endpoint or session over an endpoint.
enum class Reason : uint8_t {
  /// Unspecified reason.
  UNSPECIFIED = 0,
  /// Out of memory. There's not enough memory to perform this operation.
  OUT_OF_MEMORY = 1,
  /// Timeout. This operation timed out.
  TIMEOUT = 2,
  /// Endpoint rejected this openEndpointSession request.
  OPEN_ENDPOINT_SESSION_REQUEST_REJECTED = 3,
  /// Endpoint requested closeEndpointSession.
  CLOSE_ENDPOINT_SESSION_REQUESTED = 4,
  /// Invalid endpoint.
  ENDPOINT_INVALID = 5,
  /// Endpoint is now stopped.
  ENDPOINT_GONE = 6,
  /// Endpoint crashed.
  ENDPOINT_CRASHED = 7,
  /// Hub was reset or is resetting.
  HUB_RESET = 8,
  MIN = UNSPECIFIED,
  MAX = HUB_RESET
};

inline const Reason (&EnumValuesReason())[9] {
  static const Reason values[] = {
    Reason::UNSPECIFIED,
    Reason::OUT_OF_MEMORY,
    Reason::TIMEOUT,
    Reason::OPEN_ENDPOINT_SESSION_REQUEST_REJECTED,
    Reason::CLOSE_ENDPOINT_SESSION_REQUESTED,
    Reason::ENDPOINT_INVALID,
    Reason::ENDPOINT_GONE,
    Reason::ENDPOINT_CRASHED,
    Reason::HUB_RESET
  };
  return values;
}

inline const char * const *EnumNamesReason() {
  static const char * const names[10] = {
    "UNSPECIFIED",
    "OUT_OF_MEMORY",
    "TIMEOUT",
    "OPEN_ENDPOINT_SESSION_REQUEST_REJECTED",
    "CLOSE_ENDPOINT_SESSION_REQUESTED",
    "ENDPOINT_INVALID",
    "ENDPOINT_GONE",
    "ENDPOINT_CRASHED",
    "HUB_RESET",
    nullptr
  };
  return names;
}

inline const char *EnumNameReason(Reason e) {
  if (flatbuffers::IsOutRange(e, Reason::UNSPECIFIED, Reason::HUB_RESET)) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesReason()[index];
}

/// A union that joins together all possible messages. Note that in FlatBuffers,
/// unions have an implicit type
enum class ChreMessage : uint8_t {
  NONE = 0,
  NanoappMessage = 1,
  HubInfoRequest = 2,
  HubInfoResponse = 3,
  NanoappListRequest = 4,
  NanoappListResponse = 5,
  LoadNanoappRequest = 6,
  LoadNanoappResponse = 7,
  UnloadNanoappRequest = 8,
  UnloadNanoappResponse = 9,
  LogMessage = 10,
  TimeSyncMessage = 11,
  DebugDumpRequest = 12,
  DebugDumpData = 13,
  DebugDumpResponse = 14,
  TimeSyncRequest = 15,
  LowPowerMicAccessRequest = 16,
  LowPowerMicAccessRelease = 17,
  SettingChangeMessage = 18,
  LogMessageV2 = 19,
  SelfTestRequest = 20,
  SelfTestResponse = 21,
  HostEndpointConnected = 22,
  HostEndpointDisconnected = 23,
  MetricLog = 24,
  BatchedMetricLog = 25,
  NanConfigurationRequest = 26,
  NanConfigurationUpdate = 27,
  DebugConfiguration = 28,
  PulseRequest = 29,
  PulseResponse = 30,
  NanoappTokenDatabaseInfo = 31,
  MessageDeliveryStatus = 32,
  BtSocketOpen = 33,
  BtSocketOpenResponse = 34,
  BtSocketClose = 35,
  BtSocketCloseResponse = 36,
  GetMessageHubsAndEndpointsRequest = 37,
  GetMessageHubsAndEndpointsResponse = 38,
  RegisterMessageHub = 39,
  UnregisterMessageHub = 40,
  RegisterEndpoint = 41,
  UnregisterEndpoint = 42,
  OpenEndpointSessionRequest = 43,
  EndpointSessionOpened = 44,
  EndpointSessionClosed = 45,
  EndpointSessionMessage = 46,
  EndpointSessionMessageDeliveryStatus = 47,
  BtSocketCapabilitiesRequest = 48,
  BtSocketCapabilitiesResponse = 49,
  AddServiceToEndpoint = 50,
  EndpointReady = 51,
  MIN = NONE,
  MAX = EndpointReady
};

inline const ChreMessage (&EnumValuesChreMessage())[52] {
  static const ChreMessage values[] = {
    ChreMessage::NONE,
    ChreMessage::NanoappMessage,
    ChreMessage::HubInfoRequest,
    ChreMessage::HubInfoResponse,
    ChreMessage::NanoappListRequest,
    ChreMessage::NanoappListResponse,
    ChreMessage::LoadNanoappRequest,
    ChreMessage::LoadNanoappResponse,
    ChreMessage::UnloadNanoappRequest,
    ChreMessage::UnloadNanoappResponse,
    ChreMessage::LogMessage,
    ChreMessage::TimeSyncMessage,
    ChreMessage::DebugDumpRequest,
    ChreMessage::DebugDumpData,
    ChreMessage::DebugDumpResponse,
    ChreMessage::TimeSyncRequest,
    ChreMessage::LowPowerMicAccessRequest,
    ChreMessage::LowPowerMicAccessRelease,
    ChreMessage::SettingChangeMessage,
    ChreMessage::LogMessageV2,
    ChreMessage::SelfTestRequest,
    ChreMessage::SelfTestResponse,
    ChreMessage::HostEndpointConnected,
    ChreMessage::HostEndpointDisconnected,
    ChreMessage::MetricLog,
    ChreMessage::BatchedMetricLog,
    ChreMessage::NanConfigurationRequest,
    ChreMessage::NanConfigurationUpdate,
    ChreMessage::DebugConfiguration,
    ChreMessage::PulseRequest,
    ChreMessage::PulseResponse,
    ChreMessage::NanoappTokenDatabaseInfo,
    ChreMessage::MessageDeliveryStatus,
    ChreMessage::BtSocketOpen,
    ChreMessage::BtSocketOpenResponse,
    ChreMessage::BtSocketClose,
    ChreMessage::BtSocketCloseResponse,
    ChreMessage::GetMessageHubsAndEndpointsRequest,
    ChreMessage::GetMessageHubsAndEndpointsResponse,
    ChreMessage::RegisterMessageHub,
    ChreMessage::UnregisterMessageHub,
    ChreMessage::RegisterEndpoint,
    ChreMessage::UnregisterEndpoint,
    ChreMessage::OpenEndpointSessionRequest,
    ChreMessage::EndpointSessionOpened,
    ChreMessage::EndpointSessionClosed,
    ChreMessage::EndpointSessionMessage,
    ChreMessage::EndpointSessionMessageDeliveryStatus,
    ChreMessage::BtSocketCapabilitiesRequest,
    ChreMessage::BtSocketCapabilitiesResponse,
    ChreMessage::AddServiceToEndpoint,
    ChreMessage::EndpointReady
  };
  return values;
}

inline const char * const *EnumNamesChreMessage() {
  static const char * const names[53] = {
    "NONE",
    "NanoappMessage",
    "HubInfoRequest",
    "HubInfoResponse",
    "NanoappListRequest",
    "NanoappListResponse",
    "LoadNanoappRequest",
    "LoadNanoappResponse",
    "UnloadNanoappRequest",
    "UnloadNanoappResponse",
    "LogMessage",
    "TimeSyncMessage",
    "DebugDumpRequest",
    "DebugDumpData",
    "DebugDumpResponse",
    "TimeSyncRequest",
    "LowPowerMicAccessRequest",
    "LowPowerMicAccessRelease",
    "SettingChangeMessage",
    "LogMessageV2",
    "SelfTestRequest",
    "SelfTestResponse",
    "HostEndpointConnected",
    "HostEndpointDisconnected",
    "MetricLog",
    "BatchedMetricLog",
    "NanConfigurationRequest",
    "NanConfigurationUpdate",
    "DebugConfiguration",
    "PulseRequest",
    "PulseResponse",
    "NanoappTokenDatabaseInfo",
    "MessageDeliveryStatus",
    "BtSocketOpen",
    "BtSocketOpenResponse",
    "BtSocketClose",
    "BtSocketCloseResponse",
    "GetMessageHubsAndEndpointsRequest",
    "GetMessageHubsAndEndpointsResponse",
    "RegisterMessageHub",
    "UnregisterMessageHub",
    "RegisterEndpoint",
    "UnregisterEndpoint",
    "OpenEndpointSessionRequest",
    "EndpointSessionOpened",
    "EndpointSessionClosed",
    "EndpointSessionMessage",
    "EndpointSessionMessageDeliveryStatus",
    "BtSocketCapabilitiesRequest",
    "BtSocketCapabilitiesResponse",
    "AddServiceToEndpoint",
    "EndpointReady",
    nullptr
  };
  return names;
}

inline const char *EnumNameChreMessage(ChreMessage e) {
  if (flatbuffers::IsOutRange(e, ChreMessage::NONE, ChreMessage::EndpointReady)) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesChreMessage()[index];
}

template<typename T> struct ChreMessageTraits {
  static const ChreMessage enum_value = ChreMessage::NONE;
};

template<> struct ChreMessageTraits<chre::fbs::NanoappMessage> {
  static const ChreMessage enum_value = ChreMessage::NanoappMessage;
};

template<> struct ChreMessageTraits<chre::fbs::HubInfoRequest> {
  static const ChreMessage enum_value = ChreMessage::HubInfoRequest;
};

template<> struct ChreMessageTraits<chre::fbs::HubInfoResponse> {
  static const ChreMessage enum_value = ChreMessage::HubInfoResponse;
};

template<> struct ChreMessageTraits<chre::fbs::NanoappListRequest> {
  static const ChreMessage enum_value = ChreMessage::NanoappListRequest;
};

template<> struct ChreMessageTraits<chre::fbs::NanoappListResponse> {
  static const ChreMessage enum_value = ChreMessage::NanoappListResponse;
};

template<> struct ChreMessageTraits<chre::fbs::LoadNanoappRequest> {
  static const ChreMessage enum_value = ChreMessage::LoadNanoappRequest;
};

template<> struct ChreMessageTraits<chre::fbs::LoadNanoappResponse> {
  static const ChreMessage enum_value = ChreMessage::LoadNanoappResponse;
};

template<> struct ChreMessageTraits<chre::fbs::UnloadNanoappRequest> {
  static const ChreMessage enum_value = ChreMessage::UnloadNanoappRequest;
};

template<> struct ChreMessageTraits<chre::fbs::UnloadNanoappResponse> {
  static const ChreMessage enum_value = ChreMessage::UnloadNanoappResponse;
};

template<> struct ChreMessageTraits<chre::fbs::LogMessage> {
  static const ChreMessage enum_value = ChreMessage::LogMessage;
};

template<> struct ChreMessageTraits<chre::fbs::TimeSyncMessage> {
  static const ChreMessage enum_value = ChreMessage::TimeSyncMessage;
};

template<> struct ChreMessageTraits<chre::fbs::DebugDumpRequest> {
  static const ChreMessage enum_value = ChreMessage::DebugDumpRequest;
};

template<> struct ChreMessageTraits<chre::fbs::DebugDumpData> {
  static const ChreMessage enum_value = ChreMessage::DebugDumpData;
};

template<> struct ChreMessageTraits<chre::fbs::DebugDumpResponse> {
  static const ChreMessage enum_value = ChreMessage::DebugDumpResponse;
};

template<> struct ChreMessageTraits<chre::fbs::TimeSyncRequest> {
  static const ChreMessage enum_value = ChreMessage::TimeSyncRequest;
};

template<> struct ChreMessageTraits<chre::fbs::LowPowerMicAccessRequest> {
  static const ChreMessage enum_value = ChreMessage::LowPowerMicAccessRequest;
};

template<> struct ChreMessageTraits<chre::fbs::LowPowerMicAccessRelease> {
  static const ChreMessage enum_value = ChreMessage::LowPowerMicAccessRelease;
};

template<> struct ChreMessageTraits<chre::fbs::SettingChangeMessage> {
  static const ChreMessage enum_value = ChreMessage::SettingChangeMessage;
};

template<> struct ChreMessageTraits<chre::fbs::LogMessageV2> {
  static const ChreMessage enum_value = ChreMessage::LogMessageV2;
};

template<> struct ChreMessageTraits<chre::fbs::SelfTestRequest> {
  static const ChreMessage enum_value = ChreMessage::SelfTestRequest;
};

template<> struct ChreMessageTraits<chre::fbs::SelfTestResponse> {
  static const ChreMessage enum_value = ChreMessage::SelfTestResponse;
};

template<> struct ChreMessageTraits<chre::fbs::HostEndpointConnected> {
  static const ChreMessage enum_value = ChreMessage::HostEndpointConnected;
};

template<> struct ChreMessageTraits<chre::fbs::HostEndpointDisconnected> {
  static const ChreMessage enum_value = ChreMessage::HostEndpointDisconnected;
};

template<> struct ChreMessageTraits<chre::fbs::MetricLog> {
  static const ChreMessage enum_value = ChreMessage::MetricLog;
};

template<> struct ChreMessageTraits<chre::fbs::BatchedMetricLog> {
  static const ChreMessage enum_value = ChreMessage::BatchedMetricLog;
};

template<> struct ChreMessageTraits<chre::fbs::NanConfigurationRequest> {
  static const ChreMessage enum_value = ChreMessage::NanConfigurationRequest;
};

template<> struct ChreMessageTraits<chre::fbs::NanConfigurationUpdate> {
  static const ChreMessage enum_value = ChreMessage::NanConfigurationUpdate;
};

template<> struct ChreMessageTraits<chre::fbs::DebugConfiguration> {
  static const ChreMessage enum_value = ChreMessage::DebugConfiguration;
};

template<> struct ChreMessageTraits<chre::fbs::PulseRequest> {
  static const ChreMessage enum_value = ChreMessage::PulseRequest;
};

template<> struct ChreMessageTraits<chre::fbs::PulseResponse> {
  static const ChreMessage enum_value = ChreMessage::PulseResponse;
};

template<> struct ChreMessageTraits<chre::fbs::NanoappTokenDatabaseInfo> {
  static const ChreMessage enum_value = ChreMessage::NanoappTokenDatabaseInfo;
};

template<> struct ChreMessageTraits<chre::fbs::MessageDeliveryStatus> {
  static const ChreMessage enum_value = ChreMessage::MessageDeliveryStatus;
};

template<> struct ChreMessageTraits<chre::fbs::BtSocketOpen> {
  static const ChreMessage enum_value = ChreMessage::BtSocketOpen;
};

template<> struct ChreMessageTraits<chre::fbs::BtSocketOpenResponse> {
  static const ChreMessage enum_value = ChreMessage::BtSocketOpenResponse;
};

template<> struct ChreMessageTraits<chre::fbs::BtSocketClose> {
  static const ChreMessage enum_value = ChreMessage::BtSocketClose;
};

template<> struct ChreMessageTraits<chre::fbs::BtSocketCloseResponse> {
  static const ChreMessage enum_value = ChreMessage::BtSocketCloseResponse;
};

template<> struct ChreMessageTraits<chre::fbs::GetMessageHubsAndEndpointsRequest> {
  static const ChreMessage enum_value = ChreMessage::GetMessageHubsAndEndpointsRequest;
};

template<> struct ChreMessageTraits<chre::fbs::GetMessageHubsAndEndpointsResponse> {
  static const ChreMessage enum_value = ChreMessage::GetMessageHubsAndEndpointsResponse;
};

template<> struct ChreMessageTraits<chre::fbs::RegisterMessageHub> {
  static const ChreMessage enum_value = ChreMessage::RegisterMessageHub;
};

template<> struct ChreMessageTraits<chre::fbs::UnregisterMessageHub> {
  static const ChreMessage enum_value = ChreMessage::UnregisterMessageHub;
};

template<> struct ChreMessageTraits<chre::fbs::RegisterEndpoint> {
  static const ChreMessage enum_value = ChreMessage::RegisterEndpoint;
};

template<> struct ChreMessageTraits<chre::fbs::UnregisterEndpoint> {
  static const ChreMessage enum_value = ChreMessage::UnregisterEndpoint;
};

template<> struct ChreMessageTraits<chre::fbs::OpenEndpointSessionRequest> {
  static const ChreMessage enum_value = ChreMessage::OpenEndpointSessionRequest;
};

template<> struct ChreMessageTraits<chre::fbs::EndpointSessionOpened> {
  static const ChreMessage enum_value = ChreMessage::EndpointSessionOpened;
};

template<> struct ChreMessageTraits<chre::fbs::EndpointSessionClosed> {
  static const ChreMessage enum_value = ChreMessage::EndpointSessionClosed;
};

template<> struct ChreMessageTraits<chre::fbs::EndpointSessionMessage> {
  static const ChreMessage enum_value = ChreMessage::EndpointSessionMessage;
};

template<> struct ChreMessageTraits<chre::fbs::EndpointSessionMessageDeliveryStatus> {
  static const ChreMessage enum_value = ChreMessage::EndpointSessionMessageDeliveryStatus;
};

template<> struct ChreMessageTraits<chre::fbs::BtSocketCapabilitiesRequest> {
  static const ChreMessage enum_value = ChreMessage::BtSocketCapabilitiesRequest;
};

template<> struct ChreMessageTraits<chre::fbs::BtSocketCapabilitiesResponse> {
  static const ChreMessage enum_value = ChreMessage::BtSocketCapabilitiesResponse;
};

template<> struct ChreMessageTraits<chre::fbs::AddServiceToEndpoint> {
  static const ChreMessage enum_value = ChreMessage::AddServiceToEndpoint;
};

template<> struct ChreMessageTraits<chre::fbs::EndpointReady> {
  static const ChreMessage enum_value = ChreMessage::EndpointReady;
};

struct ChreMessageUnion {
  ChreMessage type;
  void *value;

  ChreMessageUnion() : type(ChreMessage::NONE), value(nullptr) {}
  ChreMessageUnion(ChreMessageUnion&& u) FLATBUFFERS_NOEXCEPT :
    type(ChreMessage::NONE), value(nullptr)
    { std::swap(type, u.type); std::swap(value, u.value); }
  ChreMessageUnion(const ChreMessageUnion &);
  ChreMessageUnion &operator=(const ChreMessageUnion &u)
    { ChreMessageUnion t(u); std::swap(type, t.type); std::swap(value, t.value); return *this; }
  ChreMessageUnion &operator=(ChreMessageUnion &&u) FLATBUFFERS_NOEXCEPT
    { std::swap(type, u.type); std::swap(value, u.value); return *this; }
  ~ChreMessageUnion() { Reset(); }

  void Reset();

#ifndef FLATBUFFERS_CPP98_STL
  template <typename T>
  void Set(T&& val) {
    using RT = typename std::remove_reference<T>::type;
    Reset();
    type = ChreMessageTraits<typename RT::TableType>::enum_value;
    if (type != ChreMessage::NONE) {
      value = new RT(std::forward<T>(val));
    }
  }
#endif  // FLATBUFFERS_CPP98_STL

  static void *UnPack(const void *obj, ChreMessage type, const flatbuffers::resolver_function_t *resolver);
  flatbuffers::Offset<void> Pack(flatbuffers::FlatBufferBuilder &_fbb, const flatbuffers::rehasher_function_t *_rehasher = nullptr) const;

  chre::fbs::NanoappMessageT *AsNanoappMessage() {
    return type == ChreMessage::NanoappMessage ?
      reinterpret_cast<chre::fbs::NanoappMessageT *>(value) : nullptr;
  }
  const chre::fbs::NanoappMessageT *AsNanoappMessage() const {
    return type == ChreMessage::NanoappMessage ?
      reinterpret_cast<const chre::fbs::NanoappMessageT *>(value) : nullptr;
  }
  chre::fbs::HubInfoRequestT *AsHubInfoRequest() {
    return type == ChreMessage::HubInfoRequest ?
      reinterpret_cast<chre::fbs::HubInfoRequestT *>(value) : nullptr;
  }
  const chre::fbs::HubInfoRequestT *AsHubInfoRequest() const {
    return type == ChreMessage::HubInfoRequest ?
      reinterpret_cast<const chre::fbs::HubInfoRequestT *>(value) : nullptr;
  }
  chre::fbs::HubInfoResponseT *AsHubInfoResponse() {
    return type == ChreMessage::HubInfoResponse ?
      reinterpret_cast<chre::fbs::HubInfoResponseT *>(value) : nullptr;
  }
  const chre::fbs::HubInfoResponseT *AsHubInfoResponse() const {
    return type == ChreMessage::HubInfoResponse ?
      reinterpret_cast<const chre::fbs::HubInfoResponseT *>(value) : nullptr;
  }
  chre::fbs::NanoappListRequestT *AsNanoappListRequest() {
    return type == ChreMessage::NanoappListRequest ?
      reinterpret_cast<chre::fbs::NanoappListRequestT *>(value) : nullptr;
  }
  const chre::fbs::NanoappListRequestT *AsNanoappListRequest() const {
    return type == ChreMessage::NanoappListRequest ?
      reinterpret_cast<const chre::fbs::NanoappListRequestT *>(value) : nullptr;
  }
  chre::fbs::NanoappListResponseT *AsNanoappListResponse() {
    return type == ChreMessage::NanoappListResponse ?
      reinterpret_cast<chre::fbs::NanoappListResponseT *>(value) : nullptr;
  }
  const chre::fbs::NanoappListResponseT *AsNanoappListResponse() const {
    return type == ChreMessage::NanoappListResponse ?
      reinterpret_cast<const chre::fbs::NanoappListResponseT *>(value) : nullptr;
  }
  chre::fbs::LoadNanoappRequestT *AsLoadNanoappRequest() {
    return type == ChreMessage::LoadNanoappRequest ?
      reinterpret_cast<chre::fbs::LoadNanoappRequestT *>(value) : nullptr;
  }
  const chre::fbs::LoadNanoappRequestT *AsLoadNanoappRequest() const {
    return type == ChreMessage::LoadNanoappRequest ?
      reinterpret_cast<const chre::fbs::LoadNanoappRequestT *>(value) : nullptr;
  }
  chre::fbs::LoadNanoappResponseT *AsLoadNanoappResponse() {
    return type == ChreMessage::LoadNanoappResponse ?
      reinterpret_cast<chre::fbs::LoadNanoappResponseT *>(value) : nullptr;
  }
  const chre::fbs::LoadNanoappResponseT *AsLoadNanoappResponse() const {
    return type == ChreMessage::LoadNanoappResponse ?
      reinterpret_cast<const chre::fbs::LoadNanoappResponseT *>(value) : nullptr;
  }
  chre::fbs::UnloadNanoappRequestT *AsUnloadNanoappRequest() {
    return type == ChreMessage::UnloadNanoappRequest ?
      reinterpret_cast<chre::fbs::UnloadNanoappRequestT *>(value) : nullptr;
  }
  const chre::fbs::UnloadNanoappRequestT *AsUnloadNanoappRequest() const {
    return type == ChreMessage::UnloadNanoappRequest ?
      reinterpret_cast<const chre::fbs::UnloadNanoappRequestT *>(value) : nullptr;
  }
  chre::fbs::UnloadNanoappResponseT *AsUnloadNanoappResponse() {
    return type == ChreMessage::UnloadNanoappResponse ?
      reinterpret_cast<chre::fbs::UnloadNanoappResponseT *>(value) : nullptr;
  }
  const chre::fbs::UnloadNanoappResponseT *AsUnloadNanoappResponse() const {
    return type == ChreMessage::UnloadNanoappResponse ?
      reinterpret_cast<const chre::fbs::UnloadNanoappResponseT *>(value) : nullptr;
  }
  chre::fbs::LogMessageT *AsLogMessage() {
    return type == ChreMessage::LogMessage ?
      reinterpret_cast<chre::fbs::LogMessageT *>(value) : nullptr;
  }
  const chre::fbs::LogMessageT *AsLogMessage() const {
    return type == ChreMessage::LogMessage ?
      reinterpret_cast<const chre::fbs::LogMessageT *>(value) : nullptr;
  }
  chre::fbs::TimeSyncMessageT *AsTimeSyncMessage() {
    return type == ChreMessage::TimeSyncMessage ?
      reinterpret_cast<chre::fbs::TimeSyncMessageT *>(value) : nullptr;
  }
  const chre::fbs::TimeSyncMessageT *AsTimeSyncMessage() const {
    return type == ChreMessage::TimeSyncMessage ?
      reinterpret_cast<const chre::fbs::TimeSyncMessageT *>(value) : nullptr;
  }
  chre::fbs::DebugDumpRequestT *AsDebugDumpRequest() {
    return type == ChreMessage::DebugDumpRequest ?
      reinterpret_cast<chre::fbs::DebugDumpRequestT *>(value) : nullptr;
  }
  const chre::fbs::DebugDumpRequestT *AsDebugDumpRequest() const {
    return type == ChreMessage::DebugDumpRequest ?
      reinterpret_cast<const chre::fbs::DebugDumpRequestT *>(value) : nullptr;
  }
  chre::fbs::DebugDumpDataT *AsDebugDumpData() {
    return type == ChreMessage::DebugDumpData ?
      reinterpret_cast<chre::fbs::DebugDumpDataT *>(value) : nullptr;
  }
  const chre::fbs::DebugDumpDataT *AsDebugDumpData() const {
    return type == ChreMessage::DebugDumpData ?
      reinterpret_cast<const chre::fbs::DebugDumpDataT *>(value) : nullptr;
  }
  chre::fbs::DebugDumpResponseT *AsDebugDumpResponse() {
    return type == ChreMessage::DebugDumpResponse ?
      reinterpret_cast<chre::fbs::DebugDumpResponseT *>(value) : nullptr;
  }
  const chre::fbs::DebugDumpResponseT *AsDebugDumpResponse() const {
    return type == ChreMessage::DebugDumpResponse ?
      reinterpret_cast<const chre::fbs::DebugDumpResponseT *>(value) : nullptr;
  }
  chre::fbs::TimeSyncRequestT *AsTimeSyncRequest() {
    return type == ChreMessage::TimeSyncRequest ?
      reinterpret_cast<chre::fbs::TimeSyncRequestT *>(value) : nullptr;
  }
  const chre::fbs::TimeSyncRequestT *AsTimeSyncRequest() const {
    return type == ChreMessage::TimeSyncRequest ?
      reinterpret_cast<const chre::fbs::TimeSyncRequestT *>(value) : nullptr;
  }
  chre::fbs::LowPowerMicAccessRequestT *AsLowPowerMicAccessRequest() {
    return type == ChreMessage::LowPowerMicAccessRequest ?
      reinterpret_cast<chre::fbs::LowPowerMicAccessRequestT *>(value) : nullptr;
  }
  const chre::fbs::LowPowerMicAccessRequestT *AsLowPowerMicAccessRequest() const {
    return type == ChreMessage::LowPowerMicAccessRequest ?
      reinterpret_cast<const chre::fbs::LowPowerMicAccessRequestT *>(value) : nullptr;
  }
  chre::fbs::LowPowerMicAccessReleaseT *AsLowPowerMicAccessRelease() {
    return type == ChreMessage::LowPowerMicAccessRelease ?
      reinterpret_cast<chre::fbs::LowPowerMicAccessReleaseT *>(value) : nullptr;
  }
  const chre::fbs::LowPowerMicAccessReleaseT *AsLowPowerMicAccessRelease() const {
    return type == ChreMessage::LowPowerMicAccessRelease ?
      reinterpret_cast<const chre::fbs::LowPowerMicAccessReleaseT *>(value) : nullptr;
  }
  chre::fbs::SettingChangeMessageT *AsSettingChangeMessage() {
    return type == ChreMessage::SettingChangeMessage ?
      reinterpret_cast<chre::fbs::SettingChangeMessageT *>(value) : nullptr;
  }
  const chre::fbs::SettingChangeMessageT *AsSettingChangeMessage() const {
    return type == ChreMessage::SettingChangeMessage ?
      reinterpret_cast<const chre::fbs::SettingChangeMessageT *>(value) : nullptr;
  }
  chre::fbs::LogMessageV2T *AsLogMessageV2() {
    return type == ChreMessage::LogMessageV2 ?
      reinterpret_cast<chre::fbs::LogMessageV2T *>(value) : nullptr;
  }
  const chre::fbs::LogMessageV2T *AsLogMessageV2() const {
    return type == ChreMessage::LogMessageV2 ?
      reinterpret_cast<const chre::fbs::LogMessageV2T *>(value) : nullptr;
  }
  chre::fbs::SelfTestRequestT *AsSelfTestRequest() {
    return type == ChreMessage::SelfTestRequest ?
      reinterpret_cast<chre::fbs::SelfTestRequestT *>(value) : nullptr;
  }
  const chre::fbs::SelfTestRequestT *AsSelfTestRequest() const {
    return type == ChreMessage::SelfTestRequest ?
      reinterpret_cast<const chre::fbs::SelfTestRequestT *>(value) : nullptr;
  }
  chre::fbs::SelfTestResponseT *AsSelfTestResponse() {
    return type == ChreMessage::SelfTestResponse ?
      reinterpret_cast<chre::fbs::SelfTestResponseT *>(value) : nullptr;
  }
  const chre::fbs::SelfTestResponseT *AsSelfTestResponse() const {
    return type == ChreMessage::SelfTestResponse ?
      reinterpret_cast<const chre::fbs::SelfTestResponseT *>(value) : nullptr;
  }
  chre::fbs::HostEndpointConnectedT *AsHostEndpointConnected() {
    return type == ChreMessage::HostEndpointConnected ?
      reinterpret_cast<chre::fbs::HostEndpointConnectedT *>(value) : nullptr;
  }
  const chre::fbs::HostEndpointConnectedT *AsHostEndpointConnected() const {
    return type == ChreMessage::HostEndpointConnected ?
      reinterpret_cast<const chre::fbs::HostEndpointConnectedT *>(value) : nullptr;
  }
  chre::fbs::HostEndpointDisconnectedT *AsHostEndpointDisconnected() {
    return type == ChreMessage::HostEndpointDisconnected ?
      reinterpret_cast<chre::fbs::HostEndpointDisconnectedT *>(value) : nullptr;
  }
  const chre::fbs::HostEndpointDisconnectedT *AsHostEndpointDisconnected() const {
    return type == ChreMessage::HostEndpointDisconnected ?
      reinterpret_cast<const chre::fbs::HostEndpointDisconnectedT *>(value) : nullptr;
  }
  chre::fbs::MetricLogT *AsMetricLog() {
    return type == ChreMessage::MetricLog ?
      reinterpret_cast<chre::fbs::MetricLogT *>(value) : nullptr;
  }
  const chre::fbs::MetricLogT *AsMetricLog() const {
    return type == ChreMessage::MetricLog ?
      reinterpret_cast<const chre::fbs::MetricLogT *>(value) : nullptr;
  }
  chre::fbs::BatchedMetricLogT *AsBatchedMetricLog() {
    return type == ChreMessage::BatchedMetricLog ?
      reinterpret_cast<chre::fbs::BatchedMetricLogT *>(value) : nullptr;
  }
  const chre::fbs::BatchedMetricLogT *AsBatchedMetricLog() const {
    return type == ChreMessage::BatchedMetricLog ?
      reinterpret_cast<const chre::fbs::BatchedMetricLogT *>(value) : nullptr;
  }
  chre::fbs::NanConfigurationRequestT *AsNanConfigurationRequest() {
    return type == ChreMessage::NanConfigurationRequest ?
      reinterpret_cast<chre::fbs::NanConfigurationRequestT *>(value) : nullptr;
  }
  const chre::fbs::NanConfigurationRequestT *AsNanConfigurationRequest() const {
    return type == ChreMessage::NanConfigurationRequest ?
      reinterpret_cast<const chre::fbs::NanConfigurationRequestT *>(value) : nullptr;
  }
  chre::fbs::NanConfigurationUpdateT *AsNanConfigurationUpdate() {
    return type == ChreMessage::NanConfigurationUpdate ?
      reinterpret_cast<chre::fbs::NanConfigurationUpdateT *>(value) : nullptr;
  }
  const chre::fbs::NanConfigurationUpdateT *AsNanConfigurationUpdate() const {
    return type == ChreMessage::NanConfigurationUpdate ?
      reinterpret_cast<const chre::fbs::NanConfigurationUpdateT *>(value) : nullptr;
  }
  chre::fbs::DebugConfigurationT *AsDebugConfiguration() {
    return type == ChreMessage::DebugConfiguration ?
      reinterpret_cast<chre::fbs::DebugConfigurationT *>(value) : nullptr;
  }
  const chre::fbs::DebugConfigurationT *AsDebugConfiguration() const {
    return type == ChreMessage::DebugConfiguration ?
      reinterpret_cast<const chre::fbs::DebugConfigurationT *>(value) : nullptr;
  }
  chre::fbs::PulseRequestT *AsPulseRequest() {
    return type == ChreMessage::PulseRequest ?
      reinterpret_cast<chre::fbs::PulseRequestT *>(value) : nullptr;
  }
  const chre::fbs::PulseRequestT *AsPulseRequest() const {
    return type == ChreMessage::PulseRequest ?
      reinterpret_cast<const chre::fbs::PulseRequestT *>(value) : nullptr;
  }
  chre::fbs::PulseResponseT *AsPulseResponse() {
    return type == ChreMessage::PulseResponse ?
      reinterpret_cast<chre::fbs::PulseResponseT *>(value) : nullptr;
  }
  const chre::fbs::PulseResponseT *AsPulseResponse() const {
    return type == ChreMessage::PulseResponse ?
      reinterpret_cast<const chre::fbs::PulseResponseT *>(value) : nullptr;
  }
  chre::fbs::NanoappTokenDatabaseInfoT *AsNanoappTokenDatabaseInfo() {
    return type == ChreMessage::NanoappTokenDatabaseInfo ?
      reinterpret_cast<chre::fbs::NanoappTokenDatabaseInfoT *>(value) : nullptr;
  }
  const chre::fbs::NanoappTokenDatabaseInfoT *AsNanoappTokenDatabaseInfo() const {
    return type == ChreMessage::NanoappTokenDatabaseInfo ?
      reinterpret_cast<const chre::fbs::NanoappTokenDatabaseInfoT *>(value) : nullptr;
  }
  chre::fbs::MessageDeliveryStatusT *AsMessageDeliveryStatus() {
    return type == ChreMessage::MessageDeliveryStatus ?
      reinterpret_cast<chre::fbs::MessageDeliveryStatusT *>(value) : nullptr;
  }
  const chre::fbs::MessageDeliveryStatusT *AsMessageDeliveryStatus() const {
    return type == ChreMessage::MessageDeliveryStatus ?
      reinterpret_cast<const chre::fbs::MessageDeliveryStatusT *>(value) : nullptr;
  }
  chre::fbs::BtSocketOpenT *AsBtSocketOpen() {
    return type == ChreMessage::BtSocketOpen ?
      reinterpret_cast<chre::fbs::BtSocketOpenT *>(value) : nullptr;
  }
  const chre::fbs::BtSocketOpenT *AsBtSocketOpen() const {
    return type == ChreMessage::BtSocketOpen ?
      reinterpret_cast<const chre::fbs::BtSocketOpenT *>(value) : nullptr;
  }
  chre::fbs::BtSocketOpenResponseT *AsBtSocketOpenResponse() {
    return type == ChreMessage::BtSocketOpenResponse ?
      reinterpret_cast<chre::fbs::BtSocketOpenResponseT *>(value) : nullptr;
  }
  const chre::fbs::BtSocketOpenResponseT *AsBtSocketOpenResponse() const {
    return type == ChreMessage::BtSocketOpenResponse ?
      reinterpret_cast<const chre::fbs::BtSocketOpenResponseT *>(value) : nullptr;
  }
  chre::fbs::BtSocketCloseT *AsBtSocketClose() {
    return type == ChreMessage::BtSocketClose ?
      reinterpret_cast<chre::fbs::BtSocketCloseT *>(value) : nullptr;
  }
  const chre::fbs::BtSocketCloseT *AsBtSocketClose() const {
    return type == ChreMessage::BtSocketClose ?
      reinterpret_cast<const chre::fbs::BtSocketCloseT *>(value) : nullptr;
  }
  chre::fbs::BtSocketCloseResponseT *AsBtSocketCloseResponse() {
    return type == ChreMessage::BtSocketCloseResponse ?
      reinterpret_cast<chre::fbs::BtSocketCloseResponseT *>(value) : nullptr;
  }
  const chre::fbs::BtSocketCloseResponseT *AsBtSocketCloseResponse() const {
    return type == ChreMessage::BtSocketCloseResponse ?
      reinterpret_cast<const chre::fbs::BtSocketCloseResponseT *>(value) : nullptr;
  }
  chre::fbs::GetMessageHubsAndEndpointsRequestT *AsGetMessageHubsAndEndpointsRequest() {
    return type == ChreMessage::GetMessageHubsAndEndpointsRequest ?
      reinterpret_cast<chre::fbs::GetMessageHubsAndEndpointsRequestT *>(value) : nullptr;
  }
  const chre::fbs::GetMessageHubsAndEndpointsRequestT *AsGetMessageHubsAndEndpointsRequest() const {
    return type == ChreMessage::GetMessageHubsAndEndpointsRequest ?
      reinterpret_cast<const chre::fbs::GetMessageHubsAndEndpointsRequestT *>(value) : nullptr;
  }
  chre::fbs::GetMessageHubsAndEndpointsResponseT *AsGetMessageHubsAndEndpointsResponse() {
    return type == ChreMessage::GetMessageHubsAndEndpointsResponse ?
      reinterpret_cast<chre::fbs::GetMessageHubsAndEndpointsResponseT *>(value) : nullptr;
  }
  const chre::fbs::GetMessageHubsAndEndpointsResponseT *AsGetMessageHubsAndEndpointsResponse() const {
    return type == ChreMessage::GetMessageHubsAndEndpointsResponse ?
      reinterpret_cast<const chre::fbs::GetMessageHubsAndEndpointsResponseT *>(value) : nullptr;
  }
  chre::fbs::RegisterMessageHubT *AsRegisterMessageHub() {
    return type == ChreMessage::RegisterMessageHub ?
      reinterpret_cast<chre::fbs::RegisterMessageHubT *>(value) : nullptr;
  }
  const chre::fbs::RegisterMessageHubT *AsRegisterMessageHub() const {
    return type == ChreMessage::RegisterMessageHub ?
      reinterpret_cast<const chre::fbs::RegisterMessageHubT *>(value) : nullptr;
  }
  chre::fbs::UnregisterMessageHubT *AsUnregisterMessageHub() {
    return type == ChreMessage::UnregisterMessageHub ?
      reinterpret_cast<chre::fbs::UnregisterMessageHubT *>(value) : nullptr;
  }
  const chre::fbs::UnregisterMessageHubT *AsUnregisterMessageHub() const {
    return type == ChreMessage::UnregisterMessageHub ?
      reinterpret_cast<const chre::fbs::UnregisterMessageHubT *>(value) : nullptr;
  }
  chre::fbs::RegisterEndpointT *AsRegisterEndpoint() {
    return type == ChreMessage::RegisterEndpoint ?
      reinterpret_cast<chre::fbs::RegisterEndpointT *>(value) : nullptr;
  }
  const chre::fbs::RegisterEndpointT *AsRegisterEndpoint() const {
    return type == ChreMessage::RegisterEndpoint ?
      reinterpret_cast<const chre::fbs::RegisterEndpointT *>(value) : nullptr;
  }
  chre::fbs::UnregisterEndpointT *AsUnregisterEndpoint() {
    return type == ChreMessage::UnregisterEndpoint ?
      reinterpret_cast<chre::fbs::UnregisterEndpointT *>(value) : nullptr;
  }
  const chre::fbs::UnregisterEndpointT *AsUnregisterEndpoint() const {
    return type == ChreMessage::UnregisterEndpoint ?
      reinterpret_cast<const chre::fbs::UnregisterEndpointT *>(value) : nullptr;
  }
  chre::fbs::OpenEndpointSessionRequestT *AsOpenEndpointSessionRequest() {
    return type == ChreMessage::OpenEndpointSessionRequest ?
      reinterpret_cast<chre::fbs::OpenEndpointSessionRequestT *>(value) : nullptr;
  }
  const chre::fbs::OpenEndpointSessionRequestT *AsOpenEndpointSessionRequest() const {
    return type == ChreMessage::OpenEndpointSessionRequest ?
      reinterpret_cast<const chre::fbs::OpenEndpointSessionRequestT *>(value) : nullptr;
  }
  chre::fbs::EndpointSessionOpenedT *AsEndpointSessionOpened() {
    return type == ChreMessage::EndpointSessionOpened ?
      reinterpret_cast<chre::fbs::EndpointSessionOpenedT *>(value) : nullptr;
  }
  const chre::fbs::EndpointSessionOpenedT *AsEndpointSessionOpened() const {
    return type == ChreMessage::EndpointSessionOpened ?
      reinterpret_cast<const chre::fbs::EndpointSessionOpenedT *>(value) : nullptr;
  }
  chre::fbs::EndpointSessionClosedT *AsEndpointSessionClosed() {
    return type == ChreMessage::EndpointSessionClosed ?
      reinterpret_cast<chre::fbs::EndpointSessionClosedT *>(value) : nullptr;
  }
  const chre::fbs::EndpointSessionClosedT *AsEndpointSessionClosed() const {
    return type == ChreMessage::EndpointSessionClosed ?
      reinterpret_cast<const chre::fbs::EndpointSessionClosedT *>(value) : nullptr;
  }
  chre::fbs::EndpointSessionMessageT *AsEndpointSessionMessage() {
    return type == ChreMessage::EndpointSessionMessage ?
      reinterpret_cast<chre::fbs::EndpointSessionMessageT *>(value) : nullptr;
  }
  const chre::fbs::EndpointSessionMessageT *AsEndpointSessionMessage() const {
    return type == ChreMessage::EndpointSessionMessage ?
      reinterpret_cast<const chre::fbs::EndpointSessionMessageT *>(value) : nullptr;
  }
  chre::fbs::EndpointSessionMessageDeliveryStatusT *AsEndpointSessionMessageDeliveryStatus() {
    return type == ChreMessage::EndpointSessionMessageDeliveryStatus ?
      reinterpret_cast<chre::fbs::EndpointSessionMessageDeliveryStatusT *>(value) : nullptr;
  }
  const chre::fbs::EndpointSessionMessageDeliveryStatusT *AsEndpointSessionMessageDeliveryStatus() const {
    return type == ChreMessage::EndpointSessionMessageDeliveryStatus ?
      reinterpret_cast<const chre::fbs::EndpointSessionMessageDeliveryStatusT *>(value) : nullptr;
  }
  chre::fbs::BtSocketCapabilitiesRequestT *AsBtSocketCapabilitiesRequest() {
    return type == ChreMessage::BtSocketCapabilitiesRequest ?
      reinterpret_cast<chre::fbs::BtSocketCapabilitiesRequestT *>(value) : nullptr;
  }
  const chre::fbs::BtSocketCapabilitiesRequestT *AsBtSocketCapabilitiesRequest() const {
    return type == ChreMessage::BtSocketCapabilitiesRequest ?
      reinterpret_cast<const chre::fbs::BtSocketCapabilitiesRequestT *>(value) : nullptr;
  }
  chre::fbs::BtSocketCapabilitiesResponseT *AsBtSocketCapabilitiesResponse() {
    return type == ChreMessage::BtSocketCapabilitiesResponse ?
      reinterpret_cast<chre::fbs::BtSocketCapabilitiesResponseT *>(value) : nullptr;
  }
  const chre::fbs::BtSocketCapabilitiesResponseT *AsBtSocketCapabilitiesResponse() const {
    return type == ChreMessage::BtSocketCapabilitiesResponse ?
      reinterpret_cast<const chre::fbs::BtSocketCapabilitiesResponseT *>(value) : nullptr;
  }
  chre::fbs::AddServiceToEndpointT *AsAddServiceToEndpoint() {
    return type == ChreMessage::AddServiceToEndpoint ?
      reinterpret_cast<chre::fbs::AddServiceToEndpointT *>(value) : nullptr;
  }
  const chre::fbs::AddServiceToEndpointT *AsAddServiceToEndpoint() const {
    return type == ChreMessage::AddServiceToEndpoint ?
      reinterpret_cast<const chre::fbs::AddServiceToEndpointT *>(value) : nullptr;
  }
  chre::fbs::EndpointReadyT *AsEndpointReady() {
    return type == ChreMessage::EndpointReady ?
      reinterpret_cast<chre::fbs::EndpointReadyT *>(value) : nullptr;
  }
  const chre::fbs::EndpointReadyT *AsEndpointReady() const {
    return type == ChreMessage::EndpointReady ?
      reinterpret_cast<const chre::fbs::EndpointReadyT *>(value) : nullptr;
  }
};

bool VerifyChreMessage(flatbuffers::Verifier &verifier, const void *obj, ChreMessage type);
bool VerifyChreMessageVector(flatbuffers::Verifier &verifier, const flatbuffers::Vector<flatbuffers::Offset<void>> *values, const flatbuffers::Vector<uint8_t> *types);

FLATBUFFERS_MANUALLY_ALIGNED_STRUCT(2) HostAddress FLATBUFFERS_FINAL_CLASS {
 private:
  uint16_t client_id_;

 public:
  HostAddress() {
    memset(static_cast<void *>(this), 0, sizeof(HostAddress));
  }
  HostAddress(uint16_t _client_id)
      : client_id_(flatbuffers::EndianScalar(_client_id)) {
  }
  uint16_t client_id() const {
    return flatbuffers::EndianScalar(client_id_);
  }
  void mutate_client_id(uint16_t _client_id) {
    flatbuffers::WriteScalar(&client_id_, _client_id);
  }
};
FLATBUFFERS_STRUCT_END(HostAddress, 2);

struct NanoappMessageT : public flatbuffers::NativeTable {
  typedef NanoappMessage TableType;
  uint64_t app_id;
  uint32_t message_type;
  uint16_t host_endpoint;
  std::vector<uint8_t> message;
  uint32_t message_permissions;
  uint32_t permissions;
  bool woke_host;
  bool is_reliable;
  uint32_t message_sequence_number;
  NanoappMessageT()
      : app_id(0),
        message_type(0),
        host_endpoint(65534),
        message_permissions(0),
        permissions(0),
        woke_host(false),
        is_reliable(false),
        message_sequence_number(0) {
  }
};

/// Represents a message sent to/from a nanoapp from/to a client on the host
struct NanoappMessage FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef NanoappMessageT NativeTableType;
  typedef NanoappMessageBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_APP_ID = 4,
    VT_MESSAGE_TYPE = 6,
    VT_HOST_ENDPOINT = 8,
    VT_MESSAGE = 10,
    VT_MESSAGE_PERMISSIONS = 12,
    VT_PERMISSIONS = 14,
    VT_WOKE_HOST = 16,
    VT_IS_RELIABLE = 18,
    VT_MESSAGE_SEQUENCE_NUMBER = 20
  };
  uint64_t app_id() const {
    return GetField<uint64_t>(VT_APP_ID, 0);
  }
  bool mutate_app_id(uint64_t _app_id) {
    return SetField<uint64_t>(VT_APP_ID, _app_id, 0);
  }
  uint32_t message_type() const {
    return GetField<uint32_t>(VT_MESSAGE_TYPE, 0);
  }
  bool mutate_message_type(uint32_t _message_type) {
    return SetField<uint32_t>(VT_MESSAGE_TYPE, _message_type, 0);
  }
  /// Identifies the host-side endpoint on the host that sent or should receive
  /// this message. The default value is a special value defined in the HAL and
  /// elsewhere that indicates that the endpoint is unspecified.
  uint16_t host_endpoint() const {
    return GetField<uint16_t>(VT_HOST_ENDPOINT, 65534);
  }
  bool mutate_host_endpoint(uint16_t _host_endpoint) {
    return SetField<uint16_t>(VT_HOST_ENDPOINT, _host_endpoint, 65534);
  }
  /// Vector containing arbitrary application-specific message data
  const flatbuffers::Vector<uint8_t> *message() const {
    return GetPointer<const flatbuffers::Vector<uint8_t> *>(VT_MESSAGE);
  }
  flatbuffers::Vector<uint8_t> *mutable_message() {
    return GetPointer<flatbuffers::Vector<uint8_t> *>(VT_MESSAGE);
  }
  /// List of Android permissions that cover the contents of a message from a
  /// nanoapp to the host.
  /// These permissions are used to record and attribute access to
  /// permissions-controlled resources.
  uint32_t message_permissions() const {
    return GetField<uint32_t>(VT_MESSAGE_PERMISSIONS, 0);
  }
  bool mutate_message_permissions(uint32_t _message_permissions) {
    return SetField<uint32_t>(VT_MESSAGE_PERMISSIONS, _message_permissions, 0);
  }
  /// List of Android permissions declared by the nanoapp / granted to the host.
  /// For messages from a nanoaapp to the host, this must be a superset of
  /// message_permissions.
  uint32_t permissions() const {
    return GetField<uint32_t>(VT_PERMISSIONS, 0);
  }
  bool mutate_permissions(uint32_t _permissions) {
    return SetField<uint32_t>(VT_PERMISSIONS, _permissions, 0);
  }
  bool woke_host() const {
    return GetField<uint8_t>(VT_WOKE_HOST, 0) != 0;
  }
  bool mutate_woke_host(bool _woke_host) {
    return SetField<uint8_t>(VT_WOKE_HOST, static_cast<uint8_t>(_woke_host), 0);
  }
  bool is_reliable() const {
    return GetField<uint8_t>(VT_IS_RELIABLE, 0) != 0;
  }
  bool mutate_is_reliable(bool _is_reliable) {
    return SetField<uint8_t>(VT_IS_RELIABLE, static_cast<uint8_t>(_is_reliable), 0);
  }
  uint32_t message_sequence_number() const {
    return GetField<uint32_t>(VT_MESSAGE_SEQUENCE_NUMBER, 0);
  }
  bool mutate_message_sequence_number(uint32_t _message_sequence_number) {
    return SetField<uint32_t>(VT_MESSAGE_SEQUENCE_NUMBER, _message_sequence_number, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint64_t>(verifier, VT_APP_ID) &&
           VerifyField<uint32_t>(verifier, VT_MESSAGE_TYPE) &&
           VerifyField<uint16_t>(verifier, VT_HOST_ENDPOINT) &&
           VerifyOffsetRequired(verifier, VT_MESSAGE) &&
           verifier.VerifyVector(message()) &&
           VerifyField<uint32_t>(verifier, VT_MESSAGE_PERMISSIONS) &&
           VerifyField<uint32_t>(verifier, VT_PERMISSIONS) &&
           VerifyField<uint8_t>(verifier, VT_WOKE_HOST) &&
           VerifyField<uint8_t>(verifier, VT_IS_RELIABLE) &&
           VerifyField<uint32_t>(verifier, VT_MESSAGE_SEQUENCE_NUMBER) &&
           verifier.EndTable();
  }
  NanoappMessageT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(NanoappMessageT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<NanoappMessage> Pack(flatbuffers::FlatBufferBuilder &_fbb, const NanoappMessageT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct NanoappMessageBuilder {
  typedef NanoappMessage Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_app_id(uint64_t app_id) {
    fbb_.AddElement<uint64_t>(NanoappMessage::VT_APP_ID, app_id, 0);
  }
  void add_message_type(uint32_t message_type) {
    fbb_.AddElement<uint32_t>(NanoappMessage::VT_MESSAGE_TYPE, message_type, 0);
  }
  void add_host_endpoint(uint16_t host_endpoint) {
    fbb_.AddElement<uint16_t>(NanoappMessage::VT_HOST_ENDPOINT, host_endpoint, 65534);
  }
  void add_message(flatbuffers::Offset<flatbuffers::Vector<uint8_t>> message) {
    fbb_.AddOffset(NanoappMessage::VT_MESSAGE, message);
  }
  void add_message_permissions(uint32_t message_permissions) {
    fbb_.AddElement<uint32_t>(NanoappMessage::VT_MESSAGE_PERMISSIONS, message_permissions, 0);
  }
  void add_permissions(uint32_t permissions) {
    fbb_.AddElement<uint32_t>(NanoappMessage::VT_PERMISSIONS, permissions, 0);
  }
  void add_woke_host(bool woke_host) {
    fbb_.AddElement<uint8_t>(NanoappMessage::VT_WOKE_HOST, static_cast<uint8_t>(woke_host), 0);
  }
  void add_is_reliable(bool is_reliable) {
    fbb_.AddElement<uint8_t>(NanoappMessage::VT_IS_RELIABLE, static_cast<uint8_t>(is_reliable), 0);
  }
  void add_message_sequence_number(uint32_t message_sequence_number) {
    fbb_.AddElement<uint32_t>(NanoappMessage::VT_MESSAGE_SEQUENCE_NUMBER, message_sequence_number, 0);
  }
  explicit NanoappMessageBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  NanoappMessageBuilder &operator=(const NanoappMessageBuilder &);
  flatbuffers::Offset<NanoappMessage> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<NanoappMessage>(end);
    fbb_.Required(o, NanoappMessage::VT_MESSAGE);
    return o;
  }
};

inline flatbuffers::Offset<NanoappMessage> CreateNanoappMessage(
    flatbuffers::FlatBufferBuilder &_fbb,
    uint64_t app_id = 0,
    uint32_t message_type = 0,
    uint16_t host_endpoint = 65534,
    flatbuffers::Offset<flatbuffers::Vector<uint8_t>> message = 0,
    uint32_t message_permissions = 0,
    uint32_t permissions = 0,
    bool woke_host = false,
    bool is_reliable = false,
    uint32_t message_sequence_number = 0) {
  NanoappMessageBuilder builder_(_fbb);
  builder_.add_app_id(app_id);
  builder_.add_message_sequence_number(message_sequence_number);
  builder_.add_permissions(permissions);
  builder_.add_message_permissions(message_permissions);
  builder_.add_message(message);
  builder_.add_message_type(message_type);
  builder_.add_host_endpoint(host_endpoint);
  builder_.add_is_reliable(is_reliable);
  builder_.add_woke_host(woke_host);
  return builder_.Finish();
}

inline flatbuffers::Offset<NanoappMessage> CreateNanoappMessageDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    uint64_t app_id = 0,
    uint32_t message_type = 0,
    uint16_t host_endpoint = 65534,
    const std::vector<uint8_t> *message = nullptr,
    uint32_t message_permissions = 0,
    uint32_t permissions = 0,
    bool woke_host = false,
    bool is_reliable = false,
    uint32_t message_sequence_number = 0) {
  auto message__ = message ? _fbb.CreateVector<uint8_t>(*message) : 0;
  return chre::fbs::CreateNanoappMessage(
      _fbb,
      app_id,
      message_type,
      host_endpoint,
      message__,
      message_permissions,
      permissions,
      woke_host,
      is_reliable,
      message_sequence_number);
}

flatbuffers::Offset<NanoappMessage> CreateNanoappMessage(flatbuffers::FlatBufferBuilder &_fbb, const NanoappMessageT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct MessageDeliveryStatusT : public flatbuffers::NativeTable {
  typedef MessageDeliveryStatus TableType;
  uint32_t message_sequence_number;
  int8_t error_code;
  MessageDeliveryStatusT()
      : message_sequence_number(0),
        error_code(0) {
  }
};

struct MessageDeliveryStatus FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef MessageDeliveryStatusT NativeTableType;
  typedef MessageDeliveryStatusBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_MESSAGE_SEQUENCE_NUMBER = 4,
    VT_ERROR_CODE = 6
  };
  uint32_t message_sequence_number() const {
    return GetField<uint32_t>(VT_MESSAGE_SEQUENCE_NUMBER, 0);
  }
  bool mutate_message_sequence_number(uint32_t _message_sequence_number) {
    return SetField<uint32_t>(VT_MESSAGE_SEQUENCE_NUMBER, _message_sequence_number, 0);
  }
  int8_t error_code() const {
    return GetField<int8_t>(VT_ERROR_CODE, 0);
  }
  bool mutate_error_code(int8_t _error_code) {
    return SetField<int8_t>(VT_ERROR_CODE, _error_code, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint32_t>(verifier, VT_MESSAGE_SEQUENCE_NUMBER) &&
           VerifyField<int8_t>(verifier, VT_ERROR_CODE) &&
           verifier.EndTable();
  }
  MessageDeliveryStatusT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(MessageDeliveryStatusT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<MessageDeliveryStatus> Pack(flatbuffers::FlatBufferBuilder &_fbb, const MessageDeliveryStatusT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct MessageDeliveryStatusBuilder {
  typedef MessageDeliveryStatus Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_message_sequence_number(uint32_t message_sequence_number) {
    fbb_.AddElement<uint32_t>(MessageDeliveryStatus::VT_MESSAGE_SEQUENCE_NUMBER, message_sequence_number, 0);
  }
  void add_error_code(int8_t error_code) {
    fbb_.AddElement<int8_t>(MessageDeliveryStatus::VT_ERROR_CODE, error_code, 0);
  }
  explicit MessageDeliveryStatusBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  MessageDeliveryStatusBuilder &operator=(const MessageDeliveryStatusBuilder &);
  flatbuffers::Offset<MessageDeliveryStatus> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<MessageDeliveryStatus>(end);
    return o;
  }
};

inline flatbuffers::Offset<MessageDeliveryStatus> CreateMessageDeliveryStatus(
    flatbuffers::FlatBufferBuilder &_fbb,
    uint32_t message_sequence_number = 0,
    int8_t error_code = 0) {
  MessageDeliveryStatusBuilder builder_(_fbb);
  builder_.add_message_sequence_number(message_sequence_number);
  builder_.add_error_code(error_code);
  return builder_.Finish();
}

flatbuffers::Offset<MessageDeliveryStatus> CreateMessageDeliveryStatus(flatbuffers::FlatBufferBuilder &_fbb, const MessageDeliveryStatusT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct HubInfoRequestT : public flatbuffers::NativeTable {
  typedef HubInfoRequest TableType;
  HubInfoRequestT() {
  }
};

struct HubInfoRequest FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef HubInfoRequestT NativeTableType;
  typedef HubInfoRequestBuilder Builder;
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           verifier.EndTable();
  }
  HubInfoRequestT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(HubInfoRequestT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<HubInfoRequest> Pack(flatbuffers::FlatBufferBuilder &_fbb, const HubInfoRequestT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct HubInfoRequestBuilder {
  typedef HubInfoRequest Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  explicit HubInfoRequestBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  HubInfoRequestBuilder &operator=(const HubInfoRequestBuilder &);
  flatbuffers::Offset<HubInfoRequest> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<HubInfoRequest>(end);
    return o;
  }
};

inline flatbuffers::Offset<HubInfoRequest> CreateHubInfoRequest(
    flatbuffers::FlatBufferBuilder &_fbb) {
  HubInfoRequestBuilder builder_(_fbb);
  return builder_.Finish();
}

flatbuffers::Offset<HubInfoRequest> CreateHubInfoRequest(flatbuffers::FlatBufferBuilder &_fbb, const HubInfoRequestT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct HubInfoResponseT : public flatbuffers::NativeTable {
  typedef HubInfoResponse TableType;
  std::vector<int8_t> name;
  std::vector<int8_t> vendor;
  std::vector<int8_t> toolchain;
  uint32_t platform_version;
  uint32_t toolchain_version;
  float peak_mips;
  float stopped_power;
  float sleep_power;
  float peak_power;
  uint32_t max_msg_len;
  uint64_t platform_id;
  uint32_t chre_platform_version;
  bool supports_reliable_messages;
  HubInfoResponseT()
      : platform_version(0),
        toolchain_version(0),
        peak_mips(0.0f),
        stopped_power(0.0f),
        sleep_power(0.0f),
        peak_power(0.0f),
        max_msg_len(0),
        platform_id(0),
        chre_platform_version(0),
        supports_reliable_messages(false) {
  }
};

struct HubInfoResponse FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef HubInfoResponseT NativeTableType;
  typedef HubInfoResponseBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_NAME = 4,
    VT_VENDOR = 6,
    VT_TOOLCHAIN = 8,
    VT_PLATFORM_VERSION = 10,
    VT_TOOLCHAIN_VERSION = 12,
    VT_PEAK_MIPS = 14,
    VT_STOPPED_POWER = 16,
    VT_SLEEP_POWER = 18,
    VT_PEAK_POWER = 20,
    VT_MAX_MSG_LEN = 22,
    VT_PLATFORM_ID = 24,
    VT_CHRE_PLATFORM_VERSION = 26,
    VT_SUPPORTS_RELIABLE_MESSAGES = 28
  };
  /// The name of the hub. Nominally a UTF-8 string, but note that we're not
  /// using the built-in "string" data type from FlatBuffers here, because the
  /// generated C++ uses std::string which is not well-supported in CHRE. This
  /// applies for vendor and toolchain as well.
  const flatbuffers::Vector<int8_t> *name() const {
    return GetPointer<const flatbuffers::Vector<int8_t> *>(VT_NAME);
  }
  flatbuffers::Vector<int8_t> *mutable_name() {
    return GetPointer<flatbuffers::Vector<int8_t> *>(VT_NAME);
  }
  const flatbuffers::Vector<int8_t> *vendor() const {
    return GetPointer<const flatbuffers::Vector<int8_t> *>(VT_VENDOR);
  }
  flatbuffers::Vector<int8_t> *mutable_vendor() {
    return GetPointer<flatbuffers::Vector<int8_t> *>(VT_VENDOR);
  }
  const flatbuffers::Vector<int8_t> *toolchain() const {
    return GetPointer<const flatbuffers::Vector<int8_t> *>(VT_TOOLCHAIN);
  }
  flatbuffers::Vector<int8_t> *mutable_toolchain() {
    return GetPointer<flatbuffers::Vector<int8_t> *>(VT_TOOLCHAIN);
  }
  /// Legacy platform version reported in the HAL; semantics not strictly
  /// defined
  uint32_t platform_version() const {
    return GetField<uint32_t>(VT_PLATFORM_VERSION, 0);
  }
  bool mutate_platform_version(uint32_t _platform_version) {
    return SetField<uint32_t>(VT_PLATFORM_VERSION, _platform_version, 0);
  }
  /// Toolchain version reported in the HAL; semantics not strictly defined
  uint32_t toolchain_version() const {
    return GetField<uint32_t>(VT_TOOLCHAIN_VERSION, 0);
  }
  bool mutate_toolchain_version(uint32_t _toolchain_version) {
    return SetField<uint32_t>(VT_TOOLCHAIN_VERSION, _toolchain_version, 0);
  }
  float peak_mips() const {
    return GetField<float>(VT_PEAK_MIPS, 0.0f);
  }
  bool mutate_peak_mips(float _peak_mips) {
    return SetField<float>(VT_PEAK_MIPS, _peak_mips, 0.0f);
  }
  float stopped_power() const {
    return GetField<float>(VT_STOPPED_POWER, 0.0f);
  }
  bool mutate_stopped_power(float _stopped_power) {
    return SetField<float>(VT_STOPPED_POWER, _stopped_power, 0.0f);
  }
  float sleep_power() const {
    return GetField<float>(VT_SLEEP_POWER, 0.0f);
  }
  bool mutate_sleep_power(float _sleep_power) {
    return SetField<float>(VT_SLEEP_POWER, _sleep_power, 0.0f);
  }
  float peak_power() const {
    return GetField<float>(VT_PEAK_POWER, 0.0f);
  }
  bool mutate_peak_power(float _peak_power) {
    return SetField<float>(VT_PEAK_POWER, _peak_power, 0.0f);
  }
  /// Maximum size regular message that can be sent to a nanoapp
  uint32_t max_msg_len() const {
    return GetField<uint32_t>(VT_MAX_MSG_LEN, 0);
  }
  bool mutate_max_msg_len(uint32_t _max_msg_len) {
    return SetField<uint32_t>(VT_MAX_MSG_LEN, _max_msg_len, 0);
  }
  /// @see chreGetPlatformId()
  uint64_t platform_id() const {
    return GetField<uint64_t>(VT_PLATFORM_ID, 0);
  }
  bool mutate_platform_id(uint64_t _platform_id) {
    return SetField<uint64_t>(VT_PLATFORM_ID, _platform_id, 0);
  }
  /// @see chreGetVersion()
  uint32_t chre_platform_version() const {
    return GetField<uint32_t>(VT_CHRE_PLATFORM_VERSION, 0);
  }
  bool mutate_chre_platform_version(uint32_t _chre_platform_version) {
    return SetField<uint32_t>(VT_CHRE_PLATFORM_VERSION, _chre_platform_version, 0);
  }
  /// Whether reliable messages are supported
  bool supports_reliable_messages() const {
    return GetField<uint8_t>(VT_SUPPORTS_RELIABLE_MESSAGES, 0) != 0;
  }
  bool mutate_supports_reliable_messages(bool _supports_reliable_messages) {
    return SetField<uint8_t>(VT_SUPPORTS_RELIABLE_MESSAGES, static_cast<uint8_t>(_supports_reliable_messages), 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_NAME) &&
           verifier.VerifyVector(name()) &&
           VerifyOffset(verifier, VT_VENDOR) &&
           verifier.VerifyVector(vendor()) &&
           VerifyOffset(verifier, VT_TOOLCHAIN) &&
           verifier.VerifyVector(toolchain()) &&
           VerifyField<uint32_t>(verifier, VT_PLATFORM_VERSION) &&
           VerifyField<uint32_t>(verifier, VT_TOOLCHAIN_VERSION) &&
           VerifyField<float>(verifier, VT_PEAK_MIPS) &&
           VerifyField<float>(verifier, VT_STOPPED_POWER) &&
           VerifyField<float>(verifier, VT_SLEEP_POWER) &&
           VerifyField<float>(verifier, VT_PEAK_POWER) &&
           VerifyField<uint32_t>(verifier, VT_MAX_MSG_LEN) &&
           VerifyField<uint64_t>(verifier, VT_PLATFORM_ID) &&
           VerifyField<uint32_t>(verifier, VT_CHRE_PLATFORM_VERSION) &&
           VerifyField<uint8_t>(verifier, VT_SUPPORTS_RELIABLE_MESSAGES) &&
           verifier.EndTable();
  }
  HubInfoResponseT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(HubInfoResponseT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<HubInfoResponse> Pack(flatbuffers::FlatBufferBuilder &_fbb, const HubInfoResponseT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct HubInfoResponseBuilder {
  typedef HubInfoResponse Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_name(flatbuffers::Offset<flatbuffers::Vector<int8_t>> name) {
    fbb_.AddOffset(HubInfoResponse::VT_NAME, name);
  }
  void add_vendor(flatbuffers::Offset<flatbuffers::Vector<int8_t>> vendor) {
    fbb_.AddOffset(HubInfoResponse::VT_VENDOR, vendor);
  }
  void add_toolchain(flatbuffers::Offset<flatbuffers::Vector<int8_t>> toolchain) {
    fbb_.AddOffset(HubInfoResponse::VT_TOOLCHAIN, toolchain);
  }
  void add_platform_version(uint32_t platform_version) {
    fbb_.AddElement<uint32_t>(HubInfoResponse::VT_PLATFORM_VERSION, platform_version, 0);
  }
  void add_toolchain_version(uint32_t toolchain_version) {
    fbb_.AddElement<uint32_t>(HubInfoResponse::VT_TOOLCHAIN_VERSION, toolchain_version, 0);
  }
  void add_peak_mips(float peak_mips) {
    fbb_.AddElement<float>(HubInfoResponse::VT_PEAK_MIPS, peak_mips, 0.0f);
  }
  void add_stopped_power(float stopped_power) {
    fbb_.AddElement<float>(HubInfoResponse::VT_STOPPED_POWER, stopped_power, 0.0f);
  }
  void add_sleep_power(float sleep_power) {
    fbb_.AddElement<float>(HubInfoResponse::VT_SLEEP_POWER, sleep_power, 0.0f);
  }
  void add_peak_power(float peak_power) {
    fbb_.AddElement<float>(HubInfoResponse::VT_PEAK_POWER, peak_power, 0.0f);
  }
  void add_max_msg_len(uint32_t max_msg_len) {
    fbb_.AddElement<uint32_t>(HubInfoResponse::VT_MAX_MSG_LEN, max_msg_len, 0);
  }
  void add_platform_id(uint64_t platform_id) {
    fbb_.AddElement<uint64_t>(HubInfoResponse::VT_PLATFORM_ID, platform_id, 0);
  }
  void add_chre_platform_version(uint32_t chre_platform_version) {
    fbb_.AddElement<uint32_t>(HubInfoResponse::VT_CHRE_PLATFORM_VERSION, chre_platform_version, 0);
  }
  void add_supports_reliable_messages(bool supports_reliable_messages) {
    fbb_.AddElement<uint8_t>(HubInfoResponse::VT_SUPPORTS_RELIABLE_MESSAGES, static_cast<uint8_t>(supports_reliable_messages), 0);
  }
  explicit HubInfoResponseBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  HubInfoResponseBuilder &operator=(const HubInfoResponseBuilder &);
  flatbuffers::Offset<HubInfoResponse> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<HubInfoResponse>(end);
    return o;
  }
};

inline flatbuffers::Offset<HubInfoResponse> CreateHubInfoResponse(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::Vector<int8_t>> name = 0,
    flatbuffers::Offset<flatbuffers::Vector<int8_t>> vendor = 0,
    flatbuffers::Offset<flatbuffers::Vector<int8_t>> toolchain = 0,
    uint32_t platform_version = 0,
    uint32_t toolchain_version = 0,
    float peak_mips = 0.0f,
    float stopped_power = 0.0f,
    float sleep_power = 0.0f,
    float peak_power = 0.0f,
    uint32_t max_msg_len = 0,
    uint64_t platform_id = 0,
    uint32_t chre_platform_version = 0,
    bool supports_reliable_messages = false) {
  HubInfoResponseBuilder builder_(_fbb);
  builder_.add_platform_id(platform_id);
  builder_.add_chre_platform_version(chre_platform_version);
  builder_.add_max_msg_len(max_msg_len);
  builder_.add_peak_power(peak_power);
  builder_.add_sleep_power(sleep_power);
  builder_.add_stopped_power(stopped_power);
  builder_.add_peak_mips(peak_mips);
  builder_.add_toolchain_version(toolchain_version);
  builder_.add_platform_version(platform_version);
  builder_.add_toolchain(toolchain);
  builder_.add_vendor(vendor);
  builder_.add_name(name);
  builder_.add_supports_reliable_messages(supports_reliable_messages);
  return builder_.Finish();
}

inline flatbuffers::Offset<HubInfoResponse> CreateHubInfoResponseDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const std::vector<int8_t> *name = nullptr,
    const std::vector<int8_t> *vendor = nullptr,
    const std::vector<int8_t> *toolchain = nullptr,
    uint32_t platform_version = 0,
    uint32_t toolchain_version = 0,
    float peak_mips = 0.0f,
    float stopped_power = 0.0f,
    float sleep_power = 0.0f,
    float peak_power = 0.0f,
    uint32_t max_msg_len = 0,
    uint64_t platform_id = 0,
    uint32_t chre_platform_version = 0,
    bool supports_reliable_messages = false) {
  auto name__ = name ? _fbb.CreateVector<int8_t>(*name) : 0;
  auto vendor__ = vendor ? _fbb.CreateVector<int8_t>(*vendor) : 0;
  auto toolchain__ = toolchain ? _fbb.CreateVector<int8_t>(*toolchain) : 0;
  return chre::fbs::CreateHubInfoResponse(
      _fbb,
      name__,
      vendor__,
      toolchain__,
      platform_version,
      toolchain_version,
      peak_mips,
      stopped_power,
      sleep_power,
      peak_power,
      max_msg_len,
      platform_id,
      chre_platform_version,
      supports_reliable_messages);
}

flatbuffers::Offset<HubInfoResponse> CreateHubInfoResponse(flatbuffers::FlatBufferBuilder &_fbb, const HubInfoResponseT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct NanoappListRequestT : public flatbuffers::NativeTable {
  typedef NanoappListRequest TableType;
  NanoappListRequestT() {
  }
};

struct NanoappListRequest FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef NanoappListRequestT NativeTableType;
  typedef NanoappListRequestBuilder Builder;
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           verifier.EndTable();
  }
  NanoappListRequestT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(NanoappListRequestT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<NanoappListRequest> Pack(flatbuffers::FlatBufferBuilder &_fbb, const NanoappListRequestT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct NanoappListRequestBuilder {
  typedef NanoappListRequest Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  explicit NanoappListRequestBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  NanoappListRequestBuilder &operator=(const NanoappListRequestBuilder &);
  flatbuffers::Offset<NanoappListRequest> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<NanoappListRequest>(end);
    return o;
  }
};

inline flatbuffers::Offset<NanoappListRequest> CreateNanoappListRequest(
    flatbuffers::FlatBufferBuilder &_fbb) {
  NanoappListRequestBuilder builder_(_fbb);
  return builder_.Finish();
}

flatbuffers::Offset<NanoappListRequest> CreateNanoappListRequest(flatbuffers::FlatBufferBuilder &_fbb, const NanoappListRequestT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct NanoappRpcServiceT : public flatbuffers::NativeTable {
  typedef NanoappRpcService TableType;
  uint64_t id;
  uint32_t version;
  NanoappRpcServiceT()
      : id(0),
        version(0) {
  }
};

/// Metadata regarding a Nanoapp RPC service. See the Android API
/// core/java/android/hardware/location/NanoAppRpcService.java for more details
/// on how this value is used by the Android application.
struct NanoappRpcService FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef NanoappRpcServiceT NativeTableType;
  typedef NanoappRpcServiceBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_ID = 4,
    VT_VERSION = 6
  };
  uint64_t id() const {
    return GetField<uint64_t>(VT_ID, 0);
  }
  bool mutate_id(uint64_t _id) {
    return SetField<uint64_t>(VT_ID, _id, 0);
  }
  uint32_t version() const {
    return GetField<uint32_t>(VT_VERSION, 0);
  }
  bool mutate_version(uint32_t _version) {
    return SetField<uint32_t>(VT_VERSION, _version, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint64_t>(verifier, VT_ID) &&
           VerifyField<uint32_t>(verifier, VT_VERSION) &&
           verifier.EndTable();
  }
  NanoappRpcServiceT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(NanoappRpcServiceT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<NanoappRpcService> Pack(flatbuffers::FlatBufferBuilder &_fbb, const NanoappRpcServiceT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct NanoappRpcServiceBuilder {
  typedef NanoappRpcService Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_id(uint64_t id) {
    fbb_.AddElement<uint64_t>(NanoappRpcService::VT_ID, id, 0);
  }
  void add_version(uint32_t version) {
    fbb_.AddElement<uint32_t>(NanoappRpcService::VT_VERSION, version, 0);
  }
  explicit NanoappRpcServiceBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  NanoappRpcServiceBuilder &operator=(const NanoappRpcServiceBuilder &);
  flatbuffers::Offset<NanoappRpcService> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<NanoappRpcService>(end);
    return o;
  }
};

inline flatbuffers::Offset<NanoappRpcService> CreateNanoappRpcService(
    flatbuffers::FlatBufferBuilder &_fbb,
    uint64_t id = 0,
    uint32_t version = 0) {
  NanoappRpcServiceBuilder builder_(_fbb);
  builder_.add_id(id);
  builder_.add_version(version);
  return builder_.Finish();
}

flatbuffers::Offset<NanoappRpcService> CreateNanoappRpcService(flatbuffers::FlatBufferBuilder &_fbb, const NanoappRpcServiceT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct NanoappListEntryT : public flatbuffers::NativeTable {
  typedef NanoappListEntry TableType;
  uint64_t app_id;
  uint32_t version;
  bool enabled;
  bool is_system;
  uint32_t permissions;
  std::vector<std::unique_ptr<chre::fbs::NanoappRpcServiceT>> rpc_services;
  NanoappListEntryT()
      : app_id(0),
        version(0),
        enabled(true),
        is_system(false),
        permissions(0) {
  }
};

struct NanoappListEntry FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef NanoappListEntryT NativeTableType;
  typedef NanoappListEntryBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_APP_ID = 4,
    VT_VERSION = 6,
    VT_ENABLED = 8,
    VT_IS_SYSTEM = 10,
    VT_PERMISSIONS = 12,
    VT_RPC_SERVICES = 14
  };
  uint64_t app_id() const {
    return GetField<uint64_t>(VT_APP_ID, 0);
  }
  bool mutate_app_id(uint64_t _app_id) {
    return SetField<uint64_t>(VT_APP_ID, _app_id, 0);
  }
  uint32_t version() const {
    return GetField<uint32_t>(VT_VERSION, 0);
  }
  bool mutate_version(uint32_t _version) {
    return SetField<uint32_t>(VT_VERSION, _version, 0);
  }
  bool enabled() const {
    return GetField<uint8_t>(VT_ENABLED, 1) != 0;
  }
  bool mutate_enabled(bool _enabled) {
    return SetField<uint8_t>(VT_ENABLED, static_cast<uint8_t>(_enabled), 1);
  }
  /// Whether the nanoapp is a pre-loaded "system" nanoapp, i.e. one that should
  /// not show up in the list of nanoapps in the context hub HAL. System
  /// nanoapps are typically used to leverage CHRE for some device functionality
  /// and do not interact via the context hub HAL.
  bool is_system() const {
    return GetField<uint8_t>(VT_IS_SYSTEM, 0) != 0;
  }
  bool mutate_is_system(bool _is_system) {
    return SetField<uint8_t>(VT_IS_SYSTEM, static_cast<uint8_t>(_is_system), 0);
  }
  /// Nanoapp permissions, if supported. Nanoapp permissions are required on
  /// CHRE API v1.5+, and are defined in chre/util/system/napp_permissions.h
  uint32_t permissions() const {
    return GetField<uint32_t>(VT_PERMISSIONS, 0);
  }
  bool mutate_permissions(uint32_t _permissions) {
    return SetField<uint32_t>(VT_PERMISSIONS, _permissions, 0);
  }
  /// The list of RPC services supported by this nanoapp.
  const flatbuffers::Vector<flatbuffers::Offset<chre::fbs::NanoappRpcService>> *rpc_services() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<chre::fbs::NanoappRpcService>> *>(VT_RPC_SERVICES);
  }
  flatbuffers::Vector<flatbuffers::Offset<chre::fbs::NanoappRpcService>> *mutable_rpc_services() {
    return GetPointer<flatbuffers::Vector<flatbuffers::Offset<chre::fbs::NanoappRpcService>> *>(VT_RPC_SERVICES);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint64_t>(verifier, VT_APP_ID) &&
           VerifyField<uint32_t>(verifier, VT_VERSION) &&
           VerifyField<uint8_t>(verifier, VT_ENABLED) &&
           VerifyField<uint8_t>(verifier, VT_IS_SYSTEM) &&
           VerifyField<uint32_t>(verifier, VT_PERMISSIONS) &&
           VerifyOffset(verifier, VT_RPC_SERVICES) &&
           verifier.VerifyVector(rpc_services()) &&
           verifier.VerifyVectorOfTables(rpc_services()) &&
           verifier.EndTable();
  }
  NanoappListEntryT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(NanoappListEntryT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<NanoappListEntry> Pack(flatbuffers::FlatBufferBuilder &_fbb, const NanoappListEntryT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct NanoappListEntryBuilder {
  typedef NanoappListEntry Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_app_id(uint64_t app_id) {
    fbb_.AddElement<uint64_t>(NanoappListEntry::VT_APP_ID, app_id, 0);
  }
  void add_version(uint32_t version) {
    fbb_.AddElement<uint32_t>(NanoappListEntry::VT_VERSION, version, 0);
  }
  void add_enabled(bool enabled) {
    fbb_.AddElement<uint8_t>(NanoappListEntry::VT_ENABLED, static_cast<uint8_t>(enabled), 1);
  }
  void add_is_system(bool is_system) {
    fbb_.AddElement<uint8_t>(NanoappListEntry::VT_IS_SYSTEM, static_cast<uint8_t>(is_system), 0);
  }
  void add_permissions(uint32_t permissions) {
    fbb_.AddElement<uint32_t>(NanoappListEntry::VT_PERMISSIONS, permissions, 0);
  }
  void add_rpc_services(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<chre::fbs::NanoappRpcService>>> rpc_services) {
    fbb_.AddOffset(NanoappListEntry::VT_RPC_SERVICES, rpc_services);
  }
  explicit NanoappListEntryBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  NanoappListEntryBuilder &operator=(const NanoappListEntryBuilder &);
  flatbuffers::Offset<NanoappListEntry> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<NanoappListEntry>(end);
    return o;
  }
};

inline flatbuffers::Offset<NanoappListEntry> CreateNanoappListEntry(
    flatbuffers::FlatBufferBuilder &_fbb,
    uint64_t app_id = 0,
    uint32_t version = 0,
    bool enabled = true,
    bool is_system = false,
    uint32_t permissions = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<chre::fbs::NanoappRpcService>>> rpc_services = 0) {
  NanoappListEntryBuilder builder_(_fbb);
  builder_.add_app_id(app_id);
  builder_.add_rpc_services(rpc_services);
  builder_.add_permissions(permissions);
  builder_.add_version(version);
  builder_.add_is_system(is_system);
  builder_.add_enabled(enabled);
  return builder_.Finish();
}

inline flatbuffers::Offset<NanoappListEntry> CreateNanoappListEntryDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    uint64_t app_id = 0,
    uint32_t version = 0,
    bool enabled = true,
    bool is_system = false,
    uint32_t permissions = 0,
    const std::vector<flatbuffers::Offset<chre::fbs::NanoappRpcService>> *rpc_services = nullptr) {
  auto rpc_services__ = rpc_services ? _fbb.CreateVector<flatbuffers::Offset<chre::fbs::NanoappRpcService>>(*rpc_services) : 0;
  return chre::fbs::CreateNanoappListEntry(
      _fbb,
      app_id,
      version,
      enabled,
      is_system,
      permissions,
      rpc_services__);
}

flatbuffers::Offset<NanoappListEntry> CreateNanoappListEntry(flatbuffers::FlatBufferBuilder &_fbb, const NanoappListEntryT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct NanoappListResponseT : public flatbuffers::NativeTable {
  typedef NanoappListResponse TableType;
  std::vector<std::unique_ptr<chre::fbs::NanoappListEntryT>> nanoapps;
  NanoappListResponseT() {
  }
};

struct NanoappListResponse FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef NanoappListResponseT NativeTableType;
  typedef NanoappListResponseBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_NANOAPPS = 4
  };
  const flatbuffers::Vector<flatbuffers::Offset<chre::fbs::NanoappListEntry>> *nanoapps() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<chre::fbs::NanoappListEntry>> *>(VT_NANOAPPS);
  }
  flatbuffers::Vector<flatbuffers::Offset<chre::fbs::NanoappListEntry>> *mutable_nanoapps() {
    return GetPointer<flatbuffers::Vector<flatbuffers::Offset<chre::fbs::NanoappListEntry>> *>(VT_NANOAPPS);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffsetRequired(verifier, VT_NANOAPPS) &&
           verifier.VerifyVector(nanoapps()) &&
           verifier.VerifyVectorOfTables(nanoapps()) &&
           verifier.EndTable();
  }
  NanoappListResponseT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(NanoappListResponseT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<NanoappListResponse> Pack(flatbuffers::FlatBufferBuilder &_fbb, const NanoappListResponseT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct NanoappListResponseBuilder {
  typedef NanoappListResponse Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_nanoapps(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<chre::fbs::NanoappListEntry>>> nanoapps) {
    fbb_.AddOffset(NanoappListResponse::VT_NANOAPPS, nanoapps);
  }
  explicit NanoappListResponseBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  NanoappListResponseBuilder &operator=(const NanoappListResponseBuilder &);
  flatbuffers::Offset<NanoappListResponse> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<NanoappListResponse>(end);
    fbb_.Required(o, NanoappListResponse::VT_NANOAPPS);
    return o;
  }
};

inline flatbuffers::Offset<NanoappListResponse> CreateNanoappListResponse(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<chre::fbs::NanoappListEntry>>> nanoapps = 0) {
  NanoappListResponseBuilder builder_(_fbb);
  builder_.add_nanoapps(nanoapps);
  return builder_.Finish();
}

inline flatbuffers::Offset<NanoappListResponse> CreateNanoappListResponseDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const std::vector<flatbuffers::Offset<chre::fbs::NanoappListEntry>> *nanoapps = nullptr) {
  auto nanoapps__ = nanoapps ? _fbb.CreateVector<flatbuffers::Offset<chre::fbs::NanoappListEntry>>(*nanoapps) : 0;
  return chre::fbs::CreateNanoappListResponse(
      _fbb,
      nanoapps__);
}

flatbuffers::Offset<NanoappListResponse> CreateNanoappListResponse(flatbuffers::FlatBufferBuilder &_fbb, const NanoappListResponseT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct LoadNanoappRequestT : public flatbuffers::NativeTable {
  typedef LoadNanoappRequest TableType;
  uint32_t transaction_id;
  uint64_t app_id;
  uint32_t app_version;
  uint32_t target_api_version;
  std::vector<uint8_t> app_binary;
  uint32_t fragment_id;
  uint32_t total_app_size;
  std::vector<int8_t> app_binary_file_name;
  uint32_t app_flags;
  bool respond_before_start;
  LoadNanoappRequestT()
      : transaction_id(0),
        app_id(0),
        app_version(0),
        target_api_version(0),
        fragment_id(0),
        total_app_size(0),
        app_flags(0),
        respond_before_start(false) {
  }
};

/// Represents a request for loading a nanoapp.
/// The nanaopp can either be requested to be loaded via a file or via a buffer.
/// For loading via a file, the following steps will be taken:
/// 1. The loader sends a LoadNanoappRequest message to CHRE. app_binary must
///    be set for legacy purposes, but should be empty. Additionally,
///    fragment_id and total_app_size are unused in this request. The loading
///    that happens as part of this request is serialized, but asynchronous
///    meaning that load requests will be processed in the order they are sent
///    but multiple requests can be outstanding at any given time.
/// 2. CHRE stores the filename and waits until its event loop is able to
///    process the request.
/// 3. Once ready, the nanoapp will be loaded from the file specified in the
///    original request and will send a callback indicating the
///    completion/failure of the request.
/// For loading via a buffer, loading may optionally be fragmented into multiple
/// sequential requests, which will follow the following steps:
/// 1. The loader sends a LoadNanoappRequest message to CHRE. If the request
///    is fragmented, then the fields fragment_id and total_app_size must
///    be defined. Once the first fragment is sent to CHRE, all subsequent
///    fragments must be delivered before a new LoadNanoappRequest can be
///    issued. If a new request is received while a current request has
///    outstanding fragments, the current request will be overridden with the
///    new one.
/// 2. CHRE preallocates the required amount of memory, and loads app_binary,
///    appending to already loaded fragments as appropriate.
/// 3. If the request is fragmented, then the requestor must sequentially send
///    multiple LoadNanoappRequest with incremental nanoapp binary fragments.
///    CHRE will respond with LoadNanoappResponse for each request. For
///    requests starting from the second fragment, all fields except
///    fragment_id and app_binary should be ignored by CHRE.
///
///    Once the LoadNanoappRepsonse for the last fragment is received
///    by the HAL, the HAL client will receive a callback indicating the
///    completion/failure of a load request.
///
/// If any request fragment is lost, then the entire load request will be
/// considered to have failed. If the request times out (e.g. the requestor
/// process crashes), then the load request will be cancelled at CHRE and fail.
struct LoadNanoappRequest FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef LoadNanoappRequestT NativeTableType;
  typedef LoadNanoappRequestBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_TRANSACTION_ID = 4,
    VT_APP_ID = 6,
    VT_APP_VERSION = 8,
    VT_TARGET_API_VERSION = 10,
    VT_APP_BINARY = 12,
    VT_FRAGMENT_ID = 14,
    VT_TOTAL_APP_SIZE = 16,
    VT_APP_BINARY_FILE_NAME = 18,
    VT_APP_FLAGS = 20,
    VT_RESPOND_BEFORE_START = 22
  };
  uint32_t transaction_id() const {
    return GetField<uint32_t>(VT_TRANSACTION_ID, 0);
  }
  bool mutate_transaction_id(uint32_t _transaction_id) {
    return SetField<uint32_t>(VT_TRANSACTION_ID, _transaction_id, 0);
  }
  uint64_t app_id() const {
    return GetField<uint64_t>(VT_APP_ID, 0);
  }
  bool mutate_app_id(uint64_t _app_id) {
    return SetField<uint64_t>(VT_APP_ID, _app_id, 0);
  }
  uint32_t app_version() const {
    return GetField<uint32_t>(VT_APP_VERSION, 0);
  }
  bool mutate_app_version(uint32_t _app_version) {
    return SetField<uint32_t>(VT_APP_VERSION, _app_version, 0);
  }
  uint32_t target_api_version() const {
    return GetField<uint32_t>(VT_TARGET_API_VERSION, 0);
  }
  bool mutate_target_api_version(uint32_t _target_api_version) {
    return SetField<uint32_t>(VT_TARGET_API_VERSION, _target_api_version, 0);
  }
  const flatbuffers::Vector<uint8_t> *app_binary() const {
    return GetPointer<const flatbuffers::Vector<uint8_t> *>(VT_APP_BINARY);
  }
  flatbuffers::Vector<uint8_t> *mutable_app_binary() {
    return GetPointer<flatbuffers::Vector<uint8_t> *>(VT_APP_BINARY);
  }
  /// Fields that are relevant for fragmented loading
  /// The framgent count starts at 1 and should end at the total number of
  /// fragments. For clients that do not support fragmented loading, the
  /// default behavior should be to assume one fragment.
  uint32_t fragment_id() const {
    return GetField<uint32_t>(VT_FRAGMENT_ID, 0);
  }
  bool mutate_fragment_id(uint32_t _fragment_id) {
    return SetField<uint32_t>(VT_FRAGMENT_ID, _fragment_id, 0);
  }
  uint32_t total_app_size() const {
    return GetField<uint32_t>(VT_TOTAL_APP_SIZE, 0);
  }
  bool mutate_total_app_size(uint32_t _total_app_size) {
    return SetField<uint32_t>(VT_TOTAL_APP_SIZE, _total_app_size, 0);
  }
  /// Null-terminated ASCII string containing the file name that contains the
  /// app binary to be loaded.
  const flatbuffers::Vector<int8_t> *app_binary_file_name() const {
    return GetPointer<const flatbuffers::Vector<int8_t> *>(VT_APP_BINARY_FILE_NAME);
  }
  flatbuffers::Vector<int8_t> *mutable_app_binary_file_name() {
    return GetPointer<flatbuffers::Vector<int8_t> *>(VT_APP_BINARY_FILE_NAME);
  }
  /// The nanoapp flag values from the nanoapp header defined in
  /// build/build_template.mk. Refer to that file for more details.
  uint32_t app_flags() const {
    return GetField<uint32_t>(VT_APP_FLAGS, 0);
  }
  bool mutate_app_flags(uint32_t _app_flags) {
    return SetField<uint32_t>(VT_APP_FLAGS, _app_flags, 0);
  }
  /// If true and fragmented loading is requested, the LoadNanoappResponse
  /// for the last fragment will be sent after the fragment was confirmed
  /// to be placed in memory and no additional response will be sent after
  /// the nanoapp is linked and started in the framework.
  bool respond_before_start() const {
    return GetField<uint8_t>(VT_RESPOND_BEFORE_START, 0) != 0;
  }
  bool mutate_respond_before_start(bool _respond_before_start) {
    return SetField<uint8_t>(VT_RESPOND_BEFORE_START, static_cast<uint8_t>(_respond_before_start), 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint32_t>(verifier, VT_TRANSACTION_ID) &&
           VerifyField<uint64_t>(verifier, VT_APP_ID) &&
           VerifyField<uint32_t>(verifier, VT_APP_VERSION) &&
           VerifyField<uint32_t>(verifier, VT_TARGET_API_VERSION) &&
           VerifyOffsetRequired(verifier, VT_APP_BINARY) &&
           verifier.VerifyVector(app_binary()) &&
           VerifyField<uint32_t>(verifier, VT_FRAGMENT_ID) &&
           VerifyField<uint32_t>(verifier, VT_TOTAL_APP_SIZE) &&
           VerifyOffset(verifier, VT_APP_BINARY_FILE_NAME) &&
           verifier.VerifyVector(app_binary_file_name()) &&
           VerifyField<uint32_t>(verifier, VT_APP_FLAGS) &&
           VerifyField<uint8_t>(verifier, VT_RESPOND_BEFORE_START) &&
           verifier.EndTable();
  }
  LoadNanoappRequestT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(LoadNanoappRequestT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<LoadNanoappRequest> Pack(flatbuffers::FlatBufferBuilder &_fbb, const LoadNanoappRequestT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct LoadNanoappRequestBuilder {
  typedef LoadNanoappRequest Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_transaction_id(uint32_t transaction_id) {
    fbb_.AddElement<uint32_t>(LoadNanoappRequest::VT_TRANSACTION_ID, transaction_id, 0);
  }
  void add_app_id(uint64_t app_id) {
    fbb_.AddElement<uint64_t>(LoadNanoappRequest::VT_APP_ID, app_id, 0);
  }
  void add_app_version(uint32_t app_version) {
    fbb_.AddElement<uint32_t>(LoadNanoappRequest::VT_APP_VERSION, app_version, 0);
  }
  void add_target_api_version(uint32_t target_api_version) {
    fbb_.AddElement<uint32_t>(LoadNanoappRequest::VT_TARGET_API_VERSION, target_api_version, 0);
  }
  void add_app_binary(flatbuffers::Offset<flatbuffers::Vector<uint8_t>> app_binary) {
    fbb_.AddOffset(LoadNanoappRequest::VT_APP_BINARY, app_binary);
  }
  void add_fragment_id(uint32_t fragment_id) {
    fbb_.AddElement<uint32_t>(LoadNanoappRequest::VT_FRAGMENT_ID, fragment_id, 0);
  }
  void add_total_app_size(uint32_t total_app_size) {
    fbb_.AddElement<uint32_t>(LoadNanoappRequest::VT_TOTAL_APP_SIZE, total_app_size, 0);
  }
  void add_app_binary_file_name(flatbuffers::Offset<flatbuffers::Vector<int8_t>> app_binary_file_name) {
    fbb_.AddOffset(LoadNanoappRequest::VT_APP_BINARY_FILE_NAME, app_binary_file_name);
  }
  void add_app_flags(uint32_t app_flags) {
    fbb_.AddElement<uint32_t>(LoadNanoappRequest::VT_APP_FLAGS, app_flags, 0);
  }
  void add_respond_before_start(bool respond_before_start) {
    fbb_.AddElement<uint8_t>(LoadNanoappRequest::VT_RESPOND_BEFORE_START, static_cast<uint8_t>(respond_before_start), 0);
  }
  explicit LoadNanoappRequestBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  LoadNanoappRequestBuilder &operator=(const LoadNanoappRequestBuilder &);
  flatbuffers::Offset<LoadNanoappRequest> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<LoadNanoappRequest>(end);
    fbb_.Required(o, LoadNanoappRequest::VT_APP_BINARY);
    return o;
  }
};

inline flatbuffers::Offset<LoadNanoappRequest> CreateLoadNanoappRequest(
    flatbuffers::FlatBufferBuilder &_fbb,
    uint32_t transaction_id = 0,
    uint64_t app_id = 0,
    uint32_t app_version = 0,
    uint32_t target_api_version = 0,
    flatbuffers::Offset<flatbuffers::Vector<uint8_t>> app_binary = 0,
    uint32_t fragment_id = 0,
    uint32_t total_app_size = 0,
    flatbuffers::Offset<flatbuffers::Vector<int8_t>> app_binary_file_name = 0,
    uint32_t app_flags = 0,
    bool respond_before_start = false) {
  LoadNanoappRequestBuilder builder_(_fbb);
  builder_.add_app_id(app_id);
  builder_.add_app_flags(app_flags);
  builder_.add_app_binary_file_name(app_binary_file_name);
  builder_.add_total_app_size(total_app_size);
  builder_.add_fragment_id(fragment_id);
  builder_.add_app_binary(app_binary);
  builder_.add_target_api_version(target_api_version);
  builder_.add_app_version(app_version);
  builder_.add_transaction_id(transaction_id);
  builder_.add_respond_before_start(respond_before_start);
  return builder_.Finish();
}

inline flatbuffers::Offset<LoadNanoappRequest> CreateLoadNanoappRequestDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    uint32_t transaction_id = 0,
    uint64_t app_id = 0,
    uint32_t app_version = 0,
    uint32_t target_api_version = 0,
    const std::vector<uint8_t> *app_binary = nullptr,
    uint32_t fragment_id = 0,
    uint32_t total_app_size = 0,
    const std::vector<int8_t> *app_binary_file_name = nullptr,
    uint32_t app_flags = 0,
    bool respond_before_start = false) {
  auto app_binary__ = app_binary ? _fbb.CreateVector<uint8_t>(*app_binary) : 0;
  auto app_binary_file_name__ = app_binary_file_name ? _fbb.CreateVector<int8_t>(*app_binary_file_name) : 0;
  return chre::fbs::CreateLoadNanoappRequest(
      _fbb,
      transaction_id,
      app_id,
      app_version,
      target_api_version,
      app_binary__,
      fragment_id,
      total_app_size,
      app_binary_file_name__,
      app_flags,
      respond_before_start);
}

flatbuffers::Offset<LoadNanoappRequest> CreateLoadNanoappRequest(flatbuffers::FlatBufferBuilder &_fbb, const LoadNanoappRequestT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct LoadNanoappResponseT : public flatbuffers::NativeTable {
  typedef LoadNanoappResponse TableType;
  uint32_t transaction_id;
  bool success;
  uint32_t fragment_id;
  LoadNanoappResponseT()
      : transaction_id(0),
        success(false),
        fragment_id(0) {
  }
};

struct LoadNanoappResponse FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef LoadNanoappResponseT NativeTableType;
  typedef LoadNanoappResponseBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_TRANSACTION_ID = 4,
    VT_SUCCESS = 6,
    VT_FRAGMENT_ID = 8
  };
  uint32_t transaction_id() const {
    return GetField<uint32_t>(VT_TRANSACTION_ID, 0);
  }
  bool mutate_transaction_id(uint32_t _transaction_id) {
    return SetField<uint32_t>(VT_TRANSACTION_ID, _transaction_id, 0);
  }
  /// Denotes whether a load request succeeded or failed.
  /// If any fragment of a load request fails, the entire load request for
  /// the same transaction will fail.
  bool success() const {
    return GetField<uint8_t>(VT_SUCCESS, 0) != 0;
  }
  bool mutate_success(bool _success) {
    return SetField<uint8_t>(VT_SUCCESS, static_cast<uint8_t>(_success), 0);
  }
  /// The fragment count of the load reponse is for.
  uint32_t fragment_id() const {
    return GetField<uint32_t>(VT_FRAGMENT_ID, 0);
  }
  bool mutate_fragment_id(uint32_t _fragment_id) {
    return SetField<uint32_t>(VT_FRAGMENT_ID, _fragment_id, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint32_t>(verifier, VT_TRANSACTION_ID) &&
           VerifyField<uint8_t>(verifier, VT_SUCCESS) &&
           VerifyField<uint32_t>(verifier, VT_FRAGMENT_ID) &&
           verifier.EndTable();
  }
  LoadNanoappResponseT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(LoadNanoappResponseT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<LoadNanoappResponse> Pack(flatbuffers::FlatBufferBuilder &_fbb, const LoadNanoappResponseT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct LoadNanoappResponseBuilder {
  typedef LoadNanoappResponse Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_transaction_id(uint32_t transaction_id) {
    fbb_.AddElement<uint32_t>(LoadNanoappResponse::VT_TRANSACTION_ID, transaction_id, 0);
  }
  void add_success(bool success) {
    fbb_.AddElement<uint8_t>(LoadNanoappResponse::VT_SUCCESS, static_cast<uint8_t>(success), 0);
  }
  void add_fragment_id(uint32_t fragment_id) {
    fbb_.AddElement<uint32_t>(LoadNanoappResponse::VT_FRAGMENT_ID, fragment_id, 0);
  }
  explicit LoadNanoappResponseBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  LoadNanoappResponseBuilder &operator=(const LoadNanoappResponseBuilder &);
  flatbuffers::Offset<LoadNanoappResponse> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<LoadNanoappResponse>(end);
    return o;
  }
};

inline flatbuffers::Offset<LoadNanoappResponse> CreateLoadNanoappResponse(
    flatbuffers::FlatBufferBuilder &_fbb,
    uint32_t transaction_id = 0,
    bool success = false,
    uint32_t fragment_id = 0) {
  LoadNanoappResponseBuilder builder_(_fbb);
  builder_.add_fragment_id(fragment_id);
  builder_.add_transaction_id(transaction_id);
  builder_.add_success(success);
  return builder_.Finish();
}

flatbuffers::Offset<LoadNanoappResponse> CreateLoadNanoappResponse(flatbuffers::FlatBufferBuilder &_fbb, const LoadNanoappResponseT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct NanoappTokenDatabaseInfoT : public flatbuffers::NativeTable {
  typedef NanoappTokenDatabaseInfo TableType;
  uint32_t instance_id;
  uint64_t app_id;
  uint32_t database_offset_bytes;
  uint32_t database_size_bytes;
  NanoappTokenDatabaseInfoT()
      : instance_id(0),
        app_id(0),
        database_offset_bytes(0),
        database_size_bytes(0) {
  }
};

/// Contains information needed for the host to load the token database for the
/// nanoapp. This message is only sent if a token database section is found in
/// the nanoapp elf binary.
struct NanoappTokenDatabaseInfo FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef NanoappTokenDatabaseInfoT NativeTableType;
  typedef NanoappTokenDatabaseInfoBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_INSTANCE_ID = 4,
    VT_APP_ID = 6,
    VT_DATABASE_OFFSET_BYTES = 8,
    VT_DATABASE_SIZE_BYTES = 10
  };
  uint32_t instance_id() const {
    return GetField<uint32_t>(VT_INSTANCE_ID, 0);
  }
  bool mutate_instance_id(uint32_t _instance_id) {
    return SetField<uint32_t>(VT_INSTANCE_ID, _instance_id, 0);
  }
  uint64_t app_id() const {
    return GetField<uint64_t>(VT_APP_ID, 0);
  }
  bool mutate_app_id(uint64_t _app_id) {
    return SetField<uint64_t>(VT_APP_ID, _app_id, 0);
  }
  /// The size offset of the token database from the start of the address of
  /// the ELF binary in bytes.
  uint32_t database_offset_bytes() const {
    return GetField<uint32_t>(VT_DATABASE_OFFSET_BYTES, 0);
  }
  bool mutate_database_offset_bytes(uint32_t _database_offset_bytes) {
    return SetField<uint32_t>(VT_DATABASE_OFFSET_BYTES, _database_offset_bytes, 0);
  }
  /// The size of the token database section in the ELF binary in bytes.
  uint32_t database_size_bytes() const {
    return GetField<uint32_t>(VT_DATABASE_SIZE_BYTES, 0);
  }
  bool mutate_database_size_bytes(uint32_t _database_size_bytes) {
    return SetField<uint32_t>(VT_DATABASE_SIZE_BYTES, _database_size_bytes, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint32_t>(verifier, VT_INSTANCE_ID) &&
           VerifyField<uint64_t>(verifier, VT_APP_ID) &&
           VerifyField<uint32_t>(verifier, VT_DATABASE_OFFSET_BYTES) &&
           VerifyField<uint32_t>(verifier, VT_DATABASE_SIZE_BYTES) &&
           verifier.EndTable();
  }
  NanoappTokenDatabaseInfoT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(NanoappTokenDatabaseInfoT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<NanoappTokenDatabaseInfo> Pack(flatbuffers::FlatBufferBuilder &_fbb, const NanoappTokenDatabaseInfoT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct NanoappTokenDatabaseInfoBuilder {
  typedef NanoappTokenDatabaseInfo Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_instance_id(uint32_t instance_id) {
    fbb_.AddElement<uint32_t>(NanoappTokenDatabaseInfo::VT_INSTANCE_ID, instance_id, 0);
  }
  void add_app_id(uint64_t app_id) {
    fbb_.AddElement<uint64_t>(NanoappTokenDatabaseInfo::VT_APP_ID, app_id, 0);
  }
  void add_database_offset_bytes(uint32_t database_offset_bytes) {
    fbb_.AddElement<uint32_t>(NanoappTokenDatabaseInfo::VT_DATABASE_OFFSET_BYTES, database_offset_bytes, 0);
  }
  void add_database_size_bytes(uint32_t database_size_bytes) {
    fbb_.AddElement<uint32_t>(NanoappTokenDatabaseInfo::VT_DATABASE_SIZE_BYTES, database_size_bytes, 0);
  }
  explicit NanoappTokenDatabaseInfoBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  NanoappTokenDatabaseInfoBuilder &operator=(const NanoappTokenDatabaseInfoBuilder &);
  flatbuffers::Offset<NanoappTokenDatabaseInfo> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<NanoappTokenDatabaseInfo>(end);
    return o;
  }
};

inline flatbuffers::Offset<NanoappTokenDatabaseInfo> CreateNanoappTokenDatabaseInfo(
    flatbuffers::FlatBufferBuilder &_fbb,
    uint32_t instance_id = 0,
    uint64_t app_id = 0,
    uint32_t database_offset_bytes = 0,
    uint32_t database_size_bytes = 0) {
  NanoappTokenDatabaseInfoBuilder builder_(_fbb);
  builder_.add_app_id(app_id);
  builder_.add_database_size_bytes(database_size_bytes);
  builder_.add_database_offset_bytes(database_offset_bytes);
  builder_.add_instance_id(instance_id);
  return builder_.Finish();
}

flatbuffers::Offset<NanoappTokenDatabaseInfo> CreateNanoappTokenDatabaseInfo(flatbuffers::FlatBufferBuilder &_fbb, const NanoappTokenDatabaseInfoT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct UnloadNanoappRequestT : public flatbuffers::NativeTable {
  typedef UnloadNanoappRequest TableType;
  uint32_t transaction_id;
  uint64_t app_id;
  bool allow_system_nanoapp_unload;
  UnloadNanoappRequestT()
      : transaction_id(0),
        app_id(0),
        allow_system_nanoapp_unload(false) {
  }
};

struct UnloadNanoappRequest FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef UnloadNanoappRequestT NativeTableType;
  typedef UnloadNanoappRequestBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_TRANSACTION_ID = 4,
    VT_APP_ID = 6,
    VT_ALLOW_SYSTEM_NANOAPP_UNLOAD = 8
  };
  uint32_t transaction_id() const {
    return GetField<uint32_t>(VT_TRANSACTION_ID, 0);
  }
  bool mutate_transaction_id(uint32_t _transaction_id) {
    return SetField<uint32_t>(VT_TRANSACTION_ID, _transaction_id, 0);
  }
  uint64_t app_id() const {
    return GetField<uint64_t>(VT_APP_ID, 0);
  }
  bool mutate_app_id(uint64_t _app_id) {
    return SetField<uint64_t>(VT_APP_ID, _app_id, 0);
  }
  /// Set to true to allow this request to unload nanoapps identified as "system
  /// nanoapps", i.e. ones with is_system set to true in NanoappListResponse.
  bool allow_system_nanoapp_unload() const {
    return GetField<uint8_t>(VT_ALLOW_SYSTEM_NANOAPP_UNLOAD, 0) != 0;
  }
  bool mutate_allow_system_nanoapp_unload(bool _allow_system_nanoapp_unload) {
    return SetField<uint8_t>(VT_ALLOW_SYSTEM_NANOAPP_UNLOAD, static_cast<uint8_t>(_allow_system_nanoapp_unload), 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint32_t>(verifier, VT_TRANSACTION_ID) &&
           VerifyField<uint64_t>(verifier, VT_APP_ID) &&
           VerifyField<uint8_t>(verifier, VT_ALLOW_SYSTEM_NANOAPP_UNLOAD) &&
           verifier.EndTable();
  }
  UnloadNanoappRequestT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(UnloadNanoappRequestT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<UnloadNanoappRequest> Pack(flatbuffers::FlatBufferBuilder &_fbb, const UnloadNanoappRequestT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct UnloadNanoappRequestBuilder {
  typedef UnloadNanoappRequest Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_transaction_id(uint32_t transaction_id) {
    fbb_.AddElement<uint32_t>(UnloadNanoappRequest::VT_TRANSACTION_ID, transaction_id, 0);
  }
  void add_app_id(uint64_t app_id) {
    fbb_.AddElement<uint64_t>(UnloadNanoappRequest::VT_APP_ID, app_id, 0);
  }
  void add_allow_system_nanoapp_unload(bool allow_system_nanoapp_unload) {
    fbb_.AddElement<uint8_t>(UnloadNanoappRequest::VT_ALLOW_SYSTEM_NANOAPP_UNLOAD, static_cast<uint8_t>(allow_system_nanoapp_unload), 0);
  }
  explicit UnloadNanoappRequestBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  UnloadNanoappRequestBuilder &operator=(const UnloadNanoappRequestBuilder &);
  flatbuffers::Offset<UnloadNanoappRequest> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<UnloadNanoappRequest>(end);
    return o;
  }
};

inline flatbuffers::Offset<UnloadNanoappRequest> CreateUnloadNanoappRequest(
    flatbuffers::FlatBufferBuilder &_fbb,
    uint32_t transaction_id = 0,
    uint64_t app_id = 0,
    bool allow_system_nanoapp_unload = false) {
  UnloadNanoappRequestBuilder builder_(_fbb);
  builder_.add_app_id(app_id);
  builder_.add_transaction_id(transaction_id);
  builder_.add_allow_system_nanoapp_unload(allow_system_nanoapp_unload);
  return builder_.Finish();
}

flatbuffers::Offset<UnloadNanoappRequest> CreateUnloadNanoappRequest(flatbuffers::FlatBufferBuilder &_fbb, const UnloadNanoappRequestT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct UnloadNanoappResponseT : public flatbuffers::NativeTable {
  typedef UnloadNanoappResponse TableType;
  uint32_t transaction_id;
  bool success;
  UnloadNanoappResponseT()
      : transaction_id(0),
        success(false) {
  }
};

struct UnloadNanoappResponse FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef UnloadNanoappResponseT NativeTableType;
  typedef UnloadNanoappResponseBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_TRANSACTION_ID = 4,
    VT_SUCCESS = 6
  };
  uint32_t transaction_id() const {
    return GetField<uint32_t>(VT_TRANSACTION_ID, 0);
  }
  bool mutate_transaction_id(uint32_t _transaction_id) {
    return SetField<uint32_t>(VT_TRANSACTION_ID, _transaction_id, 0);
  }
  bool success() const {
    return GetField<uint8_t>(VT_SUCCESS, 0) != 0;
  }
  bool mutate_success(bool _success) {
    return SetField<uint8_t>(VT_SUCCESS, static_cast<uint8_t>(_success), 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint32_t>(verifier, VT_TRANSACTION_ID) &&
           VerifyField<uint8_t>(verifier, VT_SUCCESS) &&
           verifier.EndTable();
  }
  UnloadNanoappResponseT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(UnloadNanoappResponseT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<UnloadNanoappResponse> Pack(flatbuffers::FlatBufferBuilder &_fbb, const UnloadNanoappResponseT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct UnloadNanoappResponseBuilder {
  typedef UnloadNanoappResponse Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_transaction_id(uint32_t transaction_id) {
    fbb_.AddElement<uint32_t>(UnloadNanoappResponse::VT_TRANSACTION_ID, transaction_id, 0);
  }
  void add_success(bool success) {
    fbb_.AddElement<uint8_t>(UnloadNanoappResponse::VT_SUCCESS, static_cast<uint8_t>(success), 0);
  }
  explicit UnloadNanoappResponseBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  UnloadNanoappResponseBuilder &operator=(const UnloadNanoappResponseBuilder &);
  flatbuffers::Offset<UnloadNanoappResponse> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<UnloadNanoappResponse>(end);
    return o;
  }
};

inline flatbuffers::Offset<UnloadNanoappResponse> CreateUnloadNanoappResponse(
    flatbuffers::FlatBufferBuilder &_fbb,
    uint32_t transaction_id = 0,
    bool success = false) {
  UnloadNanoappResponseBuilder builder_(_fbb);
  builder_.add_transaction_id(transaction_id);
  builder_.add_success(success);
  return builder_.Finish();
}

flatbuffers::Offset<UnloadNanoappResponse> CreateUnloadNanoappResponse(flatbuffers::FlatBufferBuilder &_fbb, const UnloadNanoappResponseT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct LogMessageT : public flatbuffers::NativeTable {
  typedef LogMessage TableType;
  std::vector<int8_t> buffer;
  LogMessageT() {
  }
};

/// Represents log messages from CHRE.
struct LogMessage FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef LogMessageT NativeTableType;
  typedef LogMessageBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_BUFFER = 4
  };
  /// A buffer containing formatted log data. A flat array is used here to avoid
  /// overhead in serializing and deserializing. The format is as follows:
  ///
  /// uint8_t                 - log level (1 = error, 2 = warning,
  ///                                      3 = info, 4 = debug)
  /// uint64_t, little-endian - timestamp in nanoseconds
  /// char[]                  - message to log
  /// char, \0                - null-terminator
  ///
  /// This pattern repeats until the end of the buffer for multiple log
  /// messages. The last byte will always be a null-terminator. There are no
  /// padding bytes between these fields. Treat this like a packed struct and be
  /// cautious with unaligned access when reading/writing this buffer.
  const flatbuffers::Vector<int8_t> *buffer() const {
    return GetPointer<const flatbuffers::Vector<int8_t> *>(VT_BUFFER);
  }
  flatbuffers::Vector<int8_t> *mutable_buffer() {
    return GetPointer<flatbuffers::Vector<int8_t> *>(VT_BUFFER);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_BUFFER) &&
           verifier.VerifyVector(buffer()) &&
           verifier.EndTable();
  }
  LogMessageT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(LogMessageT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<LogMessage> Pack(flatbuffers::FlatBufferBuilder &_fbb, const LogMessageT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct LogMessageBuilder {
  typedef LogMessage Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_buffer(flatbuffers::Offset<flatbuffers::Vector<int8_t>> buffer) {
    fbb_.AddOffset(LogMessage::VT_BUFFER, buffer);
  }
  explicit LogMessageBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  LogMessageBuilder &operator=(const LogMessageBuilder &);
  flatbuffers::Offset<LogMessage> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<LogMessage>(end);
    return o;
  }
};

inline flatbuffers::Offset<LogMessage> CreateLogMessage(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::Vector<int8_t>> buffer = 0) {
  LogMessageBuilder builder_(_fbb);
  builder_.add_buffer(buffer);
  return builder_.Finish();
}

inline flatbuffers::Offset<LogMessage> CreateLogMessageDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const std::vector<int8_t> *buffer = nullptr) {
  auto buffer__ = buffer ? _fbb.CreateVector<int8_t>(*buffer) : 0;
  return chre::fbs::CreateLogMessage(
      _fbb,
      buffer__);
}

flatbuffers::Offset<LogMessage> CreateLogMessage(flatbuffers::FlatBufferBuilder &_fbb, const LogMessageT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct TimeSyncMessageT : public flatbuffers::NativeTable {
  typedef TimeSyncMessage TableType;
  int64_t offset;
  TimeSyncMessageT()
      : offset(0) {
  }
};

/// Represents a message sent to CHRE to indicate AP timestamp for time sync
struct TimeSyncMessage FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef TimeSyncMessageT NativeTableType;
  typedef TimeSyncMessageBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_OFFSET = 4
  };
  /// Offset between AP and CHRE timestamp
  int64_t offset() const {
    return GetField<int64_t>(VT_OFFSET, 0);
  }
  bool mutate_offset(int64_t _offset) {
    return SetField<int64_t>(VT_OFFSET, _offset, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int64_t>(verifier, VT_OFFSET) &&
           verifier.EndTable();
  }
  TimeSyncMessageT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(TimeSyncMessageT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<TimeSyncMessage> Pack(flatbuffers::FlatBufferBuilder &_fbb, const TimeSyncMessageT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct TimeSyncMessageBuilder {
  typedef TimeSyncMessage Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_offset(int64_t offset) {
    fbb_.AddElement<int64_t>(TimeSyncMessage::VT_OFFSET, offset, 0);
  }
  explicit TimeSyncMessageBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  TimeSyncMessageBuilder &operator=(const TimeSyncMessageBuilder &);
  flatbuffers::Offset<TimeSyncMessage> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<TimeSyncMessage>(end);
    return o;
  }
};

inline flatbuffers::Offset<TimeSyncMessage> CreateTimeSyncMessage(
    flatbuffers::FlatBufferBuilder &_fbb,
    int64_t offset = 0) {
  TimeSyncMessageBuilder builder_(_fbb);
  builder_.add_offset(offset);
  return builder_.Finish();
}

flatbuffers::Offset<TimeSyncMessage> CreateTimeSyncMessage(flatbuffers::FlatBufferBuilder &_fbb, const TimeSyncMessageT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct DebugDumpRequestT : public flatbuffers::NativeTable {
  typedef DebugDumpRequest TableType;
  DebugDumpRequestT() {
  }
};

/// A request to gather and return debugging information. Only one debug dump
/// session can be active at a time. Upon accepting a request, zero or more
/// DebugDumpData messages are generated, followed by a DebugDumpResponse
/// indicating the completion of the operation.
struct DebugDumpRequest FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef DebugDumpRequestT NativeTableType;
  typedef DebugDumpRequestBuilder Builder;
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           verifier.EndTable();
  }
  DebugDumpRequestT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(DebugDumpRequestT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<DebugDumpRequest> Pack(flatbuffers::FlatBufferBuilder &_fbb, const DebugDumpRequestT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct DebugDumpRequestBuilder {
  typedef DebugDumpRequest Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  explicit DebugDumpRequestBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  DebugDumpRequestBuilder &operator=(const DebugDumpRequestBuilder &);
  flatbuffers::Offset<DebugDumpRequest> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<DebugDumpRequest>(end);
    return o;
  }
};

inline flatbuffers::Offset<DebugDumpRequest> CreateDebugDumpRequest(
    flatbuffers::FlatBufferBuilder &_fbb) {
  DebugDumpRequestBuilder builder_(_fbb);
  return builder_.Finish();
}

flatbuffers::Offset<DebugDumpRequest> CreateDebugDumpRequest(flatbuffers::FlatBufferBuilder &_fbb, const DebugDumpRequestT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct DebugDumpDataT : public flatbuffers::NativeTable {
  typedef DebugDumpData TableType;
  std::vector<int8_t> debug_str;
  DebugDumpDataT() {
  }
};

struct DebugDumpData FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef DebugDumpDataT NativeTableType;
  typedef DebugDumpDataBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_DEBUG_STR = 4
  };
  /// Null-terminated ASCII string containing debugging information
  const flatbuffers::Vector<int8_t> *debug_str() const {
    return GetPointer<const flatbuffers::Vector<int8_t> *>(VT_DEBUG_STR);
  }
  flatbuffers::Vector<int8_t> *mutable_debug_str() {
    return GetPointer<flatbuffers::Vector<int8_t> *>(VT_DEBUG_STR);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_DEBUG_STR) &&
           verifier.VerifyVector(debug_str()) &&
           verifier.EndTable();
  }
  DebugDumpDataT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(DebugDumpDataT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<DebugDumpData> Pack(flatbuffers::FlatBufferBuilder &_fbb, const DebugDumpDataT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct DebugDumpDataBuilder {
  typedef DebugDumpData Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_debug_str(flatbuffers::Offset<flatbuffers::Vector<int8_t>> debug_str) {
    fbb_.AddOffset(DebugDumpData::VT_DEBUG_STR, debug_str);
  }
  explicit DebugDumpDataBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  DebugDumpDataBuilder &operator=(const DebugDumpDataBuilder &);
  flatbuffers::Offset<DebugDumpData> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<DebugDumpData>(end);
    return o;
  }
};

inline flatbuffers::Offset<DebugDumpData> CreateDebugDumpData(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::Vector<int8_t>> debug_str = 0) {
  DebugDumpDataBuilder builder_(_fbb);
  builder_.add_debug_str(debug_str);
  return builder_.Finish();
}

inline flatbuffers::Offset<DebugDumpData> CreateDebugDumpDataDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const std::vector<int8_t> *debug_str = nullptr) {
  auto debug_str__ = debug_str ? _fbb.CreateVector<int8_t>(*debug_str) : 0;
  return chre::fbs::CreateDebugDumpData(
      _fbb,
      debug_str__);
}

flatbuffers::Offset<DebugDumpData> CreateDebugDumpData(flatbuffers::FlatBufferBuilder &_fbb, const DebugDumpDataT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct DebugDumpResponseT : public flatbuffers::NativeTable {
  typedef DebugDumpResponse TableType;
  bool success;
  uint32_t data_count;
  DebugDumpResponseT()
      : success(false),
        data_count(0) {
  }
};

struct DebugDumpResponse FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef DebugDumpResponseT NativeTableType;
  typedef DebugDumpResponseBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_SUCCESS = 4,
    VT_DATA_COUNT = 6
  };
  /// true if the request was accepted and a dump was performed, false if it was
  /// rejected or failed to complete for some reason
  bool success() const {
    return GetField<uint8_t>(VT_SUCCESS, 0) != 0;
  }
  bool mutate_success(bool _success) {
    return SetField<uint8_t>(VT_SUCCESS, static_cast<uint8_t>(_success), 0);
  }
  /// The number of DebugDumpData messages sent in this session
  uint32_t data_count() const {
    return GetField<uint32_t>(VT_DATA_COUNT, 0);
  }
  bool mutate_data_count(uint32_t _data_count) {
    return SetField<uint32_t>(VT_DATA_COUNT, _data_count, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint8_t>(verifier, VT_SUCCESS) &&
           VerifyField<uint32_t>(verifier, VT_DATA_COUNT) &&
           verifier.EndTable();
  }
  DebugDumpResponseT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(DebugDumpResponseT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<DebugDumpResponse> Pack(flatbuffers::FlatBufferBuilder &_fbb, const DebugDumpResponseT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct DebugDumpResponseBuilder {
  typedef DebugDumpResponse Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_success(bool success) {
    fbb_.AddElement<uint8_t>(DebugDumpResponse::VT_SUCCESS, static_cast<uint8_t>(success), 0);
  }
  void add_data_count(uint32_t data_count) {
    fbb_.AddElement<uint32_t>(DebugDumpResponse::VT_DATA_COUNT, data_count, 0);
  }
  explicit DebugDumpResponseBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  DebugDumpResponseBuilder &operator=(const DebugDumpResponseBuilder &);
  flatbuffers::Offset<DebugDumpResponse> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<DebugDumpResponse>(end);
    return o;
  }
};

inline flatbuffers::Offset<DebugDumpResponse> CreateDebugDumpResponse(
    flatbuffers::FlatBufferBuilder &_fbb,
    bool success = false,
    uint32_t data_count = 0) {
  DebugDumpResponseBuilder builder_(_fbb);
  builder_.add_data_count(data_count);
  builder_.add_success(success);
  return builder_.Finish();
}

flatbuffers::Offset<DebugDumpResponse> CreateDebugDumpResponse(flatbuffers::FlatBufferBuilder &_fbb, const DebugDumpResponseT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct TimeSyncRequestT : public flatbuffers::NativeTable {
  typedef TimeSyncRequest TableType;
  TimeSyncRequestT() {
  }
};

/// A request from CHRE for host to initiate a time sync message
/// (system feature, platform-specific - not all platforms necessarily use this)
struct TimeSyncRequest FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef TimeSyncRequestT NativeTableType;
  typedef TimeSyncRequestBuilder Builder;
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           verifier.EndTable();
  }
  TimeSyncRequestT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(TimeSyncRequestT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<TimeSyncRequest> Pack(flatbuffers::FlatBufferBuilder &_fbb, const TimeSyncRequestT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct TimeSyncRequestBuilder {
  typedef TimeSyncRequest Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  explicit TimeSyncRequestBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  TimeSyncRequestBuilder &operator=(const TimeSyncRequestBuilder &);
  flatbuffers::Offset<TimeSyncRequest> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<TimeSyncRequest>(end);
    return o;
  }
};

inline flatbuffers::Offset<TimeSyncRequest> CreateTimeSyncRequest(
    flatbuffers::FlatBufferBuilder &_fbb) {
  TimeSyncRequestBuilder builder_(_fbb);
  return builder_.Finish();
}

flatbuffers::Offset<TimeSyncRequest> CreateTimeSyncRequest(flatbuffers::FlatBufferBuilder &_fbb, const TimeSyncRequestT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct LowPowerMicAccessRequestT : public flatbuffers::NativeTable {
  typedef LowPowerMicAccessRequest TableType;
  LowPowerMicAccessRequestT() {
  }
};

/// Request from CHRE to enable direct access to data from the low-power
/// microphone. On some systems, coordination via the AP (e.g. with
/// SoundTrigger HAL) is needed to ensure this capability is powered up when
/// CHRE needs it. The host does not send a response.
struct LowPowerMicAccessRequest FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef LowPowerMicAccessRequestT NativeTableType;
  typedef LowPowerMicAccessRequestBuilder Builder;
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           verifier.EndTable();
  }
  LowPowerMicAccessRequestT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(LowPowerMicAccessRequestT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<LowPowerMicAccessRequest> Pack(flatbuffers::FlatBufferBuilder &_fbb, const LowPowerMicAccessRequestT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct LowPowerMicAccessRequestBuilder {
  typedef LowPowerMicAccessRequest Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  explicit LowPowerMicAccessRequestBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  LowPowerMicAccessRequestBuilder &operator=(const LowPowerMicAccessRequestBuilder &);
  flatbuffers::Offset<LowPowerMicAccessRequest> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<LowPowerMicAccessRequest>(end);
    return o;
  }
};

inline flatbuffers::Offset<LowPowerMicAccessRequest> CreateLowPowerMicAccessRequest(
    flatbuffers::FlatBufferBuilder &_fbb) {
  LowPowerMicAccessRequestBuilder builder_(_fbb);
  return builder_.Finish();
}

flatbuffers::Offset<LowPowerMicAccessRequest> CreateLowPowerMicAccessRequest(flatbuffers::FlatBufferBuilder &_fbb, const LowPowerMicAccessRequestT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct LowPowerMicAccessReleaseT : public flatbuffers::NativeTable {
  typedef LowPowerMicAccessRelease TableType;
  LowPowerMicAccessReleaseT() {
  }
};

/// Notification from CHRE that it no longer needs direct access to low-power
/// microphone data.
struct LowPowerMicAccessRelease FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef LowPowerMicAccessReleaseT NativeTableType;
  typedef LowPowerMicAccessReleaseBuilder Builder;
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           verifier.EndTable();
  }
  LowPowerMicAccessReleaseT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(LowPowerMicAccessReleaseT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<LowPowerMicAccessRelease> Pack(flatbuffers::FlatBufferBuilder &_fbb, const LowPowerMicAccessReleaseT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct LowPowerMicAccessReleaseBuilder {
  typedef LowPowerMicAccessRelease Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  explicit LowPowerMicAccessReleaseBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  LowPowerMicAccessReleaseBuilder &operator=(const LowPowerMicAccessReleaseBuilder &);
  flatbuffers::Offset<LowPowerMicAccessRelease> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<LowPowerMicAccessRelease>(end);
    return o;
  }
};

inline flatbuffers::Offset<LowPowerMicAccessRelease> CreateLowPowerMicAccessRelease(
    flatbuffers::FlatBufferBuilder &_fbb) {
  LowPowerMicAccessReleaseBuilder builder_(_fbb);
  return builder_.Finish();
}

flatbuffers::Offset<LowPowerMicAccessRelease> CreateLowPowerMicAccessRelease(flatbuffers::FlatBufferBuilder &_fbb, const LowPowerMicAccessReleaseT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct SettingChangeMessageT : public flatbuffers::NativeTable {
  typedef SettingChangeMessage TableType;
  chre::fbs::Setting setting;
  chre::fbs::SettingState state;
  SettingChangeMessageT()
      : setting(chre::fbs::Setting::LOCATION),
        state(chre::fbs::SettingState::DISABLED) {
  }
};

/// Notification from the host that a system setting has changed
struct SettingChangeMessage FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef SettingChangeMessageT NativeTableType;
  typedef SettingChangeMessageBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_SETTING = 4,
    VT_STATE = 6
  };
  /// The setting that has changed
  chre::fbs::Setting setting() const {
    return static_cast<chre::fbs::Setting>(GetField<int8_t>(VT_SETTING, 0));
  }
  bool mutate_setting(chre::fbs::Setting _setting) {
    return SetField<int8_t>(VT_SETTING, static_cast<int8_t>(_setting), 0);
  }
  /// The new setting value
  chre::fbs::SettingState state() const {
    return static_cast<chre::fbs::SettingState>(GetField<int8_t>(VT_STATE, 0));
  }
  bool mutate_state(chre::fbs::SettingState _state) {
    return SetField<int8_t>(VT_STATE, static_cast<int8_t>(_state), 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int8_t>(verifier, VT_SETTING) &&
           VerifyField<int8_t>(verifier, VT_STATE) &&
           verifier.EndTable();
  }
  SettingChangeMessageT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(SettingChangeMessageT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<SettingChangeMessage> Pack(flatbuffers::FlatBufferBuilder &_fbb, const SettingChangeMessageT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct SettingChangeMessageBuilder {
  typedef SettingChangeMessage Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_setting(chre::fbs::Setting setting) {
    fbb_.AddElement<int8_t>(SettingChangeMessage::VT_SETTING, static_cast<int8_t>(setting), 0);
  }
  void add_state(chre::fbs::SettingState state) {
    fbb_.AddElement<int8_t>(SettingChangeMessage::VT_STATE, static_cast<int8_t>(state), 0);
  }
  explicit SettingChangeMessageBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  SettingChangeMessageBuilder &operator=(const SettingChangeMessageBuilder &);
  flatbuffers::Offset<SettingChangeMessage> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<SettingChangeMessage>(end);
    return o;
  }
};

inline flatbuffers::Offset<SettingChangeMessage> CreateSettingChangeMessage(
    flatbuffers::FlatBufferBuilder &_fbb,
    chre::fbs::Setting setting = chre::fbs::Setting::LOCATION,
    chre::fbs::SettingState state = chre::fbs::SettingState::DISABLED) {
  SettingChangeMessageBuilder builder_(_fbb);
  builder_.add_state(state);
  builder_.add_setting(setting);
  return builder_.Finish();
}

flatbuffers::Offset<SettingChangeMessage> CreateSettingChangeMessage(flatbuffers::FlatBufferBuilder &_fbb, const SettingChangeMessageT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct LogMessageV2T : public flatbuffers::NativeTable {
  typedef LogMessageV2 TableType;
  std::vector<int8_t> buffer;
  uint32_t num_logs_dropped;
  LogMessageV2T()
      : num_logs_dropped(0) {
  }
};

/// Represents V2 log messages from CHRE.
struct LogMessageV2 FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef LogMessageV2T NativeTableType;
  typedef LogMessageV2Builder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_BUFFER = 4,
    VT_NUM_LOGS_DROPPED = 6
  };
  /// A buffer containing formatted log data. A flat array is used here to avoid
  /// overhead in serializing and deserializing. The format is as follows:
  ///
  /// uint8_t                 - Log metadata, encoded as follows:
  ///                           [EI(Upper nibble) | Level(Lower nibble)]
  ///                            * Log Type
  ///                              (0 = No encoding, 1 = Tokenized log,
  ///                               2 = BT snoop log, 3 = Nanoapp Tokenized log)
  ///                            * LogBuffer log level (1 = error, 2 = warn,
  ///                                                   3 = info,  4 = debug,
  ///                                                   5 = verbose)
  /// uint32_t, little-endian - timestamp in milliseconds
  /// char[]                  - Log data buffer
  ///
  /// The log data buffer format is as follows:
  /// * Unencoded (string) logs: The log buffer can be interpreted as a NULL
  ///   terminated string (eg: pass to string manipulation functions, get its
  ///   size via strlen(), etc.).
  ///
  /// * Tokenized logs: The first byte of the log buffer indicates the size of
  ///   the actual encoded data to follow. For example, if a tokenized log of
  ///   size 24 bytes were to be represented, a buffer of size 25 bytes would
  ///   be needed to encode this as: [Size(1B) | Data(24B)]. A decoder would
  ///   then have to decode this starting from a 1 byte offset from the
  ///   received buffer.
  ///
  /// * Bt Snoop logs: The first byte of the log buffer indicates the direction
  ///   of the bt snoop log, depending on whether it is incoming for the BT
  ///   controller or outgoing to the arbiter. The second byte indicates the size
  ///   of the actual BT payload followed. For example, if a bt snoop log of
  ///   size 24 bytes were to be represented, a buffer of size 26 bytes would
  ///   be needed to encode this as: [Direction(1B) | Size(1B) | Data(24B)].
  ///
  /// * Tokenized nanoapp logs: This log type is specifically for nanoapps with
  ///   tokenized logs enabled. The first two bytes is the instance ID of the
  ///   nanoapp which sends this tokenized log message. This instance ID will be
  ///   used to map to the corresponding detokenizer in the log message parser.
  ///   The rest is similar to tokenized logs with one byte of the size followed
  ///   by the payload. For example, if a nanoapp tokenized log of size 24 bytes
  ///   were to be sent, a buffer of size 27 bytes would be to encoded as:
  ///   [InstanceId (2B) | Size(1B) | Data(24B)].
  ///
  /// This pattern repeats until the end of the buffer for multiple log
  /// messages. The last byte will always be a null-terminator. There are no
  /// padding bytes between these fields. Treat this like a packed struct and be
  /// cautious with unaligned access when reading/writing this buffer.
  /// Note that the log message might not be null-terminated if an encoding is
  /// used.
  const flatbuffers::Vector<int8_t> *buffer() const {
    return GetPointer<const flatbuffers::Vector<int8_t> *>(VT_BUFFER);
  }
  flatbuffers::Vector<int8_t> *mutable_buffer() {
    return GetPointer<flatbuffers::Vector<int8_t> *>(VT_BUFFER);
  }
  /// The number of logs dropped since CHRE started
  uint32_t num_logs_dropped() const {
    return GetField<uint32_t>(VT_NUM_LOGS_DROPPED, 0);
  }
  bool mutate_num_logs_dropped(uint32_t _num_logs_dropped) {
    return SetField<uint32_t>(VT_NUM_LOGS_DROPPED, _num_logs_dropped, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_BUFFER) &&
           verifier.VerifyVector(buffer()) &&
           VerifyField<uint32_t>(verifier, VT_NUM_LOGS_DROPPED) &&
           verifier.EndTable();
  }
  LogMessageV2T *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(LogMessageV2T *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<LogMessageV2> Pack(flatbuffers::FlatBufferBuilder &_fbb, const LogMessageV2T* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct LogMessageV2Builder {
  typedef LogMessageV2 Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_buffer(flatbuffers::Offset<flatbuffers::Vector<int8_t>> buffer) {
    fbb_.AddOffset(LogMessageV2::VT_BUFFER, buffer);
  }
  void add_num_logs_dropped(uint32_t num_logs_dropped) {
    fbb_.AddElement<uint32_t>(LogMessageV2::VT_NUM_LOGS_DROPPED, num_logs_dropped, 0);
  }
  explicit LogMessageV2Builder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  LogMessageV2Builder &operator=(const LogMessageV2Builder &);
  flatbuffers::Offset<LogMessageV2> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<LogMessageV2>(end);
    return o;
  }
};

inline flatbuffers::Offset<LogMessageV2> CreateLogMessageV2(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::Vector<int8_t>> buffer = 0,
    uint32_t num_logs_dropped = 0) {
  LogMessageV2Builder builder_(_fbb);
  builder_.add_num_logs_dropped(num_logs_dropped);
  builder_.add_buffer(buffer);
  return builder_.Finish();
}

inline flatbuffers::Offset<LogMessageV2> CreateLogMessageV2Direct(
    flatbuffers::FlatBufferBuilder &_fbb,
    const std::vector<int8_t> *buffer = nullptr,
    uint32_t num_logs_dropped = 0) {
  auto buffer__ = buffer ? _fbb.CreateVector<int8_t>(*buffer) : 0;
  return chre::fbs::CreateLogMessageV2(
      _fbb,
      buffer__,
      num_logs_dropped);
}

flatbuffers::Offset<LogMessageV2> CreateLogMessageV2(flatbuffers::FlatBufferBuilder &_fbb, const LogMessageV2T *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct SelfTestRequestT : public flatbuffers::NativeTable {
  typedef SelfTestRequest TableType;
  SelfTestRequestT() {
  }
};

struct SelfTestRequest FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef SelfTestRequestT NativeTableType;
  typedef SelfTestRequestBuilder Builder;
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           verifier.EndTable();
  }
  SelfTestRequestT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(SelfTestRequestT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<SelfTestRequest> Pack(flatbuffers::FlatBufferBuilder &_fbb, const SelfTestRequestT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct SelfTestRequestBuilder {
  typedef SelfTestRequest Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  explicit SelfTestRequestBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  SelfTestRequestBuilder &operator=(const SelfTestRequestBuilder &);
  flatbuffers::Offset<SelfTestRequest> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<SelfTestRequest>(end);
    return o;
  }
};

inline flatbuffers::Offset<SelfTestRequest> CreateSelfTestRequest(
    flatbuffers::FlatBufferBuilder &_fbb) {
  SelfTestRequestBuilder builder_(_fbb);
  return builder_.Finish();
}

flatbuffers::Offset<SelfTestRequest> CreateSelfTestRequest(flatbuffers::FlatBufferBuilder &_fbb, const SelfTestRequestT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct SelfTestResponseT : public flatbuffers::NativeTable {
  typedef SelfTestResponse TableType;
  bool success;
  SelfTestResponseT()
      : success(false) {
  }
};

struct SelfTestResponse FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef SelfTestResponseT NativeTableType;
  typedef SelfTestResponseBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_SUCCESS = 4
  };
  bool success() const {
    return GetField<uint8_t>(VT_SUCCESS, 0) != 0;
  }
  bool mutate_success(bool _success) {
    return SetField<uint8_t>(VT_SUCCESS, static_cast<uint8_t>(_success), 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint8_t>(verifier, VT_SUCCESS) &&
           verifier.EndTable();
  }
  SelfTestResponseT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(SelfTestResponseT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<SelfTestResponse> Pack(flatbuffers::FlatBufferBuilder &_fbb, const SelfTestResponseT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct SelfTestResponseBuilder {
  typedef SelfTestResponse Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_success(bool success) {
    fbb_.AddElement<uint8_t>(SelfTestResponse::VT_SUCCESS, static_cast<uint8_t>(success), 0);
  }
  explicit SelfTestResponseBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  SelfTestResponseBuilder &operator=(const SelfTestResponseBuilder &);
  flatbuffers::Offset<SelfTestResponse> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<SelfTestResponse>(end);
    return o;
  }
};

inline flatbuffers::Offset<SelfTestResponse> CreateSelfTestResponse(
    flatbuffers::FlatBufferBuilder &_fbb,
    bool success = false) {
  SelfTestResponseBuilder builder_(_fbb);
  builder_.add_success(success);
  return builder_.Finish();
}

flatbuffers::Offset<SelfTestResponse> CreateSelfTestResponse(flatbuffers::FlatBufferBuilder &_fbb, const SelfTestResponseT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct HostEndpointConnectedT : public flatbuffers::NativeTable {
  typedef HostEndpointConnected TableType;
  uint16_t host_endpoint;
  uint8_t type;
  std::vector<int8_t> package_name;
  std::vector<int8_t> attribution_tag;
  HostEndpointConnectedT()
      : host_endpoint(0),
        type(0) {
  }
};

struct HostEndpointConnected FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef HostEndpointConnectedT NativeTableType;
  typedef HostEndpointConnectedBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_HOST_ENDPOINT = 4,
    VT_TYPE = 6,
    VT_PACKAGE_NAME = 8,
    VT_ATTRIBUTION_TAG = 10
  };
  /// The host-side endpoint that has connected to the framework.
  uint16_t host_endpoint() const {
    return GetField<uint16_t>(VT_HOST_ENDPOINT, 0);
  }
  bool mutate_host_endpoint(uint16_t _host_endpoint) {
    return SetField<uint16_t>(VT_HOST_ENDPOINT, _host_endpoint, 0);
  }
  /// The type of host endpoint, which should be any of the CHRE_HOST_ENDPOINT_TYPE_*
  /// values defined in the chre_api/chre/event.h.
  uint8_t type() const {
    return GetField<uint8_t>(VT_TYPE, 0);
  }
  bool mutate_type(uint8_t _type) {
    return SetField<uint8_t>(VT_TYPE, _type, 0);
  }
  /// The (optional) package name associated with the host endpoint.
  const flatbuffers::Vector<int8_t> *package_name() const {
    return GetPointer<const flatbuffers::Vector<int8_t> *>(VT_PACKAGE_NAME);
  }
  flatbuffers::Vector<int8_t> *mutable_package_name() {
    return GetPointer<flatbuffers::Vector<int8_t> *>(VT_PACKAGE_NAME);
  }
  /// The (optional) attribution tag associated with this host.
  const flatbuffers::Vector<int8_t> *attribution_tag() const {
    return GetPointer<const flatbuffers::Vector<int8_t> *>(VT_ATTRIBUTION_TAG);
  }
  flatbuffers::Vector<int8_t> *mutable_attribution_tag() {
    return GetPointer<flatbuffers::Vector<int8_t> *>(VT_ATTRIBUTION_TAG);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint16_t>(verifier, VT_HOST_ENDPOINT) &&
           VerifyField<uint8_t>(verifier, VT_TYPE) &&
           VerifyOffset(verifier, VT_PACKAGE_NAME) &&
           verifier.VerifyVector(package_name()) &&
           VerifyOffset(verifier, VT_ATTRIBUTION_TAG) &&
           verifier.VerifyVector(attribution_tag()) &&
           verifier.EndTable();
  }
  HostEndpointConnectedT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(HostEndpointConnectedT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<HostEndpointConnected> Pack(flatbuffers::FlatBufferBuilder &_fbb, const HostEndpointConnectedT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct HostEndpointConnectedBuilder {
  typedef HostEndpointConnected Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_host_endpoint(uint16_t host_endpoint) {
    fbb_.AddElement<uint16_t>(HostEndpointConnected::VT_HOST_ENDPOINT, host_endpoint, 0);
  }
  void add_type(uint8_t type) {
    fbb_.AddElement<uint8_t>(HostEndpointConnected::VT_TYPE, type, 0);
  }
  void add_package_name(flatbuffers::Offset<flatbuffers::Vector<int8_t>> package_name) {
    fbb_.AddOffset(HostEndpointConnected::VT_PACKAGE_NAME, package_name);
  }
  void add_attribution_tag(flatbuffers::Offset<flatbuffers::Vector<int8_t>> attribution_tag) {
    fbb_.AddOffset(HostEndpointConnected::VT_ATTRIBUTION_TAG, attribution_tag);
  }
  explicit HostEndpointConnectedBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  HostEndpointConnectedBuilder &operator=(const HostEndpointConnectedBuilder &);
  flatbuffers::Offset<HostEndpointConnected> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<HostEndpointConnected>(end);
    return o;
  }
};

inline flatbuffers::Offset<HostEndpointConnected> CreateHostEndpointConnected(
    flatbuffers::FlatBufferBuilder &_fbb,
    uint16_t host_endpoint = 0,
    uint8_t type = 0,
    flatbuffers::Offset<flatbuffers::Vector<int8_t>> package_name = 0,
    flatbuffers::Offset<flatbuffers::Vector<int8_t>> attribution_tag = 0) {
  HostEndpointConnectedBuilder builder_(_fbb);
  builder_.add_attribution_tag(attribution_tag);
  builder_.add_package_name(package_name);
  builder_.add_host_endpoint(host_endpoint);
  builder_.add_type(type);
  return builder_.Finish();
}

inline flatbuffers::Offset<HostEndpointConnected> CreateHostEndpointConnectedDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    uint16_t host_endpoint = 0,
    uint8_t type = 0,
    const std::vector<int8_t> *package_name = nullptr,
    const std::vector<int8_t> *attribution_tag = nullptr) {
  auto package_name__ = package_name ? _fbb.CreateVector<int8_t>(*package_name) : 0;
  auto attribution_tag__ = attribution_tag ? _fbb.CreateVector<int8_t>(*attribution_tag) : 0;
  return chre::fbs::CreateHostEndpointConnected(
      _fbb,
      host_endpoint,
      type,
      package_name__,
      attribution_tag__);
}

flatbuffers::Offset<HostEndpointConnected> CreateHostEndpointConnected(flatbuffers::FlatBufferBuilder &_fbb, const HostEndpointConnectedT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct HostEndpointDisconnectedT : public flatbuffers::NativeTable {
  typedef HostEndpointDisconnected TableType;
  uint16_t host_endpoint;
  HostEndpointDisconnectedT()
      : host_endpoint(0) {
  }
};

struct HostEndpointDisconnected FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef HostEndpointDisconnectedT NativeTableType;
  typedef HostEndpointDisconnectedBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_HOST_ENDPOINT = 4
  };
  /// The host-side endpoint that has disconnected from the framework.
  uint16_t host_endpoint() const {
    return GetField<uint16_t>(VT_HOST_ENDPOINT, 0);
  }
  bool mutate_host_endpoint(uint16_t _host_endpoint) {
    return SetField<uint16_t>(VT_HOST_ENDPOINT, _host_endpoint, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint16_t>(verifier, VT_HOST_ENDPOINT) &&
           verifier.EndTable();
  }
  HostEndpointDisconnectedT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(HostEndpointDisconnectedT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<HostEndpointDisconnected> Pack(flatbuffers::FlatBufferBuilder &_fbb, const HostEndpointDisconnectedT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct HostEndpointDisconnectedBuilder {
  typedef HostEndpointDisconnected Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_host_endpoint(uint16_t host_endpoint) {
    fbb_.AddElement<uint16_t>(HostEndpointDisconnected::VT_HOST_ENDPOINT, host_endpoint, 0);
  }
  explicit HostEndpointDisconnectedBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  HostEndpointDisconnectedBuilder &operator=(const HostEndpointDisconnectedBuilder &);
  flatbuffers::Offset<HostEndpointDisconnected> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<HostEndpointDisconnected>(end);
    return o;
  }
};

inline flatbuffers::Offset<HostEndpointDisconnected> CreateHostEndpointDisconnected(
    flatbuffers::FlatBufferBuilder &_fbb,
    uint16_t host_endpoint = 0) {
  HostEndpointDisconnectedBuilder builder_(_fbb);
  builder_.add_host_endpoint(host_endpoint);
  return builder_.Finish();
}

flatbuffers::Offset<HostEndpointDisconnected> CreateHostEndpointDisconnected(flatbuffers::FlatBufferBuilder &_fbb, const HostEndpointDisconnectedT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct MetricLogT : public flatbuffers::NativeTable {
  typedef MetricLog TableType;
  uint32_t id;
  std::vector<int8_t> encoded_metric;
  MetricLogT()
      : id(0) {
  }
};

struct MetricLog FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef MetricLogT NativeTableType;
  typedef MetricLogBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_ID = 4,
    VT_ENCODED_METRIC = 6
  };
  uint32_t id() const {
    return GetField<uint32_t>(VT_ID, 0);
  }
  bool mutate_id(uint32_t _id) {
    return SetField<uint32_t>(VT_ID, _id, 0);
  }
  const flatbuffers::Vector<int8_t> *encoded_metric() const {
    return GetPointer<const flatbuffers::Vector<int8_t> *>(VT_ENCODED_METRIC);
  }
  flatbuffers::Vector<int8_t> *mutable_encoded_metric() {
    return GetPointer<flatbuffers::Vector<int8_t> *>(VT_ENCODED_METRIC);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint32_t>(verifier, VT_ID) &&
           VerifyOffset(verifier, VT_ENCODED_METRIC) &&
           verifier.VerifyVector(encoded_metric()) &&
           verifier.EndTable();
  }
  MetricLogT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(MetricLogT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<MetricLog> Pack(flatbuffers::FlatBufferBuilder &_fbb, const MetricLogT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct MetricLogBuilder {
  typedef MetricLog Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_id(uint32_t id) {
    fbb_.AddElement<uint32_t>(MetricLog::VT_ID, id, 0);
  }
  void add_encoded_metric(flatbuffers::Offset<flatbuffers::Vector<int8_t>> encoded_metric) {
    fbb_.AddOffset(MetricLog::VT_ENCODED_METRIC, encoded_metric);
  }
  explicit MetricLogBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  MetricLogBuilder &operator=(const MetricLogBuilder &);
  flatbuffers::Offset<MetricLog> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<MetricLog>(end);
    return o;
  }
};

inline flatbuffers::Offset<MetricLog> CreateMetricLog(
    flatbuffers::FlatBufferBuilder &_fbb,
    uint32_t id = 0,
    flatbuffers::Offset<flatbuffers::Vector<int8_t>> encoded_metric = 0) {
  MetricLogBuilder builder_(_fbb);
  builder_.add_encoded_metric(encoded_metric);
  builder_.add_id(id);
  return builder_.Finish();
}

inline flatbuffers::Offset<MetricLog> CreateMetricLogDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    uint32_t id = 0,
    const std::vector<int8_t> *encoded_metric = nullptr) {
  auto encoded_metric__ = encoded_metric ? _fbb.CreateVector<int8_t>(*encoded_metric) : 0;
  return chre::fbs::CreateMetricLog(
      _fbb,
      id,
      encoded_metric__);
}

flatbuffers::Offset<MetricLog> CreateMetricLog(flatbuffers::FlatBufferBuilder &_fbb, const MetricLogT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct BatchedMetricLogT : public flatbuffers::NativeTable {
  typedef BatchedMetricLog TableType;
  std::vector<std::unique_ptr<chre::fbs::MetricLogT>> metrics;
  BatchedMetricLogT() {
  }
};

struct BatchedMetricLog FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef BatchedMetricLogT NativeTableType;
  typedef BatchedMetricLogBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_METRICS = 4
  };
  const flatbuffers::Vector<flatbuffers::Offset<chre::fbs::MetricLog>> *metrics() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<chre::fbs::MetricLog>> *>(VT_METRICS);
  }
  flatbuffers::Vector<flatbuffers::Offset<chre::fbs::MetricLog>> *mutable_metrics() {
    return GetPointer<flatbuffers::Vector<flatbuffers::Offset<chre::fbs::MetricLog>> *>(VT_METRICS);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_METRICS) &&
           verifier.VerifyVector(metrics()) &&
           verifier.VerifyVectorOfTables(metrics()) &&
           verifier.EndTable();
  }
  BatchedMetricLogT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(BatchedMetricLogT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<BatchedMetricLog> Pack(flatbuffers::FlatBufferBuilder &_fbb, const BatchedMetricLogT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct BatchedMetricLogBuilder {
  typedef BatchedMetricLog Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_metrics(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<chre::fbs::MetricLog>>> metrics) {
    fbb_.AddOffset(BatchedMetricLog::VT_METRICS, metrics);
  }
  explicit BatchedMetricLogBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  BatchedMetricLogBuilder &operator=(const BatchedMetricLogBuilder &);
  flatbuffers::Offset<BatchedMetricLog> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<BatchedMetricLog>(end);
    return o;
  }
};

inline flatbuffers::Offset<BatchedMetricLog> CreateBatchedMetricLog(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<chre::fbs::MetricLog>>> metrics = 0) {
  BatchedMetricLogBuilder builder_(_fbb);
  builder_.add_metrics(metrics);
  return builder_.Finish();
}

inline flatbuffers::Offset<BatchedMetricLog> CreateBatchedMetricLogDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const std::vector<flatbuffers::Offset<chre::fbs::MetricLog>> *metrics = nullptr) {
  auto metrics__ = metrics ? _fbb.CreateVector<flatbuffers::Offset<chre::fbs::MetricLog>>(*metrics) : 0;
  return chre::fbs::CreateBatchedMetricLog(
      _fbb,
      metrics__);
}

flatbuffers::Offset<BatchedMetricLog> CreateBatchedMetricLog(flatbuffers::FlatBufferBuilder &_fbb, const BatchedMetricLogT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct NanConfigurationRequestT : public flatbuffers::NativeTable {
  typedef NanConfigurationRequest TableType;
  bool enable;
  NanConfigurationRequestT()
      : enable(false) {
  }
};

struct NanConfigurationRequest FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef NanConfigurationRequestT NativeTableType;
  typedef NanConfigurationRequestBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_ENABLE = 4
  };
  bool enable() const {
    return GetField<uint8_t>(VT_ENABLE, 0) != 0;
  }
  bool mutate_enable(bool _enable) {
    return SetField<uint8_t>(VT_ENABLE, static_cast<uint8_t>(_enable), 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint8_t>(verifier, VT_ENABLE) &&
           verifier.EndTable();
  }
  NanConfigurationRequestT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(NanConfigurationRequestT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<NanConfigurationRequest> Pack(flatbuffers::FlatBufferBuilder &_fbb, const NanConfigurationRequestT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct NanConfigurationRequestBuilder {
  typedef NanConfigurationRequest Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_enable(bool enable) {
    fbb_.AddElement<uint8_t>(NanConfigurationRequest::VT_ENABLE, static_cast<uint8_t>(enable), 0);
  }
  explicit NanConfigurationRequestBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  NanConfigurationRequestBuilder &operator=(const NanConfigurationRequestBuilder &);
  flatbuffers::Offset<NanConfigurationRequest> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<NanConfigurationRequest>(end);
    return o;
  }
};

inline flatbuffers::Offset<NanConfigurationRequest> CreateNanConfigurationRequest(
    flatbuffers::FlatBufferBuilder &_fbb,
    bool enable = false) {
  NanConfigurationRequestBuilder builder_(_fbb);
  builder_.add_enable(enable);
  return builder_.Finish();
}

flatbuffers::Offset<NanConfigurationRequest> CreateNanConfigurationRequest(flatbuffers::FlatBufferBuilder &_fbb, const NanConfigurationRequestT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct NanConfigurationUpdateT : public flatbuffers::NativeTable {
  typedef NanConfigurationUpdate TableType;
  bool enabled;
  NanConfigurationUpdateT()
      : enabled(false) {
  }
};

struct NanConfigurationUpdate FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef NanConfigurationUpdateT NativeTableType;
  typedef NanConfigurationUpdateBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_ENABLED = 4
  };
  bool enabled() const {
    return GetField<uint8_t>(VT_ENABLED, 0) != 0;
  }
  bool mutate_enabled(bool _enabled) {
    return SetField<uint8_t>(VT_ENABLED, static_cast<uint8_t>(_enabled), 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint8_t>(verifier, VT_ENABLED) &&
           verifier.EndTable();
  }
  NanConfigurationUpdateT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(NanConfigurationUpdateT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<NanConfigurationUpdate> Pack(flatbuffers::FlatBufferBuilder &_fbb, const NanConfigurationUpdateT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct NanConfigurationUpdateBuilder {
  typedef NanConfigurationUpdate Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_enabled(bool enabled) {
    fbb_.AddElement<uint8_t>(NanConfigurationUpdate::VT_ENABLED, static_cast<uint8_t>(enabled), 0);
  }
  explicit NanConfigurationUpdateBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  NanConfigurationUpdateBuilder &operator=(const NanConfigurationUpdateBuilder &);
  flatbuffers::Offset<NanConfigurationUpdate> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<NanConfigurationUpdate>(end);
    return o;
  }
};

inline flatbuffers::Offset<NanConfigurationUpdate> CreateNanConfigurationUpdate(
    flatbuffers::FlatBufferBuilder &_fbb,
    bool enabled = false) {
  NanConfigurationUpdateBuilder builder_(_fbb);
  builder_.add_enabled(enabled);
  return builder_.Finish();
}

flatbuffers::Offset<NanConfigurationUpdate> CreateNanConfigurationUpdate(flatbuffers::FlatBufferBuilder &_fbb, const NanConfigurationUpdateT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct DebugConfigurationT : public flatbuffers::NativeTable {
  typedef DebugConfiguration TableType;
  bool health_monitor_failure_crash;
  DebugConfigurationT()
      : health_monitor_failure_crash(false) {
  }
};

struct DebugConfiguration FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef DebugConfigurationT NativeTableType;
  typedef DebugConfigurationBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_HEALTH_MONITOR_FAILURE_CRASH = 4
  };
  bool health_monitor_failure_crash() const {
    return GetField<uint8_t>(VT_HEALTH_MONITOR_FAILURE_CRASH, 0) != 0;
  }
  bool mutate_health_monitor_failure_crash(bool _health_monitor_failure_crash) {
    return SetField<uint8_t>(VT_HEALTH_MONITOR_FAILURE_CRASH, static_cast<uint8_t>(_health_monitor_failure_crash), 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint8_t>(verifier, VT_HEALTH_MONITOR_FAILURE_CRASH) &&
           verifier.EndTable();
  }
  DebugConfigurationT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(DebugConfigurationT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<DebugConfiguration> Pack(flatbuffers::FlatBufferBuilder &_fbb, const DebugConfigurationT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct DebugConfigurationBuilder {
  typedef DebugConfiguration Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_health_monitor_failure_crash(bool health_monitor_failure_crash) {
    fbb_.AddElement<uint8_t>(DebugConfiguration::VT_HEALTH_MONITOR_FAILURE_CRASH, static_cast<uint8_t>(health_monitor_failure_crash), 0);
  }
  explicit DebugConfigurationBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  DebugConfigurationBuilder &operator=(const DebugConfigurationBuilder &);
  flatbuffers::Offset<DebugConfiguration> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<DebugConfiguration>(end);
    return o;
  }
};

inline flatbuffers::Offset<DebugConfiguration> CreateDebugConfiguration(
    flatbuffers::FlatBufferBuilder &_fbb,
    bool health_monitor_failure_crash = false) {
  DebugConfigurationBuilder builder_(_fbb);
  builder_.add_health_monitor_failure_crash(health_monitor_failure_crash);
  return builder_.Finish();
}

flatbuffers::Offset<DebugConfiguration> CreateDebugConfiguration(flatbuffers::FlatBufferBuilder &_fbb, const DebugConfigurationT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct PulseRequestT : public flatbuffers::NativeTable {
  typedef PulseRequest TableType;
  PulseRequestT() {
  }
};

struct PulseRequest FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef PulseRequestT NativeTableType;
  typedef PulseRequestBuilder Builder;
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           verifier.EndTable();
  }
  PulseRequestT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(PulseRequestT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<PulseRequest> Pack(flatbuffers::FlatBufferBuilder &_fbb, const PulseRequestT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct PulseRequestBuilder {
  typedef PulseRequest Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  explicit PulseRequestBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  PulseRequestBuilder &operator=(const PulseRequestBuilder &);
  flatbuffers::Offset<PulseRequest> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<PulseRequest>(end);
    return o;
  }
};

inline flatbuffers::Offset<PulseRequest> CreatePulseRequest(
    flatbuffers::FlatBufferBuilder &_fbb) {
  PulseRequestBuilder builder_(_fbb);
  return builder_.Finish();
}

flatbuffers::Offset<PulseRequest> CreatePulseRequest(flatbuffers::FlatBufferBuilder &_fbb, const PulseRequestT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct PulseResponseT : public flatbuffers::NativeTable {
  typedef PulseResponse TableType;
  PulseResponseT() {
  }
};

struct PulseResponse FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef PulseResponseT NativeTableType;
  typedef PulseResponseBuilder Builder;
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           verifier.EndTable();
  }
  PulseResponseT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(PulseResponseT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<PulseResponse> Pack(flatbuffers::FlatBufferBuilder &_fbb, const PulseResponseT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct PulseResponseBuilder {
  typedef PulseResponse Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  explicit PulseResponseBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  PulseResponseBuilder &operator=(const PulseResponseBuilder &);
  flatbuffers::Offset<PulseResponse> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<PulseResponse>(end);
    return o;
  }
};

inline flatbuffers::Offset<PulseResponse> CreatePulseResponse(
    flatbuffers::FlatBufferBuilder &_fbb) {
  PulseResponseBuilder builder_(_fbb);
  return builder_.Finish();
}

flatbuffers::Offset<PulseResponse> CreatePulseResponse(flatbuffers::FlatBufferBuilder &_fbb, const PulseResponseT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct LeCocChannelInfoT : public flatbuffers::NativeTable {
  typedef LeCocChannelInfo TableType;
  int32_t localCid;
  int32_t remoteCid;
  int32_t psm;
  int32_t localMtu;
  int32_t remoteMtu;
  int32_t localMps;
  int32_t remoteMps;
  int32_t initialRxCredits;
  int32_t initialTxCredits;
  LeCocChannelInfoT()
      : localCid(0),
        remoteCid(0),
        psm(0),
        localMtu(0),
        remoteMtu(0),
        localMps(0),
        remoteMps(0),
        initialRxCredits(0),
        initialTxCredits(0) {
  }
};

struct LeCocChannelInfo FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef LeCocChannelInfoT NativeTableType;
  typedef LeCocChannelInfoBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_LOCALCID = 4,
    VT_REMOTECID = 6,
    VT_PSM = 8,
    VT_LOCALMTU = 10,
    VT_REMOTEMTU = 12,
    VT_LOCALMPS = 14,
    VT_REMOTEMPS = 16,
    VT_INITIALRXCREDITS = 18,
    VT_INITIALTXCREDITS = 20
  };
  int32_t localCid() const {
    return GetField<int32_t>(VT_LOCALCID, 0);
  }
  bool mutate_localCid(int32_t _localCid) {
    return SetField<int32_t>(VT_LOCALCID, _localCid, 0);
  }
  int32_t remoteCid() const {
    return GetField<int32_t>(VT_REMOTECID, 0);
  }
  bool mutate_remoteCid(int32_t _remoteCid) {
    return SetField<int32_t>(VT_REMOTECID, _remoteCid, 0);
  }
  int32_t psm() const {
    return GetField<int32_t>(VT_PSM, 0);
  }
  bool mutate_psm(int32_t _psm) {
    return SetField<int32_t>(VT_PSM, _psm, 0);
  }
  int32_t localMtu() const {
    return GetField<int32_t>(VT_LOCALMTU, 0);
  }
  bool mutate_localMtu(int32_t _localMtu) {
    return SetField<int32_t>(VT_LOCALMTU, _localMtu, 0);
  }
  int32_t remoteMtu() const {
    return GetField<int32_t>(VT_REMOTEMTU, 0);
  }
  bool mutate_remoteMtu(int32_t _remoteMtu) {
    return SetField<int32_t>(VT_REMOTEMTU, _remoteMtu, 0);
  }
  int32_t localMps() const {
    return GetField<int32_t>(VT_LOCALMPS, 0);
  }
  bool mutate_localMps(int32_t _localMps) {
    return SetField<int32_t>(VT_LOCALMPS, _localMps, 0);
  }
  int32_t remoteMps() const {
    return GetField<int32_t>(VT_REMOTEMPS, 0);
  }
  bool mutate_remoteMps(int32_t _remoteMps) {
    return SetField<int32_t>(VT_REMOTEMPS, _remoteMps, 0);
  }
  int32_t initialRxCredits() const {
    return GetField<int32_t>(VT_INITIALRXCREDITS, 0);
  }
  bool mutate_initialRxCredits(int32_t _initialRxCredits) {
    return SetField<int32_t>(VT_INITIALRXCREDITS, _initialRxCredits, 0);
  }
  int32_t initialTxCredits() const {
    return GetField<int32_t>(VT_INITIALTXCREDITS, 0);
  }
  bool mutate_initialTxCredits(int32_t _initialTxCredits) {
    return SetField<int32_t>(VT_INITIALTXCREDITS, _initialTxCredits, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_LOCALCID) &&
           VerifyField<int32_t>(verifier, VT_REMOTECID) &&
           VerifyField<int32_t>(verifier, VT_PSM) &&
           VerifyField<int32_t>(verifier, VT_LOCALMTU) &&
           VerifyField<int32_t>(verifier, VT_REMOTEMTU) &&
           VerifyField<int32_t>(verifier, VT_LOCALMPS) &&
           VerifyField<int32_t>(verifier, VT_REMOTEMPS) &&
           VerifyField<int32_t>(verifier, VT_INITIALRXCREDITS) &&
           VerifyField<int32_t>(verifier, VT_INITIALTXCREDITS) &&
           verifier.EndTable();
  }
  LeCocChannelInfoT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(LeCocChannelInfoT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<LeCocChannelInfo> Pack(flatbuffers::FlatBufferBuilder &_fbb, const LeCocChannelInfoT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct LeCocChannelInfoBuilder {
  typedef LeCocChannelInfo Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_localCid(int32_t localCid) {
    fbb_.AddElement<int32_t>(LeCocChannelInfo::VT_LOCALCID, localCid, 0);
  }
  void add_remoteCid(int32_t remoteCid) {
    fbb_.AddElement<int32_t>(LeCocChannelInfo::VT_REMOTECID, remoteCid, 0);
  }
  void add_psm(int32_t psm) {
    fbb_.AddElement<int32_t>(LeCocChannelInfo::VT_PSM, psm, 0);
  }
  void add_localMtu(int32_t localMtu) {
    fbb_.AddElement<int32_t>(LeCocChannelInfo::VT_LOCALMTU, localMtu, 0);
  }
  void add_remoteMtu(int32_t remoteMtu) {
    fbb_.AddElement<int32_t>(LeCocChannelInfo::VT_REMOTEMTU, remoteMtu, 0);
  }
  void add_localMps(int32_t localMps) {
    fbb_.AddElement<int32_t>(LeCocChannelInfo::VT_LOCALMPS, localMps, 0);
  }
  void add_remoteMps(int32_t remoteMps) {
    fbb_.AddElement<int32_t>(LeCocChannelInfo::VT_REMOTEMPS, remoteMps, 0);
  }
  void add_initialRxCredits(int32_t initialRxCredits) {
    fbb_.AddElement<int32_t>(LeCocChannelInfo::VT_INITIALRXCREDITS, initialRxCredits, 0);
  }
  void add_initialTxCredits(int32_t initialTxCredits) {
    fbb_.AddElement<int32_t>(LeCocChannelInfo::VT_INITIALTXCREDITS, initialTxCredits, 0);
  }
  explicit LeCocChannelInfoBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  LeCocChannelInfoBuilder &operator=(const LeCocChannelInfoBuilder &);
  flatbuffers::Offset<LeCocChannelInfo> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<LeCocChannelInfo>(end);
    return o;
  }
};

inline flatbuffers::Offset<LeCocChannelInfo> CreateLeCocChannelInfo(
    flatbuffers::FlatBufferBuilder &_fbb,
    int32_t localCid = 0,
    int32_t remoteCid = 0,
    int32_t psm = 0,
    int32_t localMtu = 0,
    int32_t remoteMtu = 0,
    int32_t localMps = 0,
    int32_t remoteMps = 0,
    int32_t initialRxCredits = 0,
    int32_t initialTxCredits = 0) {
  LeCocChannelInfoBuilder builder_(_fbb);
  builder_.add_initialTxCredits(initialTxCredits);
  builder_.add_initialRxCredits(initialRxCredits);
  builder_.add_remoteMps(remoteMps);
  builder_.add_localMps(localMps);
  builder_.add_remoteMtu(remoteMtu);
  builder_.add_localMtu(localMtu);
  builder_.add_psm(psm);
  builder_.add_remoteCid(remoteCid);
  builder_.add_localCid(localCid);
  return builder_.Finish();
}

flatbuffers::Offset<LeCocChannelInfo> CreateLeCocChannelInfo(flatbuffers::FlatBufferBuilder &_fbb, const LeCocChannelInfoT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct BtSocketOpenT : public flatbuffers::NativeTable {
  typedef BtSocketOpen TableType;
  int64_t socketId;
  std::vector<int8_t> name;
  int32_t aclConnectionHandle;
  chre::fbs::ChannelInfoUnion channelInfo;
  int64_t hubId;
  int64_t endpointId;
  BtSocketOpenT()
      : socketId(0),
        aclConnectionHandle(0),
        hubId(0),
        endpointId(0) {
  }
};

struct BtSocketOpen FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef BtSocketOpenT NativeTableType;
  typedef BtSocketOpenBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_SOCKETID = 4,
    VT_NAME = 6,
    VT_ACLCONNECTIONHANDLE = 8,
    VT_CHANNELINFO_TYPE = 10,
    VT_CHANNELINFO = 12,
    VT_HUBID = 14,
    VT_ENDPOINTID = 16
  };
  int64_t socketId() const {
    return GetField<int64_t>(VT_SOCKETID, 0);
  }
  bool mutate_socketId(int64_t _socketId) {
    return SetField<int64_t>(VT_SOCKETID, _socketId, 0);
  }
  const flatbuffers::Vector<int8_t> *name() const {
    return GetPointer<const flatbuffers::Vector<int8_t> *>(VT_NAME);
  }
  flatbuffers::Vector<int8_t> *mutable_name() {
    return GetPointer<flatbuffers::Vector<int8_t> *>(VT_NAME);
  }
  int32_t aclConnectionHandle() const {
    return GetField<int32_t>(VT_ACLCONNECTIONHANDLE, 0);
  }
  bool mutate_aclConnectionHandle(int32_t _aclConnectionHandle) {
    return SetField<int32_t>(VT_ACLCONNECTIONHANDLE, _aclConnectionHandle, 0);
  }
  chre::fbs::ChannelInfo channelInfo_type() const {
    return static_cast<chre::fbs::ChannelInfo>(GetField<uint8_t>(VT_CHANNELINFO_TYPE, 0));
  }
  const void *channelInfo() const {
    return GetPointer<const void *>(VT_CHANNELINFO);
  }
  template<typename T> const T *channelInfo_as() const;
  const chre::fbs::LeCocChannelInfo *channelInfo_as_LeCocChannelInfo() const {
    return channelInfo_type() == chre::fbs::ChannelInfo::LeCocChannelInfo ? static_cast<const chre::fbs::LeCocChannelInfo *>(channelInfo()) : nullptr;
  }
  void *mutable_channelInfo() {
    return GetPointer<void *>(VT_CHANNELINFO);
  }
  int64_t hubId() const {
    return GetField<int64_t>(VT_HUBID, 0);
  }
  bool mutate_hubId(int64_t _hubId) {
    return SetField<int64_t>(VT_HUBID, _hubId, 0);
  }
  int64_t endpointId() const {
    return GetField<int64_t>(VT_ENDPOINTID, 0);
  }
  bool mutate_endpointId(int64_t _endpointId) {
    return SetField<int64_t>(VT_ENDPOINTID, _endpointId, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int64_t>(verifier, VT_SOCKETID) &&
           VerifyOffset(verifier, VT_NAME) &&
           verifier.VerifyVector(name()) &&
           VerifyField<int32_t>(verifier, VT_ACLCONNECTIONHANDLE) &&
           VerifyField<uint8_t>(verifier, VT_CHANNELINFO_TYPE) &&
           VerifyOffset(verifier, VT_CHANNELINFO) &&
           VerifyChannelInfo(verifier, channelInfo(), channelInfo_type()) &&
           VerifyField<int64_t>(verifier, VT_HUBID) &&
           VerifyField<int64_t>(verifier, VT_ENDPOINTID) &&
           verifier.EndTable();
  }
  BtSocketOpenT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(BtSocketOpenT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<BtSocketOpen> Pack(flatbuffers::FlatBufferBuilder &_fbb, const BtSocketOpenT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

template<> inline const chre::fbs::LeCocChannelInfo *BtSocketOpen::channelInfo_as<chre::fbs::LeCocChannelInfo>() const {
  return channelInfo_as_LeCocChannelInfo();
}

struct BtSocketOpenBuilder {
  typedef BtSocketOpen Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_socketId(int64_t socketId) {
    fbb_.AddElement<int64_t>(BtSocketOpen::VT_SOCKETID, socketId, 0);
  }
  void add_name(flatbuffers::Offset<flatbuffers::Vector<int8_t>> name) {
    fbb_.AddOffset(BtSocketOpen::VT_NAME, name);
  }
  void add_aclConnectionHandle(int32_t aclConnectionHandle) {
    fbb_.AddElement<int32_t>(BtSocketOpen::VT_ACLCONNECTIONHANDLE, aclConnectionHandle, 0);
  }
  void add_channelInfo_type(chre::fbs::ChannelInfo channelInfo_type) {
    fbb_.AddElement<uint8_t>(BtSocketOpen::VT_CHANNELINFO_TYPE, static_cast<uint8_t>(channelInfo_type), 0);
  }
  void add_channelInfo(flatbuffers::Offset<void> channelInfo) {
    fbb_.AddOffset(BtSocketOpen::VT_CHANNELINFO, channelInfo);
  }
  void add_hubId(int64_t hubId) {
    fbb_.AddElement<int64_t>(BtSocketOpen::VT_HUBID, hubId, 0);
  }
  void add_endpointId(int64_t endpointId) {
    fbb_.AddElement<int64_t>(BtSocketOpen::VT_ENDPOINTID, endpointId, 0);
  }
  explicit BtSocketOpenBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  BtSocketOpenBuilder &operator=(const BtSocketOpenBuilder &);
  flatbuffers::Offset<BtSocketOpen> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<BtSocketOpen>(end);
    return o;
  }
};

inline flatbuffers::Offset<BtSocketOpen> CreateBtSocketOpen(
    flatbuffers::FlatBufferBuilder &_fbb,
    int64_t socketId = 0,
    flatbuffers::Offset<flatbuffers::Vector<int8_t>> name = 0,
    int32_t aclConnectionHandle = 0,
    chre::fbs::ChannelInfo channelInfo_type = chre::fbs::ChannelInfo::NONE,
    flatbuffers::Offset<void> channelInfo = 0,
    int64_t hubId = 0,
    int64_t endpointId = 0) {
  BtSocketOpenBuilder builder_(_fbb);
  builder_.add_endpointId(endpointId);
  builder_.add_hubId(hubId);
  builder_.add_socketId(socketId);
  builder_.add_channelInfo(channelInfo);
  builder_.add_aclConnectionHandle(aclConnectionHandle);
  builder_.add_name(name);
  builder_.add_channelInfo_type(channelInfo_type);
  return builder_.Finish();
}

inline flatbuffers::Offset<BtSocketOpen> CreateBtSocketOpenDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    int64_t socketId = 0,
    const std::vector<int8_t> *name = nullptr,
    int32_t aclConnectionHandle = 0,
    chre::fbs::ChannelInfo channelInfo_type = chre::fbs::ChannelInfo::NONE,
    flatbuffers::Offset<void> channelInfo = 0,
    int64_t hubId = 0,
    int64_t endpointId = 0) {
  auto name__ = name ? _fbb.CreateVector<int8_t>(*name) : 0;
  return chre::fbs::CreateBtSocketOpen(
      _fbb,
      socketId,
      name__,
      aclConnectionHandle,
      channelInfo_type,
      channelInfo,
      hubId,
      endpointId);
}

flatbuffers::Offset<BtSocketOpen> CreateBtSocketOpen(flatbuffers::FlatBufferBuilder &_fbb, const BtSocketOpenT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct BtSocketOpenResponseT : public flatbuffers::NativeTable {
  typedef BtSocketOpenResponse TableType;
  int64_t socketId;
  chre::fbs::BtSocketOpenStatus status;
  std::vector<int8_t> reason;
  BtSocketOpenResponseT()
      : socketId(0),
        status(chre::fbs::BtSocketOpenStatus::SUCCESS) {
  }
};

struct BtSocketOpenResponse FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef BtSocketOpenResponseT NativeTableType;
  typedef BtSocketOpenResponseBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_SOCKETID = 4,
    VT_STATUS = 6,
    VT_REASON = 8
  };
  int64_t socketId() const {
    return GetField<int64_t>(VT_SOCKETID, 0);
  }
  bool mutate_socketId(int64_t _socketId) {
    return SetField<int64_t>(VT_SOCKETID, _socketId, 0);
  }
  chre::fbs::BtSocketOpenStatus status() const {
    return static_cast<chre::fbs::BtSocketOpenStatus>(GetField<int8_t>(VT_STATUS, 0));
  }
  bool mutate_status(chre::fbs::BtSocketOpenStatus _status) {
    return SetField<int8_t>(VT_STATUS, static_cast<int8_t>(_status), 0);
  }
  const flatbuffers::Vector<int8_t> *reason() const {
    return GetPointer<const flatbuffers::Vector<int8_t> *>(VT_REASON);
  }
  flatbuffers::Vector<int8_t> *mutable_reason() {
    return GetPointer<flatbuffers::Vector<int8_t> *>(VT_REASON);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int64_t>(verifier, VT_SOCKETID) &&
           VerifyField<int8_t>(verifier, VT_STATUS) &&
           VerifyOffset(verifier, VT_REASON) &&
           verifier.VerifyVector(reason()) &&
           verifier.EndTable();
  }
  BtSocketOpenResponseT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(BtSocketOpenResponseT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<BtSocketOpenResponse> Pack(flatbuffers::FlatBufferBuilder &_fbb, const BtSocketOpenResponseT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct BtSocketOpenResponseBuilder {
  typedef BtSocketOpenResponse Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_socketId(int64_t socketId) {
    fbb_.AddElement<int64_t>(BtSocketOpenResponse::VT_SOCKETID, socketId, 0);
  }
  void add_status(chre::fbs::BtSocketOpenStatus status) {
    fbb_.AddElement<int8_t>(BtSocketOpenResponse::VT_STATUS, static_cast<int8_t>(status), 0);
  }
  void add_reason(flatbuffers::Offset<flatbuffers::Vector<int8_t>> reason) {
    fbb_.AddOffset(BtSocketOpenResponse::VT_REASON, reason);
  }
  explicit BtSocketOpenResponseBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  BtSocketOpenResponseBuilder &operator=(const BtSocketOpenResponseBuilder &);
  flatbuffers::Offset<BtSocketOpenResponse> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<BtSocketOpenResponse>(end);
    return o;
  }
};

inline flatbuffers::Offset<BtSocketOpenResponse> CreateBtSocketOpenResponse(
    flatbuffers::FlatBufferBuilder &_fbb,
    int64_t socketId = 0,
    chre::fbs::BtSocketOpenStatus status = chre::fbs::BtSocketOpenStatus::SUCCESS,
    flatbuffers::Offset<flatbuffers::Vector<int8_t>> reason = 0) {
  BtSocketOpenResponseBuilder builder_(_fbb);
  builder_.add_socketId(socketId);
  builder_.add_reason(reason);
  builder_.add_status(status);
  return builder_.Finish();
}

inline flatbuffers::Offset<BtSocketOpenResponse> CreateBtSocketOpenResponseDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    int64_t socketId = 0,
    chre::fbs::BtSocketOpenStatus status = chre::fbs::BtSocketOpenStatus::SUCCESS,
    const std::vector<int8_t> *reason = nullptr) {
  auto reason__ = reason ? _fbb.CreateVector<int8_t>(*reason) : 0;
  return chre::fbs::CreateBtSocketOpenResponse(
      _fbb,
      socketId,
      status,
      reason__);
}

flatbuffers::Offset<BtSocketOpenResponse> CreateBtSocketOpenResponse(flatbuffers::FlatBufferBuilder &_fbb, const BtSocketOpenResponseT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct BtSocketCloseT : public flatbuffers::NativeTable {
  typedef BtSocketClose TableType;
  int64_t socketId;
  std::vector<int8_t> reason;
  BtSocketCloseT()
      : socketId(0) {
  }
};

struct BtSocketClose FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef BtSocketCloseT NativeTableType;
  typedef BtSocketCloseBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_SOCKETID = 4,
    VT_REASON = 6
  };
  int64_t socketId() const {
    return GetField<int64_t>(VT_SOCKETID, 0);
  }
  bool mutate_socketId(int64_t _socketId) {
    return SetField<int64_t>(VT_SOCKETID, _socketId, 0);
  }
  const flatbuffers::Vector<int8_t> *reason() const {
    return GetPointer<const flatbuffers::Vector<int8_t> *>(VT_REASON);
  }
  flatbuffers::Vector<int8_t> *mutable_reason() {
    return GetPointer<flatbuffers::Vector<int8_t> *>(VT_REASON);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int64_t>(verifier, VT_SOCKETID) &&
           VerifyOffset(verifier, VT_REASON) &&
           verifier.VerifyVector(reason()) &&
           verifier.EndTable();
  }
  BtSocketCloseT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(BtSocketCloseT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<BtSocketClose> Pack(flatbuffers::FlatBufferBuilder &_fbb, const BtSocketCloseT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct BtSocketCloseBuilder {
  typedef BtSocketClose Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_socketId(int64_t socketId) {
    fbb_.AddElement<int64_t>(BtSocketClose::VT_SOCKETID, socketId, 0);
  }
  void add_reason(flatbuffers::Offset<flatbuffers::Vector<int8_t>> reason) {
    fbb_.AddOffset(BtSocketClose::VT_REASON, reason);
  }
  explicit BtSocketCloseBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  BtSocketCloseBuilder &operator=(const BtSocketCloseBuilder &);
  flatbuffers::Offset<BtSocketClose> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<BtSocketClose>(end);
    return o;
  }
};

inline flatbuffers::Offset<BtSocketClose> CreateBtSocketClose(
    flatbuffers::FlatBufferBuilder &_fbb,
    int64_t socketId = 0,
    flatbuffers::Offset<flatbuffers::Vector<int8_t>> reason = 0) {
  BtSocketCloseBuilder builder_(_fbb);
  builder_.add_socketId(socketId);
  builder_.add_reason(reason);
  return builder_.Finish();
}

inline flatbuffers::Offset<BtSocketClose> CreateBtSocketCloseDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    int64_t socketId = 0,
    const std::vector<int8_t> *reason = nullptr) {
  auto reason__ = reason ? _fbb.CreateVector<int8_t>(*reason) : 0;
  return chre::fbs::CreateBtSocketClose(
      _fbb,
      socketId,
      reason__);
}

flatbuffers::Offset<BtSocketClose> CreateBtSocketClose(flatbuffers::FlatBufferBuilder &_fbb, const BtSocketCloseT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct BtSocketCloseResponseT : public flatbuffers::NativeTable {
  typedef BtSocketCloseResponse TableType;
  int64_t socketId;
  BtSocketCloseResponseT()
      : socketId(0) {
  }
};

struct BtSocketCloseResponse FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef BtSocketCloseResponseT NativeTableType;
  typedef BtSocketCloseResponseBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_SOCKETID = 4
  };
  int64_t socketId() const {
    return GetField<int64_t>(VT_SOCKETID, 0);
  }
  bool mutate_socketId(int64_t _socketId) {
    return SetField<int64_t>(VT_SOCKETID, _socketId, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int64_t>(verifier, VT_SOCKETID) &&
           verifier.EndTable();
  }
  BtSocketCloseResponseT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(BtSocketCloseResponseT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<BtSocketCloseResponse> Pack(flatbuffers::FlatBufferBuilder &_fbb, const BtSocketCloseResponseT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct BtSocketCloseResponseBuilder {
  typedef BtSocketCloseResponse Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_socketId(int64_t socketId) {
    fbb_.AddElement<int64_t>(BtSocketCloseResponse::VT_SOCKETID, socketId, 0);
  }
  explicit BtSocketCloseResponseBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  BtSocketCloseResponseBuilder &operator=(const BtSocketCloseResponseBuilder &);
  flatbuffers::Offset<BtSocketCloseResponse> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<BtSocketCloseResponse>(end);
    return o;
  }
};

inline flatbuffers::Offset<BtSocketCloseResponse> CreateBtSocketCloseResponse(
    flatbuffers::FlatBufferBuilder &_fbb,
    int64_t socketId = 0) {
  BtSocketCloseResponseBuilder builder_(_fbb);
  builder_.add_socketId(socketId);
  return builder_.Finish();
}

flatbuffers::Offset<BtSocketCloseResponse> CreateBtSocketCloseResponse(flatbuffers::FlatBufferBuilder &_fbb, const BtSocketCloseResponseT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct BtSocketCapabilitiesRequestT : public flatbuffers::NativeTable {
  typedef BtSocketCapabilitiesRequest TableType;
  BtSocketCapabilitiesRequestT() {
  }
};

struct BtSocketCapabilitiesRequest FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef BtSocketCapabilitiesRequestT NativeTableType;
  typedef BtSocketCapabilitiesRequestBuilder Builder;
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           verifier.EndTable();
  }
  BtSocketCapabilitiesRequestT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(BtSocketCapabilitiesRequestT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<BtSocketCapabilitiesRequest> Pack(flatbuffers::FlatBufferBuilder &_fbb, const BtSocketCapabilitiesRequestT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct BtSocketCapabilitiesRequestBuilder {
  typedef BtSocketCapabilitiesRequest Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  explicit BtSocketCapabilitiesRequestBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  BtSocketCapabilitiesRequestBuilder &operator=(const BtSocketCapabilitiesRequestBuilder &);
  flatbuffers::Offset<BtSocketCapabilitiesRequest> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<BtSocketCapabilitiesRequest>(end);
    return o;
  }
};

inline flatbuffers::Offset<BtSocketCapabilitiesRequest> CreateBtSocketCapabilitiesRequest(
    flatbuffers::FlatBufferBuilder &_fbb) {
  BtSocketCapabilitiesRequestBuilder builder_(_fbb);
  return builder_.Finish();
}

flatbuffers::Offset<BtSocketCapabilitiesRequest> CreateBtSocketCapabilitiesRequest(flatbuffers::FlatBufferBuilder &_fbb, const BtSocketCapabilitiesRequestT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct BtSocketLeCocCapabilitiesT : public flatbuffers::NativeTable {
  typedef BtSocketLeCocCapabilities TableType;
  int32_t numberOfSupportedSockets;
  int32_t mtu;
  BtSocketLeCocCapabilitiesT()
      : numberOfSupportedSockets(0),
        mtu(0) {
  }
};

struct BtSocketLeCocCapabilities FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef BtSocketLeCocCapabilitiesT NativeTableType;
  typedef BtSocketLeCocCapabilitiesBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_NUMBEROFSUPPORTEDSOCKETS = 4,
    VT_MTU = 6
  };
  int32_t numberOfSupportedSockets() const {
    return GetField<int32_t>(VT_NUMBEROFSUPPORTEDSOCKETS, 0);
  }
  bool mutate_numberOfSupportedSockets(int32_t _numberOfSupportedSockets) {
    return SetField<int32_t>(VT_NUMBEROFSUPPORTEDSOCKETS, _numberOfSupportedSockets, 0);
  }
  int32_t mtu() const {
    return GetField<int32_t>(VT_MTU, 0);
  }
  bool mutate_mtu(int32_t _mtu) {
    return SetField<int32_t>(VT_MTU, _mtu, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_NUMBEROFSUPPORTEDSOCKETS) &&
           VerifyField<int32_t>(verifier, VT_MTU) &&
           verifier.EndTable();
  }
  BtSocketLeCocCapabilitiesT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(BtSocketLeCocCapabilitiesT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<BtSocketLeCocCapabilities> Pack(flatbuffers::FlatBufferBuilder &_fbb, const BtSocketLeCocCapabilitiesT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct BtSocketLeCocCapabilitiesBuilder {
  typedef BtSocketLeCocCapabilities Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_numberOfSupportedSockets(int32_t numberOfSupportedSockets) {
    fbb_.AddElement<int32_t>(BtSocketLeCocCapabilities::VT_NUMBEROFSUPPORTEDSOCKETS, numberOfSupportedSockets, 0);
  }
  void add_mtu(int32_t mtu) {
    fbb_.AddElement<int32_t>(BtSocketLeCocCapabilities::VT_MTU, mtu, 0);
  }
  explicit BtSocketLeCocCapabilitiesBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  BtSocketLeCocCapabilitiesBuilder &operator=(const BtSocketLeCocCapabilitiesBuilder &);
  flatbuffers::Offset<BtSocketLeCocCapabilities> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<BtSocketLeCocCapabilities>(end);
    return o;
  }
};

inline flatbuffers::Offset<BtSocketLeCocCapabilities> CreateBtSocketLeCocCapabilities(
    flatbuffers::FlatBufferBuilder &_fbb,
    int32_t numberOfSupportedSockets = 0,
    int32_t mtu = 0) {
  BtSocketLeCocCapabilitiesBuilder builder_(_fbb);
  builder_.add_mtu(mtu);
  builder_.add_numberOfSupportedSockets(numberOfSupportedSockets);
  return builder_.Finish();
}

flatbuffers::Offset<BtSocketLeCocCapabilities> CreateBtSocketLeCocCapabilities(flatbuffers::FlatBufferBuilder &_fbb, const BtSocketLeCocCapabilitiesT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct BtSocketRfcommCapabilitiesT : public flatbuffers::NativeTable {
  typedef BtSocketRfcommCapabilities TableType;
  int32_t numberOfSupportedSockets;
  int32_t maxFrameSize;
  BtSocketRfcommCapabilitiesT()
      : numberOfSupportedSockets(0),
        maxFrameSize(0) {
  }
};

struct BtSocketRfcommCapabilities FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef BtSocketRfcommCapabilitiesT NativeTableType;
  typedef BtSocketRfcommCapabilitiesBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_NUMBEROFSUPPORTEDSOCKETS = 4,
    VT_MAXFRAMESIZE = 6
  };
  int32_t numberOfSupportedSockets() const {
    return GetField<int32_t>(VT_NUMBEROFSUPPORTEDSOCKETS, 0);
  }
  bool mutate_numberOfSupportedSockets(int32_t _numberOfSupportedSockets) {
    return SetField<int32_t>(VT_NUMBEROFSUPPORTEDSOCKETS, _numberOfSupportedSockets, 0);
  }
  int32_t maxFrameSize() const {
    return GetField<int32_t>(VT_MAXFRAMESIZE, 0);
  }
  bool mutate_maxFrameSize(int32_t _maxFrameSize) {
    return SetField<int32_t>(VT_MAXFRAMESIZE, _maxFrameSize, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_NUMBEROFSUPPORTEDSOCKETS) &&
           VerifyField<int32_t>(verifier, VT_MAXFRAMESIZE) &&
           verifier.EndTable();
  }
  BtSocketRfcommCapabilitiesT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(BtSocketRfcommCapabilitiesT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<BtSocketRfcommCapabilities> Pack(flatbuffers::FlatBufferBuilder &_fbb, const BtSocketRfcommCapabilitiesT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct BtSocketRfcommCapabilitiesBuilder {
  typedef BtSocketRfcommCapabilities Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_numberOfSupportedSockets(int32_t numberOfSupportedSockets) {
    fbb_.AddElement<int32_t>(BtSocketRfcommCapabilities::VT_NUMBEROFSUPPORTEDSOCKETS, numberOfSupportedSockets, 0);
  }
  void add_maxFrameSize(int32_t maxFrameSize) {
    fbb_.AddElement<int32_t>(BtSocketRfcommCapabilities::VT_MAXFRAMESIZE, maxFrameSize, 0);
  }
  explicit BtSocketRfcommCapabilitiesBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  BtSocketRfcommCapabilitiesBuilder &operator=(const BtSocketRfcommCapabilitiesBuilder &);
  flatbuffers::Offset<BtSocketRfcommCapabilities> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<BtSocketRfcommCapabilities>(end);
    return o;
  }
};

inline flatbuffers::Offset<BtSocketRfcommCapabilities> CreateBtSocketRfcommCapabilities(
    flatbuffers::FlatBufferBuilder &_fbb,
    int32_t numberOfSupportedSockets = 0,
    int32_t maxFrameSize = 0) {
  BtSocketRfcommCapabilitiesBuilder builder_(_fbb);
  builder_.add_maxFrameSize(maxFrameSize);
  builder_.add_numberOfSupportedSockets(numberOfSupportedSockets);
  return builder_.Finish();
}

flatbuffers::Offset<BtSocketRfcommCapabilities> CreateBtSocketRfcommCapabilities(flatbuffers::FlatBufferBuilder &_fbb, const BtSocketRfcommCapabilitiesT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct BtSocketCapabilitiesResponseT : public flatbuffers::NativeTable {
  typedef BtSocketCapabilitiesResponse TableType;
  std::unique_ptr<chre::fbs::BtSocketLeCocCapabilitiesT> leCocCapabilities;
  std::unique_ptr<chre::fbs::BtSocketRfcommCapabilitiesT> rfcommCapabilities;
  BtSocketCapabilitiesResponseT() {
  }
};

struct BtSocketCapabilitiesResponse FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef BtSocketCapabilitiesResponseT NativeTableType;
  typedef BtSocketCapabilitiesResponseBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_LECOCCAPABILITIES = 4,
    VT_RFCOMMCAPABILITIES = 6
  };
  const chre::fbs::BtSocketLeCocCapabilities *leCocCapabilities() const {
    return GetPointer<const chre::fbs::BtSocketLeCocCapabilities *>(VT_LECOCCAPABILITIES);
  }
  chre::fbs::BtSocketLeCocCapabilities *mutable_leCocCapabilities() {
    return GetPointer<chre::fbs::BtSocketLeCocCapabilities *>(VT_LECOCCAPABILITIES);
  }
  const chre::fbs::BtSocketRfcommCapabilities *rfcommCapabilities() const {
    return GetPointer<const chre::fbs::BtSocketRfcommCapabilities *>(VT_RFCOMMCAPABILITIES);
  }
  chre::fbs::BtSocketRfcommCapabilities *mutable_rfcommCapabilities() {
    return GetPointer<chre::fbs::BtSocketRfcommCapabilities *>(VT_RFCOMMCAPABILITIES);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_LECOCCAPABILITIES) &&
           verifier.VerifyTable(leCocCapabilities()) &&
           VerifyOffset(verifier, VT_RFCOMMCAPABILITIES) &&
           verifier.VerifyTable(rfcommCapabilities()) &&
           verifier.EndTable();
  }
  BtSocketCapabilitiesResponseT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(BtSocketCapabilitiesResponseT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<BtSocketCapabilitiesResponse> Pack(flatbuffers::FlatBufferBuilder &_fbb, const BtSocketCapabilitiesResponseT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct BtSocketCapabilitiesResponseBuilder {
  typedef BtSocketCapabilitiesResponse Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_leCocCapabilities(flatbuffers::Offset<chre::fbs::BtSocketLeCocCapabilities> leCocCapabilities) {
    fbb_.AddOffset(BtSocketCapabilitiesResponse::VT_LECOCCAPABILITIES, leCocCapabilities);
  }
  void add_rfcommCapabilities(flatbuffers::Offset<chre::fbs::BtSocketRfcommCapabilities> rfcommCapabilities) {
    fbb_.AddOffset(BtSocketCapabilitiesResponse::VT_RFCOMMCAPABILITIES, rfcommCapabilities);
  }
  explicit BtSocketCapabilitiesResponseBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  BtSocketCapabilitiesResponseBuilder &operator=(const BtSocketCapabilitiesResponseBuilder &);
  flatbuffers::Offset<BtSocketCapabilitiesResponse> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<BtSocketCapabilitiesResponse>(end);
    return o;
  }
};

inline flatbuffers::Offset<BtSocketCapabilitiesResponse> CreateBtSocketCapabilitiesResponse(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<chre::fbs::BtSocketLeCocCapabilities> leCocCapabilities = 0,
    flatbuffers::Offset<chre::fbs::BtSocketRfcommCapabilities> rfcommCapabilities = 0) {
  BtSocketCapabilitiesResponseBuilder builder_(_fbb);
  builder_.add_rfcommCapabilities(rfcommCapabilities);
  builder_.add_leCocCapabilities(leCocCapabilities);
  return builder_.Finish();
}

flatbuffers::Offset<BtSocketCapabilitiesResponse> CreateBtSocketCapabilitiesResponse(flatbuffers::FlatBufferBuilder &_fbb, const BtSocketCapabilitiesResponseT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct VendorHubInfoT : public flatbuffers::NativeTable {
  typedef VendorHubInfo TableType;
  std::vector<int8_t> name;
  uint32_t version;
  std::vector<uint8_t> extended_info;
  VendorHubInfoT()
      : version(0) {
  }
};

struct VendorHubInfo FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef VendorHubInfoT NativeTableType;
  typedef VendorHubInfoBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_NAME = 4,
    VT_VERSION = 6,
    VT_EXTENDED_INFO = 8
  };
  /// The name of the hub. Nominally a UTF-8 string, but note that we're not
  /// using the built-in "string" data type from FlatBuffers here, because the
  /// generated C++ uses std::string which is not well-supported in CHRE.
  const flatbuffers::Vector<int8_t> *name() const {
    return GetPointer<const flatbuffers::Vector<int8_t> *>(VT_NAME);
  }
  flatbuffers::Vector<int8_t> *mutable_name() {
    return GetPointer<flatbuffers::Vector<int8_t> *>(VT_NAME);
  }
  /// Hub version
  uint32_t version() const {
    return GetField<uint32_t>(VT_VERSION, 0);
  }
  bool mutate_version(uint32_t _version) {
    return SetField<uint32_t>(VT_VERSION, _version, 0);
  }
  /// Additional vendor-defined data
  const flatbuffers::Vector<uint8_t> *extended_info() const {
    return GetPointer<const flatbuffers::Vector<uint8_t> *>(VT_EXTENDED_INFO);
  }
  flatbuffers::Vector<uint8_t> *mutable_extended_info() {
    return GetPointer<flatbuffers::Vector<uint8_t> *>(VT_EXTENDED_INFO);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_NAME) &&
           verifier.VerifyVector(name()) &&
           VerifyField<uint32_t>(verifier, VT_VERSION) &&
           VerifyOffset(verifier, VT_EXTENDED_INFO) &&
           verifier.VerifyVector(extended_info()) &&
           verifier.EndTable();
  }
  VendorHubInfoT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(VendorHubInfoT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<VendorHubInfo> Pack(flatbuffers::FlatBufferBuilder &_fbb, const VendorHubInfoT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct VendorHubInfoBuilder {
  typedef VendorHubInfo Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_name(flatbuffers::Offset<flatbuffers::Vector<int8_t>> name) {
    fbb_.AddOffset(VendorHubInfo::VT_NAME, name);
  }
  void add_version(uint32_t version) {
    fbb_.AddElement<uint32_t>(VendorHubInfo::VT_VERSION, version, 0);
  }
  void add_extended_info(flatbuffers::Offset<flatbuffers::Vector<uint8_t>> extended_info) {
    fbb_.AddOffset(VendorHubInfo::VT_EXTENDED_INFO, extended_info);
  }
  explicit VendorHubInfoBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  VendorHubInfoBuilder &operator=(const VendorHubInfoBuilder &);
  flatbuffers::Offset<VendorHubInfo> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<VendorHubInfo>(end);
    return o;
  }
};

inline flatbuffers::Offset<VendorHubInfo> CreateVendorHubInfo(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::Vector<int8_t>> name = 0,
    uint32_t version = 0,
    flatbuffers::Offset<flatbuffers::Vector<uint8_t>> extended_info = 0) {
  VendorHubInfoBuilder builder_(_fbb);
  builder_.add_extended_info(extended_info);
  builder_.add_version(version);
  builder_.add_name(name);
  return builder_.Finish();
}

inline flatbuffers::Offset<VendorHubInfo> CreateVendorHubInfoDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const std::vector<int8_t> *name = nullptr,
    uint32_t version = 0,
    const std::vector<uint8_t> *extended_info = nullptr) {
  auto name__ = name ? _fbb.CreateVector<int8_t>(*name) : 0;
  auto extended_info__ = extended_info ? _fbb.CreateVector<uint8_t>(*extended_info) : 0;
  return chre::fbs::CreateVendorHubInfo(
      _fbb,
      name__,
      version,
      extended_info__);
}

flatbuffers::Offset<VendorHubInfo> CreateVendorHubInfo(flatbuffers::FlatBufferBuilder &_fbb, const VendorHubInfoT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct MessageHubT : public flatbuffers::NativeTable {
  typedef MessageHub TableType;
  int64_t id;
  chre::fbs::MessageHubDetailsUnion details;
  MessageHubT()
      : id(0) {
  }
};

struct MessageHub FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef MessageHubT NativeTableType;
  typedef MessageHubBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_ID = 4,
    VT_DETAILS_TYPE = 6,
    VT_DETAILS = 8
  };
  /// The hub id. -1 is reserved and 0 is invalid. 0x416e64726f696400 represents
  /// the ContextHub service.
  int64_t id() const {
    return GetField<int64_t>(VT_ID, 0);
  }
  bool mutate_id(int64_t _id) {
    return SetField<int64_t>(VT_ID, _id, 0);
  }
  chre::fbs::MessageHubDetails details_type() const {
    return static_cast<chre::fbs::MessageHubDetails>(GetField<uint8_t>(VT_DETAILS_TYPE, 0));
  }
  /// Details of the message hub.
  const void *details() const {
    return GetPointer<const void *>(VT_DETAILS);
  }
  template<typename T> const T *details_as() const;
  const chre::fbs::HubInfoResponse *details_as_HubInfoResponse() const {
    return details_type() == chre::fbs::MessageHubDetails::HubInfoResponse ? static_cast<const chre::fbs::HubInfoResponse *>(details()) : nullptr;
  }
  const chre::fbs::VendorHubInfo *details_as_VendorHubInfo() const {
    return details_type() == chre::fbs::MessageHubDetails::VendorHubInfo ? static_cast<const chre::fbs::VendorHubInfo *>(details()) : nullptr;
  }
  void *mutable_details() {
    return GetPointer<void *>(VT_DETAILS);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int64_t>(verifier, VT_ID) &&
           VerifyField<uint8_t>(verifier, VT_DETAILS_TYPE) &&
           VerifyOffset(verifier, VT_DETAILS) &&
           VerifyMessageHubDetails(verifier, details(), details_type()) &&
           verifier.EndTable();
  }
  MessageHubT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(MessageHubT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<MessageHub> Pack(flatbuffers::FlatBufferBuilder &_fbb, const MessageHubT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

template<> inline const chre::fbs::HubInfoResponse *MessageHub::details_as<chre::fbs::HubInfoResponse>() const {
  return details_as_HubInfoResponse();
}

template<> inline const chre::fbs::VendorHubInfo *MessageHub::details_as<chre::fbs::VendorHubInfo>() const {
  return details_as_VendorHubInfo();
}

struct MessageHubBuilder {
  typedef MessageHub Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_id(int64_t id) {
    fbb_.AddElement<int64_t>(MessageHub::VT_ID, id, 0);
  }
  void add_details_type(chre::fbs::MessageHubDetails details_type) {
    fbb_.AddElement<uint8_t>(MessageHub::VT_DETAILS_TYPE, static_cast<uint8_t>(details_type), 0);
  }
  void add_details(flatbuffers::Offset<void> details) {
    fbb_.AddOffset(MessageHub::VT_DETAILS, details);
  }
  explicit MessageHubBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  MessageHubBuilder &operator=(const MessageHubBuilder &);
  flatbuffers::Offset<MessageHub> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<MessageHub>(end);
    return o;
  }
};

inline flatbuffers::Offset<MessageHub> CreateMessageHub(
    flatbuffers::FlatBufferBuilder &_fbb,
    int64_t id = 0,
    chre::fbs::MessageHubDetails details_type = chre::fbs::MessageHubDetails::NONE,
    flatbuffers::Offset<void> details = 0) {
  MessageHubBuilder builder_(_fbb);
  builder_.add_id(id);
  builder_.add_details(details);
  builder_.add_details_type(details_type);
  return builder_.Finish();
}

flatbuffers::Offset<MessageHub> CreateMessageHub(flatbuffers::FlatBufferBuilder &_fbb, const MessageHubT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct RegisterMessageHubT : public flatbuffers::NativeTable {
  typedef RegisterMessageHub TableType;
  std::unique_ptr<chre::fbs::MessageHubT> hub;
  RegisterMessageHubT() {
  }
};

struct RegisterMessageHub FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef RegisterMessageHubT NativeTableType;
  typedef RegisterMessageHubBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_HUB = 4
  };
  const chre::fbs::MessageHub *hub() const {
    return GetPointer<const chre::fbs::MessageHub *>(VT_HUB);
  }
  chre::fbs::MessageHub *mutable_hub() {
    return GetPointer<chre::fbs::MessageHub *>(VT_HUB);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_HUB) &&
           verifier.VerifyTable(hub()) &&
           verifier.EndTable();
  }
  RegisterMessageHubT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(RegisterMessageHubT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<RegisterMessageHub> Pack(flatbuffers::FlatBufferBuilder &_fbb, const RegisterMessageHubT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct RegisterMessageHubBuilder {
  typedef RegisterMessageHub Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_hub(flatbuffers::Offset<chre::fbs::MessageHub> hub) {
    fbb_.AddOffset(RegisterMessageHub::VT_HUB, hub);
  }
  explicit RegisterMessageHubBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  RegisterMessageHubBuilder &operator=(const RegisterMessageHubBuilder &);
  flatbuffers::Offset<RegisterMessageHub> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<RegisterMessageHub>(end);
    return o;
  }
};

inline flatbuffers::Offset<RegisterMessageHub> CreateRegisterMessageHub(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<chre::fbs::MessageHub> hub = 0) {
  RegisterMessageHubBuilder builder_(_fbb);
  builder_.add_hub(hub);
  return builder_.Finish();
}

flatbuffers::Offset<RegisterMessageHub> CreateRegisterMessageHub(flatbuffers::FlatBufferBuilder &_fbb, const RegisterMessageHubT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct UnregisterMessageHubT : public flatbuffers::NativeTable {
  typedef UnregisterMessageHub TableType;
  int64_t id;
  UnregisterMessageHubT()
      : id(0) {
  }
};

struct UnregisterMessageHub FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef UnregisterMessageHubT NativeTableType;
  typedef UnregisterMessageHubBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_ID = 4
  };
  int64_t id() const {
    return GetField<int64_t>(VT_ID, 0);
  }
  bool mutate_id(int64_t _id) {
    return SetField<int64_t>(VT_ID, _id, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int64_t>(verifier, VT_ID) &&
           verifier.EndTable();
  }
  UnregisterMessageHubT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(UnregisterMessageHubT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<UnregisterMessageHub> Pack(flatbuffers::FlatBufferBuilder &_fbb, const UnregisterMessageHubT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct UnregisterMessageHubBuilder {
  typedef UnregisterMessageHub Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_id(int64_t id) {
    fbb_.AddElement<int64_t>(UnregisterMessageHub::VT_ID, id, 0);
  }
  explicit UnregisterMessageHubBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  UnregisterMessageHubBuilder &operator=(const UnregisterMessageHubBuilder &);
  flatbuffers::Offset<UnregisterMessageHub> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<UnregisterMessageHub>(end);
    return o;
  }
};

inline flatbuffers::Offset<UnregisterMessageHub> CreateUnregisterMessageHub(
    flatbuffers::FlatBufferBuilder &_fbb,
    int64_t id = 0) {
  UnregisterMessageHubBuilder builder_(_fbb);
  builder_.add_id(id);
  return builder_.Finish();
}

flatbuffers::Offset<UnregisterMessageHub> CreateUnregisterMessageHub(flatbuffers::FlatBufferBuilder &_fbb, const UnregisterMessageHubT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct EndpointIdT : public flatbuffers::NativeTable {
  typedef EndpointId TableType;
  int64_t hubId;
  int64_t id;
  EndpointIdT()
      : hubId(0),
        id(0) {
  }
};

struct EndpointId FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef EndpointIdT NativeTableType;
  typedef EndpointIdBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_HUBID = 4,
    VT_ID = 6
  };
  /// Id of the hub hosting the endpoint
  int64_t hubId() const {
    return GetField<int64_t>(VT_HUBID, 0);
  }
  bool mutate_hubId(int64_t _hubId) {
    return SetField<int64_t>(VT_HUBID, _hubId, 0);
  }
  /// The id of the endpoint scoped to the hub
  int64_t id() const {
    return GetField<int64_t>(VT_ID, 0);
  }
  bool mutate_id(int64_t _id) {
    return SetField<int64_t>(VT_ID, _id, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int64_t>(verifier, VT_HUBID) &&
           VerifyField<int64_t>(verifier, VT_ID) &&
           verifier.EndTable();
  }
  EndpointIdT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(EndpointIdT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<EndpointId> Pack(flatbuffers::FlatBufferBuilder &_fbb, const EndpointIdT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct EndpointIdBuilder {
  typedef EndpointId Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_hubId(int64_t hubId) {
    fbb_.AddElement<int64_t>(EndpointId::VT_HUBID, hubId, 0);
  }
  void add_id(int64_t id) {
    fbb_.AddElement<int64_t>(EndpointId::VT_ID, id, 0);
  }
  explicit EndpointIdBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  EndpointIdBuilder &operator=(const EndpointIdBuilder &);
  flatbuffers::Offset<EndpointId> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<EndpointId>(end);
    return o;
  }
};

inline flatbuffers::Offset<EndpointId> CreateEndpointId(
    flatbuffers::FlatBufferBuilder &_fbb,
    int64_t hubId = 0,
    int64_t id = 0) {
  EndpointIdBuilder builder_(_fbb);
  builder_.add_id(id);
  builder_.add_hubId(hubId);
  return builder_.Finish();
}

flatbuffers::Offset<EndpointId> CreateEndpointId(flatbuffers::FlatBufferBuilder &_fbb, const EndpointIdT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct ServiceT : public flatbuffers::NativeTable {
  typedef Service TableType;
  chre::fbs::RpcFormat format;
  std::vector<int8_t> descriptor;
  uint32_t major_version;
  uint32_t minor_version;
  ServiceT()
      : format(chre::fbs::RpcFormat::CUSTOM),
        major_version(0),
        minor_version(0) {
  }
};

struct Service FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef ServiceT NativeTableType;
  typedef ServiceBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_FORMAT = 4,
    VT_DESCRIPTOR = 6,
    VT_MAJOR_VERSION = 8,
    VT_MINOR_VERSION = 10
  };
  chre::fbs::RpcFormat format() const {
    return static_cast<chre::fbs::RpcFormat>(GetField<uint8_t>(VT_FORMAT, 0));
  }
  bool mutate_format(chre::fbs::RpcFormat _format) {
    return SetField<uint8_t>(VT_FORMAT, static_cast<uint8_t>(_format), 0);
  }
  /// Service descriptor. Nominally a UTF-8 string, but note that we're not
  /// using the built-in "string" data type from FlatBuffers here, because the
  /// generated C++ uses std::string which is not well-supported in CHRE.
  const flatbuffers::Vector<int8_t> *descriptor() const {
    return GetPointer<const flatbuffers::Vector<int8_t> *>(VT_DESCRIPTOR);
  }
  flatbuffers::Vector<int8_t> *mutable_descriptor() {
    return GetPointer<flatbuffers::Vector<int8_t> *>(VT_DESCRIPTOR);
  }
  /// Breaking changes should bump the major version.
  uint32_t major_version() const {
    return GetField<uint32_t>(VT_MAJOR_VERSION, 0);
  }
  bool mutate_major_version(uint32_t _major_version) {
    return SetField<uint32_t>(VT_MAJOR_VERSION, _major_version, 0);
  }
  /// Monotonically increasing minor version.
  uint32_t minor_version() const {
    return GetField<uint32_t>(VT_MINOR_VERSION, 0);
  }
  bool mutate_minor_version(uint32_t _minor_version) {
    return SetField<uint32_t>(VT_MINOR_VERSION, _minor_version, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint8_t>(verifier, VT_FORMAT) &&
           VerifyOffset(verifier, VT_DESCRIPTOR) &&
           verifier.VerifyVector(descriptor()) &&
           VerifyField<uint32_t>(verifier, VT_MAJOR_VERSION) &&
           VerifyField<uint32_t>(verifier, VT_MINOR_VERSION) &&
           verifier.EndTable();
  }
  ServiceT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(ServiceT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<Service> Pack(flatbuffers::FlatBufferBuilder &_fbb, const ServiceT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct ServiceBuilder {
  typedef Service Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_format(chre::fbs::RpcFormat format) {
    fbb_.AddElement<uint8_t>(Service::VT_FORMAT, static_cast<uint8_t>(format), 0);
  }
  void add_descriptor(flatbuffers::Offset<flatbuffers::Vector<int8_t>> descriptor) {
    fbb_.AddOffset(Service::VT_DESCRIPTOR, descriptor);
  }
  void add_major_version(uint32_t major_version) {
    fbb_.AddElement<uint32_t>(Service::VT_MAJOR_VERSION, major_version, 0);
  }
  void add_minor_version(uint32_t minor_version) {
    fbb_.AddElement<uint32_t>(Service::VT_MINOR_VERSION, minor_version, 0);
  }
  explicit ServiceBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ServiceBuilder &operator=(const ServiceBuilder &);
  flatbuffers::Offset<Service> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<Service>(end);
    return o;
  }
};

inline flatbuffers::Offset<Service> CreateService(
    flatbuffers::FlatBufferBuilder &_fbb,
    chre::fbs::RpcFormat format = chre::fbs::RpcFormat::CUSTOM,
    flatbuffers::Offset<flatbuffers::Vector<int8_t>> descriptor = 0,
    uint32_t major_version = 0,
    uint32_t minor_version = 0) {
  ServiceBuilder builder_(_fbb);
  builder_.add_minor_version(minor_version);
  builder_.add_major_version(major_version);
  builder_.add_descriptor(descriptor);
  builder_.add_format(format);
  return builder_.Finish();
}

inline flatbuffers::Offset<Service> CreateServiceDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    chre::fbs::RpcFormat format = chre::fbs::RpcFormat::CUSTOM,
    const std::vector<int8_t> *descriptor = nullptr,
    uint32_t major_version = 0,
    uint32_t minor_version = 0) {
  auto descriptor__ = descriptor ? _fbb.CreateVector<int8_t>(*descriptor) : 0;
  return chre::fbs::CreateService(
      _fbb,
      format,
      descriptor__,
      major_version,
      minor_version);
}

flatbuffers::Offset<Service> CreateService(flatbuffers::FlatBufferBuilder &_fbb, const ServiceT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct EndpointInfoT : public flatbuffers::NativeTable {
  typedef EndpointInfo TableType;
  std::unique_ptr<chre::fbs::EndpointIdT> id;
  chre::fbs::EndpointType type;
  std::vector<int8_t> name;
  uint32_t version;
  uint32_t required_permissions;
  std::vector<std::unique_ptr<chre::fbs::ServiceT>> services;
  EndpointInfoT()
      : type(chre::fbs::EndpointType::INVALID),
        version(0),
        required_permissions(0) {
  }
};

struct EndpointInfo FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef EndpointInfoT NativeTableType;
  typedef EndpointInfoBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_ID = 4,
    VT_TYPE = 6,
    VT_NAME = 8,
    VT_VERSION = 10,
    VT_REQUIRED_PERMISSIONS = 12,
    VT_SERVICES = 14
  };
  const chre::fbs::EndpointId *id() const {
    return GetPointer<const chre::fbs::EndpointId *>(VT_ID);
  }
  chre::fbs::EndpointId *mutable_id() {
    return GetPointer<chre::fbs::EndpointId *>(VT_ID);
  }
  chre::fbs::EndpointType type() const {
    return static_cast<chre::fbs::EndpointType>(GetField<uint8_t>(VT_TYPE, 0));
  }
  bool mutate_type(chre::fbs::EndpointType _type) {
    return SetField<uint8_t>(VT_TYPE, static_cast<uint8_t>(_type), 0);
  }
  /// Endpoing name. Nominally a UTF-8 string, but note that we're not using
  /// the built-in "string" data type from FlatBuffers here, because the
  /// generated C++ uses std::string which is not well-supported in CHRE.
  const flatbuffers::Vector<int8_t> *name() const {
    return GetPointer<const flatbuffers::Vector<int8_t> *>(VT_NAME);
  }
  flatbuffers::Vector<int8_t> *mutable_name() {
    return GetPointer<flatbuffers::Vector<int8_t> *>(VT_NAME);
  }
  uint32_t version() const {
    return GetField<uint32_t>(VT_VERSION, 0);
  }
  bool mutate_version(uint32_t _version) {
    return SetField<uint32_t>(VT_VERSION, _version, 0);
  }
  /// Values from CHRE_MESSAGE_PERMISSION_*
  uint32_t required_permissions() const {
    return GetField<uint32_t>(VT_REQUIRED_PERMISSIONS, 0);
  }
  bool mutate_required_permissions(uint32_t _required_permissions) {
    return SetField<uint32_t>(VT_REQUIRED_PERMISSIONS, _required_permissions, 0);
  }
  const flatbuffers::Vector<flatbuffers::Offset<chre::fbs::Service>> *services() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<chre::fbs::Service>> *>(VT_SERVICES);
  }
  flatbuffers::Vector<flatbuffers::Offset<chre::fbs::Service>> *mutable_services() {
    return GetPointer<flatbuffers::Vector<flatbuffers::Offset<chre::fbs::Service>> *>(VT_SERVICES);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_ID) &&
           verifier.VerifyTable(id()) &&
           VerifyField<uint8_t>(verifier, VT_TYPE) &&
           VerifyOffset(verifier, VT_NAME) &&
           verifier.VerifyVector(name()) &&
           VerifyField<uint32_t>(verifier, VT_VERSION) &&
           VerifyField<uint32_t>(verifier, VT_REQUIRED_PERMISSIONS) &&
           VerifyOffset(verifier, VT_SERVICES) &&
           verifier.VerifyVector(services()) &&
           verifier.VerifyVectorOfTables(services()) &&
           verifier.EndTable();
  }
  EndpointInfoT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(EndpointInfoT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<EndpointInfo> Pack(flatbuffers::FlatBufferBuilder &_fbb, const EndpointInfoT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct EndpointInfoBuilder {
  typedef EndpointInfo Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_id(flatbuffers::Offset<chre::fbs::EndpointId> id) {
    fbb_.AddOffset(EndpointInfo::VT_ID, id);
  }
  void add_type(chre::fbs::EndpointType type) {
    fbb_.AddElement<uint8_t>(EndpointInfo::VT_TYPE, static_cast<uint8_t>(type), 0);
  }
  void add_name(flatbuffers::Offset<flatbuffers::Vector<int8_t>> name) {
    fbb_.AddOffset(EndpointInfo::VT_NAME, name);
  }
  void add_version(uint32_t version) {
    fbb_.AddElement<uint32_t>(EndpointInfo::VT_VERSION, version, 0);
  }
  void add_required_permissions(uint32_t required_permissions) {
    fbb_.AddElement<uint32_t>(EndpointInfo::VT_REQUIRED_PERMISSIONS, required_permissions, 0);
  }
  void add_services(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<chre::fbs::Service>>> services) {
    fbb_.AddOffset(EndpointInfo::VT_SERVICES, services);
  }
  explicit EndpointInfoBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  EndpointInfoBuilder &operator=(const EndpointInfoBuilder &);
  flatbuffers::Offset<EndpointInfo> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<EndpointInfo>(end);
    return o;
  }
};

inline flatbuffers::Offset<EndpointInfo> CreateEndpointInfo(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<chre::fbs::EndpointId> id = 0,
    chre::fbs::EndpointType type = chre::fbs::EndpointType::INVALID,
    flatbuffers::Offset<flatbuffers::Vector<int8_t>> name = 0,
    uint32_t version = 0,
    uint32_t required_permissions = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<chre::fbs::Service>>> services = 0) {
  EndpointInfoBuilder builder_(_fbb);
  builder_.add_services(services);
  builder_.add_required_permissions(required_permissions);
  builder_.add_version(version);
  builder_.add_name(name);
  builder_.add_id(id);
  builder_.add_type(type);
  return builder_.Finish();
}

inline flatbuffers::Offset<EndpointInfo> CreateEndpointInfoDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<chre::fbs::EndpointId> id = 0,
    chre::fbs::EndpointType type = chre::fbs::EndpointType::INVALID,
    const std::vector<int8_t> *name = nullptr,
    uint32_t version = 0,
    uint32_t required_permissions = 0,
    const std::vector<flatbuffers::Offset<chre::fbs::Service>> *services = nullptr) {
  auto name__ = name ? _fbb.CreateVector<int8_t>(*name) : 0;
  auto services__ = services ? _fbb.CreateVector<flatbuffers::Offset<chre::fbs::Service>>(*services) : 0;
  return chre::fbs::CreateEndpointInfo(
      _fbb,
      id,
      type,
      name__,
      version,
      required_permissions,
      services__);
}

flatbuffers::Offset<EndpointInfo> CreateEndpointInfo(flatbuffers::FlatBufferBuilder &_fbb, const EndpointInfoT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct RegisterEndpointT : public flatbuffers::NativeTable {
  typedef RegisterEndpoint TableType;
  std::unique_ptr<chre::fbs::EndpointInfoT> endpoint;
  RegisterEndpointT() {
  }
};

struct RegisterEndpoint FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef RegisterEndpointT NativeTableType;
  typedef RegisterEndpointBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_ENDPOINT = 4
  };
  const chre::fbs::EndpointInfo *endpoint() const {
    return GetPointer<const chre::fbs::EndpointInfo *>(VT_ENDPOINT);
  }
  chre::fbs::EndpointInfo *mutable_endpoint() {
    return GetPointer<chre::fbs::EndpointInfo *>(VT_ENDPOINT);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_ENDPOINT) &&
           verifier.VerifyTable(endpoint()) &&
           verifier.EndTable();
  }
  RegisterEndpointT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(RegisterEndpointT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<RegisterEndpoint> Pack(flatbuffers::FlatBufferBuilder &_fbb, const RegisterEndpointT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct RegisterEndpointBuilder {
  typedef RegisterEndpoint Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_endpoint(flatbuffers::Offset<chre::fbs::EndpointInfo> endpoint) {
    fbb_.AddOffset(RegisterEndpoint::VT_ENDPOINT, endpoint);
  }
  explicit RegisterEndpointBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  RegisterEndpointBuilder &operator=(const RegisterEndpointBuilder &);
  flatbuffers::Offset<RegisterEndpoint> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<RegisterEndpoint>(end);
    return o;
  }
};

inline flatbuffers::Offset<RegisterEndpoint> CreateRegisterEndpoint(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<chre::fbs::EndpointInfo> endpoint = 0) {
  RegisterEndpointBuilder builder_(_fbb);
  builder_.add_endpoint(endpoint);
  return builder_.Finish();
}

flatbuffers::Offset<RegisterEndpoint> CreateRegisterEndpoint(flatbuffers::FlatBufferBuilder &_fbb, const RegisterEndpointT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct AddServiceToEndpointT : public flatbuffers::NativeTable {
  typedef AddServiceToEndpoint TableType;
  std::unique_ptr<chre::fbs::EndpointIdT> endpoint;
  std::unique_ptr<chre::fbs::ServiceT> service;
  AddServiceToEndpointT() {
  }
};

/// MessageRouter handles service inspection separately from endpoint inspection
/// so these messages are required to send embedded endpoint information in
/// pieces to the host. After RegisterEndpoint, the endpoint is only ready once
/// an EndpointReady message is sent. After EndpointReady, AddServiceToEndpoint
/// will be rejected.
struct AddServiceToEndpoint FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef AddServiceToEndpointT NativeTableType;
  typedef AddServiceToEndpointBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_ENDPOINT = 4,
    VT_SERVICE = 6
  };
  const chre::fbs::EndpointId *endpoint() const {
    return GetPointer<const chre::fbs::EndpointId *>(VT_ENDPOINT);
  }
  chre::fbs::EndpointId *mutable_endpoint() {
    return GetPointer<chre::fbs::EndpointId *>(VT_ENDPOINT);
  }
  const chre::fbs::Service *service() const {
    return GetPointer<const chre::fbs::Service *>(VT_SERVICE);
  }
  chre::fbs::Service *mutable_service() {
    return GetPointer<chre::fbs::Service *>(VT_SERVICE);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_ENDPOINT) &&
           verifier.VerifyTable(endpoint()) &&
           VerifyOffset(verifier, VT_SERVICE) &&
           verifier.VerifyTable(service()) &&
           verifier.EndTable();
  }
  AddServiceToEndpointT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(AddServiceToEndpointT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<AddServiceToEndpoint> Pack(flatbuffers::FlatBufferBuilder &_fbb, const AddServiceToEndpointT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct AddServiceToEndpointBuilder {
  typedef AddServiceToEndpoint Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_endpoint(flatbuffers::Offset<chre::fbs::EndpointId> endpoint) {
    fbb_.AddOffset(AddServiceToEndpoint::VT_ENDPOINT, endpoint);
  }
  void add_service(flatbuffers::Offset<chre::fbs::Service> service) {
    fbb_.AddOffset(AddServiceToEndpoint::VT_SERVICE, service);
  }
  explicit AddServiceToEndpointBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  AddServiceToEndpointBuilder &operator=(const AddServiceToEndpointBuilder &);
  flatbuffers::Offset<AddServiceToEndpoint> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<AddServiceToEndpoint>(end);
    return o;
  }
};

inline flatbuffers::Offset<AddServiceToEndpoint> CreateAddServiceToEndpoint(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<chre::fbs::EndpointId> endpoint = 0,
    flatbuffers::Offset<chre::fbs::Service> service = 0) {
  AddServiceToEndpointBuilder builder_(_fbb);
  builder_.add_service(service);
  builder_.add_endpoint(endpoint);
  return builder_.Finish();
}

flatbuffers::Offset<AddServiceToEndpoint> CreateAddServiceToEndpoint(flatbuffers::FlatBufferBuilder &_fbb, const AddServiceToEndpointT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct EndpointReadyT : public flatbuffers::NativeTable {
  typedef EndpointReady TableType;
  std::unique_ptr<chre::fbs::EndpointIdT> endpoint;
  EndpointReadyT() {
  }
};

struct EndpointReady FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef EndpointReadyT NativeTableType;
  typedef EndpointReadyBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_ENDPOINT = 4
  };
  const chre::fbs::EndpointId *endpoint() const {
    return GetPointer<const chre::fbs::EndpointId *>(VT_ENDPOINT);
  }
  chre::fbs::EndpointId *mutable_endpoint() {
    return GetPointer<chre::fbs::EndpointId *>(VT_ENDPOINT);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_ENDPOINT) &&
           verifier.VerifyTable(endpoint()) &&
           verifier.EndTable();
  }
  EndpointReadyT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(EndpointReadyT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<EndpointReady> Pack(flatbuffers::FlatBufferBuilder &_fbb, const EndpointReadyT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct EndpointReadyBuilder {
  typedef EndpointReady Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_endpoint(flatbuffers::Offset<chre::fbs::EndpointId> endpoint) {
    fbb_.AddOffset(EndpointReady::VT_ENDPOINT, endpoint);
  }
  explicit EndpointReadyBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  EndpointReadyBuilder &operator=(const EndpointReadyBuilder &);
  flatbuffers::Offset<EndpointReady> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<EndpointReady>(end);
    return o;
  }
};

inline flatbuffers::Offset<EndpointReady> CreateEndpointReady(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<chre::fbs::EndpointId> endpoint = 0) {
  EndpointReadyBuilder builder_(_fbb);
  builder_.add_endpoint(endpoint);
  return builder_.Finish();
}

flatbuffers::Offset<EndpointReady> CreateEndpointReady(flatbuffers::FlatBufferBuilder &_fbb, const EndpointReadyT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct UnregisterEndpointT : public flatbuffers::NativeTable {
  typedef UnregisterEndpoint TableType;
  std::unique_ptr<chre::fbs::EndpointIdT> endpoint;
  UnregisterEndpointT() {
  }
};

struct UnregisterEndpoint FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef UnregisterEndpointT NativeTableType;
  typedef UnregisterEndpointBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_ENDPOINT = 4
  };
  const chre::fbs::EndpointId *endpoint() const {
    return GetPointer<const chre::fbs::EndpointId *>(VT_ENDPOINT);
  }
  chre::fbs::EndpointId *mutable_endpoint() {
    return GetPointer<chre::fbs::EndpointId *>(VT_ENDPOINT);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_ENDPOINT) &&
           verifier.VerifyTable(endpoint()) &&
           verifier.EndTable();
  }
  UnregisterEndpointT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(UnregisterEndpointT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<UnregisterEndpoint> Pack(flatbuffers::FlatBufferBuilder &_fbb, const UnregisterEndpointT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct UnregisterEndpointBuilder {
  typedef UnregisterEndpoint Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_endpoint(flatbuffers::Offset<chre::fbs::EndpointId> endpoint) {
    fbb_.AddOffset(UnregisterEndpoint::VT_ENDPOINT, endpoint);
  }
  explicit UnregisterEndpointBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  UnregisterEndpointBuilder &operator=(const UnregisterEndpointBuilder &);
  flatbuffers::Offset<UnregisterEndpoint> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<UnregisterEndpoint>(end);
    return o;
  }
};

inline flatbuffers::Offset<UnregisterEndpoint> CreateUnregisterEndpoint(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<chre::fbs::EndpointId> endpoint = 0) {
  UnregisterEndpointBuilder builder_(_fbb);
  builder_.add_endpoint(endpoint);
  return builder_.Finish();
}

flatbuffers::Offset<UnregisterEndpoint> CreateUnregisterEndpoint(flatbuffers::FlatBufferBuilder &_fbb, const UnregisterEndpointT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct GetMessageHubsAndEndpointsRequestT : public flatbuffers::NativeTable {
  typedef GetMessageHubsAndEndpointsRequest TableType;
  GetMessageHubsAndEndpointsRequestT() {
  }
};

/// HAL->CHRE, indicates the HAL is coming up
struct GetMessageHubsAndEndpointsRequest FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef GetMessageHubsAndEndpointsRequestT NativeTableType;
  typedef GetMessageHubsAndEndpointsRequestBuilder Builder;
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           verifier.EndTable();
  }
  GetMessageHubsAndEndpointsRequestT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(GetMessageHubsAndEndpointsRequestT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<GetMessageHubsAndEndpointsRequest> Pack(flatbuffers::FlatBufferBuilder &_fbb, const GetMessageHubsAndEndpointsRequestT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct GetMessageHubsAndEndpointsRequestBuilder {
  typedef GetMessageHubsAndEndpointsRequest Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  explicit GetMessageHubsAndEndpointsRequestBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  GetMessageHubsAndEndpointsRequestBuilder &operator=(const GetMessageHubsAndEndpointsRequestBuilder &);
  flatbuffers::Offset<GetMessageHubsAndEndpointsRequest> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<GetMessageHubsAndEndpointsRequest>(end);
    return o;
  }
};

inline flatbuffers::Offset<GetMessageHubsAndEndpointsRequest> CreateGetMessageHubsAndEndpointsRequest(
    flatbuffers::FlatBufferBuilder &_fbb) {
  GetMessageHubsAndEndpointsRequestBuilder builder_(_fbb);
  return builder_.Finish();
}

flatbuffers::Offset<GetMessageHubsAndEndpointsRequest> CreateGetMessageHubsAndEndpointsRequest(flatbuffers::FlatBufferBuilder &_fbb, const GetMessageHubsAndEndpointsRequestT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct GetMessageHubsAndEndpointsResponseT : public flatbuffers::NativeTable {
  typedef GetMessageHubsAndEndpointsResponse TableType;
  std::vector<std::unique_ptr<chre::fbs::MessageHubT>> hubs;
  std::vector<std::unique_ptr<chre::fbs::EndpointInfoT>> endpoints;
  GetMessageHubsAndEndpointsResponseT() {
  }
};

struct GetMessageHubsAndEndpointsResponse FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef GetMessageHubsAndEndpointsResponseT NativeTableType;
  typedef GetMessageHubsAndEndpointsResponseBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_HUBS = 4,
    VT_ENDPOINTS = 6
  };
  const flatbuffers::Vector<flatbuffers::Offset<chre::fbs::MessageHub>> *hubs() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<chre::fbs::MessageHub>> *>(VT_HUBS);
  }
  flatbuffers::Vector<flatbuffers::Offset<chre::fbs::MessageHub>> *mutable_hubs() {
    return GetPointer<flatbuffers::Vector<flatbuffers::Offset<chre::fbs::MessageHub>> *>(VT_HUBS);
  }
  const flatbuffers::Vector<flatbuffers::Offset<chre::fbs::EndpointInfo>> *endpoints() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<chre::fbs::EndpointInfo>> *>(VT_ENDPOINTS);
  }
  flatbuffers::Vector<flatbuffers::Offset<chre::fbs::EndpointInfo>> *mutable_endpoints() {
    return GetPointer<flatbuffers::Vector<flatbuffers::Offset<chre::fbs::EndpointInfo>> *>(VT_ENDPOINTS);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_HUBS) &&
           verifier.VerifyVector(hubs()) &&
           verifier.VerifyVectorOfTables(hubs()) &&
           VerifyOffset(verifier, VT_ENDPOINTS) &&
           verifier.VerifyVector(endpoints()) &&
           verifier.VerifyVectorOfTables(endpoints()) &&
           verifier.EndTable();
  }
  GetMessageHubsAndEndpointsResponseT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(GetMessageHubsAndEndpointsResponseT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<GetMessageHubsAndEndpointsResponse> Pack(flatbuffers::FlatBufferBuilder &_fbb, const GetMessageHubsAndEndpointsResponseT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct GetMessageHubsAndEndpointsResponseBuilder {
  typedef GetMessageHubsAndEndpointsResponse Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_hubs(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<chre::fbs::MessageHub>>> hubs) {
    fbb_.AddOffset(GetMessageHubsAndEndpointsResponse::VT_HUBS, hubs);
  }
  void add_endpoints(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<chre::fbs::EndpointInfo>>> endpoints) {
    fbb_.AddOffset(GetMessageHubsAndEndpointsResponse::VT_ENDPOINTS, endpoints);
  }
  explicit GetMessageHubsAndEndpointsResponseBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  GetMessageHubsAndEndpointsResponseBuilder &operator=(const GetMessageHubsAndEndpointsResponseBuilder &);
  flatbuffers::Offset<GetMessageHubsAndEndpointsResponse> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<GetMessageHubsAndEndpointsResponse>(end);
    return o;
  }
};

inline flatbuffers::Offset<GetMessageHubsAndEndpointsResponse> CreateGetMessageHubsAndEndpointsResponse(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<chre::fbs::MessageHub>>> hubs = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<chre::fbs::EndpointInfo>>> endpoints = 0) {
  GetMessageHubsAndEndpointsResponseBuilder builder_(_fbb);
  builder_.add_endpoints(endpoints);
  builder_.add_hubs(hubs);
  return builder_.Finish();
}

inline flatbuffers::Offset<GetMessageHubsAndEndpointsResponse> CreateGetMessageHubsAndEndpointsResponseDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const std::vector<flatbuffers::Offset<chre::fbs::MessageHub>> *hubs = nullptr,
    const std::vector<flatbuffers::Offset<chre::fbs::EndpointInfo>> *endpoints = nullptr) {
  auto hubs__ = hubs ? _fbb.CreateVector<flatbuffers::Offset<chre::fbs::MessageHub>>(*hubs) : 0;
  auto endpoints__ = endpoints ? _fbb.CreateVector<flatbuffers::Offset<chre::fbs::EndpointInfo>>(*endpoints) : 0;
  return chre::fbs::CreateGetMessageHubsAndEndpointsResponse(
      _fbb,
      hubs__,
      endpoints__);
}

flatbuffers::Offset<GetMessageHubsAndEndpointsResponse> CreateGetMessageHubsAndEndpointsResponse(flatbuffers::FlatBufferBuilder &_fbb, const GetMessageHubsAndEndpointsResponseT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct OpenEndpointSessionRequestT : public flatbuffers::NativeTable {
  typedef OpenEndpointSessionRequest TableType;
  int64_t host_hub_id;
  uint16_t session_id;
  std::unique_ptr<chre::fbs::EndpointIdT> fromEndpoint;
  std::unique_ptr<chre::fbs::EndpointIdT> toEndpoint;
  std::vector<int8_t> serviceDescriptor;
  OpenEndpointSessionRequestT()
      : host_hub_id(0),
        session_id(0) {
  }
};

struct OpenEndpointSessionRequest FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef OpenEndpointSessionRequestT NativeTableType;
  typedef OpenEndpointSessionRequestBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_HOST_HUB_ID = 4,
    VT_SESSION_ID = 6,
    VT_FROMENDPOINT = 8,
    VT_TOENDPOINT = 10,
    VT_SERVICEDESCRIPTOR = 12
  };
  int64_t host_hub_id() const {
    return GetField<int64_t>(VT_HOST_HUB_ID, 0);
  }
  bool mutate_host_hub_id(int64_t _host_hub_id) {
    return SetField<int64_t>(VT_HOST_HUB_ID, _host_hub_id, 0);
  }
  uint16_t session_id() const {
    return GetField<uint16_t>(VT_SESSION_ID, 0);
  }
  bool mutate_session_id(uint16_t _session_id) {
    return SetField<uint16_t>(VT_SESSION_ID, _session_id, 0);
  }
  const chre::fbs::EndpointId *fromEndpoint() const {
    return GetPointer<const chre::fbs::EndpointId *>(VT_FROMENDPOINT);
  }
  chre::fbs::EndpointId *mutable_fromEndpoint() {
    return GetPointer<chre::fbs::EndpointId *>(VT_FROMENDPOINT);
  }
  const chre::fbs::EndpointId *toEndpoint() const {
    return GetPointer<const chre::fbs::EndpointId *>(VT_TOENDPOINT);
  }
  chre::fbs::EndpointId *mutable_toEndpoint() {
    return GetPointer<chre::fbs::EndpointId *>(VT_TOENDPOINT);
  }
  /// If present, describes the service definition used over the session
  const flatbuffers::Vector<int8_t> *serviceDescriptor() const {
    return GetPointer<const flatbuffers::Vector<int8_t> *>(VT_SERVICEDESCRIPTOR);
  }
  flatbuffers::Vector<int8_t> *mutable_serviceDescriptor() {
    return GetPointer<flatbuffers::Vector<int8_t> *>(VT_SERVICEDESCRIPTOR);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int64_t>(verifier, VT_HOST_HUB_ID) &&
           VerifyField<uint16_t>(verifier, VT_SESSION_ID) &&
           VerifyOffset(verifier, VT_FROMENDPOINT) &&
           verifier.VerifyTable(fromEndpoint()) &&
           VerifyOffset(verifier, VT_TOENDPOINT) &&
           verifier.VerifyTable(toEndpoint()) &&
           VerifyOffset(verifier, VT_SERVICEDESCRIPTOR) &&
           verifier.VerifyVector(serviceDescriptor()) &&
           verifier.EndTable();
  }
  OpenEndpointSessionRequestT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(OpenEndpointSessionRequestT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<OpenEndpointSessionRequest> Pack(flatbuffers::FlatBufferBuilder &_fbb, const OpenEndpointSessionRequestT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct OpenEndpointSessionRequestBuilder {
  typedef OpenEndpointSessionRequest Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_host_hub_id(int64_t host_hub_id) {
    fbb_.AddElement<int64_t>(OpenEndpointSessionRequest::VT_HOST_HUB_ID, host_hub_id, 0);
  }
  void add_session_id(uint16_t session_id) {
    fbb_.AddElement<uint16_t>(OpenEndpointSessionRequest::VT_SESSION_ID, session_id, 0);
  }
  void add_fromEndpoint(flatbuffers::Offset<chre::fbs::EndpointId> fromEndpoint) {
    fbb_.AddOffset(OpenEndpointSessionRequest::VT_FROMENDPOINT, fromEndpoint);
  }
  void add_toEndpoint(flatbuffers::Offset<chre::fbs::EndpointId> toEndpoint) {
    fbb_.AddOffset(OpenEndpointSessionRequest::VT_TOENDPOINT, toEndpoint);
  }
  void add_serviceDescriptor(flatbuffers::Offset<flatbuffers::Vector<int8_t>> serviceDescriptor) {
    fbb_.AddOffset(OpenEndpointSessionRequest::VT_SERVICEDESCRIPTOR, serviceDescriptor);
  }
  explicit OpenEndpointSessionRequestBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  OpenEndpointSessionRequestBuilder &operator=(const OpenEndpointSessionRequestBuilder &);
  flatbuffers::Offset<OpenEndpointSessionRequest> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<OpenEndpointSessionRequest>(end);
    return o;
  }
};

inline flatbuffers::Offset<OpenEndpointSessionRequest> CreateOpenEndpointSessionRequest(
    flatbuffers::FlatBufferBuilder &_fbb,
    int64_t host_hub_id = 0,
    uint16_t session_id = 0,
    flatbuffers::Offset<chre::fbs::EndpointId> fromEndpoint = 0,
    flatbuffers::Offset<chre::fbs::EndpointId> toEndpoint = 0,
    flatbuffers::Offset<flatbuffers::Vector<int8_t>> serviceDescriptor = 0) {
  OpenEndpointSessionRequestBuilder builder_(_fbb);
  builder_.add_host_hub_id(host_hub_id);
  builder_.add_serviceDescriptor(serviceDescriptor);
  builder_.add_toEndpoint(toEndpoint);
  builder_.add_fromEndpoint(fromEndpoint);
  builder_.add_session_id(session_id);
  return builder_.Finish();
}

inline flatbuffers::Offset<OpenEndpointSessionRequest> CreateOpenEndpointSessionRequestDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    int64_t host_hub_id = 0,
    uint16_t session_id = 0,
    flatbuffers::Offset<chre::fbs::EndpointId> fromEndpoint = 0,
    flatbuffers::Offset<chre::fbs::EndpointId> toEndpoint = 0,
    const std::vector<int8_t> *serviceDescriptor = nullptr) {
  auto serviceDescriptor__ = serviceDescriptor ? _fbb.CreateVector<int8_t>(*serviceDescriptor) : 0;
  return chre::fbs::CreateOpenEndpointSessionRequest(
      _fbb,
      host_hub_id,
      session_id,
      fromEndpoint,
      toEndpoint,
      serviceDescriptor__);
}

flatbuffers::Offset<OpenEndpointSessionRequest> CreateOpenEndpointSessionRequest(flatbuffers::FlatBufferBuilder &_fbb, const OpenEndpointSessionRequestT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct EndpointSessionOpenedT : public flatbuffers::NativeTable {
  typedef EndpointSessionOpened TableType;
  int64_t host_hub_id;
  uint16_t session_id;
  EndpointSessionOpenedT()
      : host_hub_id(0),
        session_id(0) {
  }
};

struct EndpointSessionOpened FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef EndpointSessionOpenedT NativeTableType;
  typedef EndpointSessionOpenedBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_HOST_HUB_ID = 4,
    VT_SESSION_ID = 6
  };
  int64_t host_hub_id() const {
    return GetField<int64_t>(VT_HOST_HUB_ID, 0);
  }
  bool mutate_host_hub_id(int64_t _host_hub_id) {
    return SetField<int64_t>(VT_HOST_HUB_ID, _host_hub_id, 0);
  }
  uint16_t session_id() const {
    return GetField<uint16_t>(VT_SESSION_ID, 0);
  }
  bool mutate_session_id(uint16_t _session_id) {
    return SetField<uint16_t>(VT_SESSION_ID, _session_id, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int64_t>(verifier, VT_HOST_HUB_ID) &&
           VerifyField<uint16_t>(verifier, VT_SESSION_ID) &&
           verifier.EndTable();
  }
  EndpointSessionOpenedT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(EndpointSessionOpenedT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<EndpointSessionOpened> Pack(flatbuffers::FlatBufferBuilder &_fbb, const EndpointSessionOpenedT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct EndpointSessionOpenedBuilder {
  typedef EndpointSessionOpened Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_host_hub_id(int64_t host_hub_id) {
    fbb_.AddElement<int64_t>(EndpointSessionOpened::VT_HOST_HUB_ID, host_hub_id, 0);
  }
  void add_session_id(uint16_t session_id) {
    fbb_.AddElement<uint16_t>(EndpointSessionOpened::VT_SESSION_ID, session_id, 0);
  }
  explicit EndpointSessionOpenedBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  EndpointSessionOpenedBuilder &operator=(const EndpointSessionOpenedBuilder &);
  flatbuffers::Offset<EndpointSessionOpened> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<EndpointSessionOpened>(end);
    return o;
  }
};

inline flatbuffers::Offset<EndpointSessionOpened> CreateEndpointSessionOpened(
    flatbuffers::FlatBufferBuilder &_fbb,
    int64_t host_hub_id = 0,
    uint16_t session_id = 0) {
  EndpointSessionOpenedBuilder builder_(_fbb);
  builder_.add_host_hub_id(host_hub_id);
  builder_.add_session_id(session_id);
  return builder_.Finish();
}

flatbuffers::Offset<EndpointSessionOpened> CreateEndpointSessionOpened(flatbuffers::FlatBufferBuilder &_fbb, const EndpointSessionOpenedT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct EndpointSessionClosedT : public flatbuffers::NativeTable {
  typedef EndpointSessionClosed TableType;
  int64_t host_hub_id;
  uint16_t session_id;
  chre::fbs::Reason reason;
  EndpointSessionClosedT()
      : host_hub_id(0),
        session_id(0),
        reason(chre::fbs::Reason::UNSPECIFIED) {
  }
};

struct EndpointSessionClosed FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef EndpointSessionClosedT NativeTableType;
  typedef EndpointSessionClosedBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_HOST_HUB_ID = 4,
    VT_SESSION_ID = 6,
    VT_REASON = 8
  };
  int64_t host_hub_id() const {
    return GetField<int64_t>(VT_HOST_HUB_ID, 0);
  }
  bool mutate_host_hub_id(int64_t _host_hub_id) {
    return SetField<int64_t>(VT_HOST_HUB_ID, _host_hub_id, 0);
  }
  uint16_t session_id() const {
    return GetField<uint16_t>(VT_SESSION_ID, 0);
  }
  bool mutate_session_id(uint16_t _session_id) {
    return SetField<uint16_t>(VT_SESSION_ID, _session_id, 0);
  }
  chre::fbs::Reason reason() const {
    return static_cast<chre::fbs::Reason>(GetField<uint8_t>(VT_REASON, 0));
  }
  bool mutate_reason(chre::fbs::Reason _reason) {
    return SetField<uint8_t>(VT_REASON, static_cast<uint8_t>(_reason), 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int64_t>(verifier, VT_HOST_HUB_ID) &&
           VerifyField<uint16_t>(verifier, VT_SESSION_ID) &&
           VerifyField<uint8_t>(verifier, VT_REASON) &&
           verifier.EndTable();
  }
  EndpointSessionClosedT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(EndpointSessionClosedT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<EndpointSessionClosed> Pack(flatbuffers::FlatBufferBuilder &_fbb, const EndpointSessionClosedT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct EndpointSessionClosedBuilder {
  typedef EndpointSessionClosed Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_host_hub_id(int64_t host_hub_id) {
    fbb_.AddElement<int64_t>(EndpointSessionClosed::VT_HOST_HUB_ID, host_hub_id, 0);
  }
  void add_session_id(uint16_t session_id) {
    fbb_.AddElement<uint16_t>(EndpointSessionClosed::VT_SESSION_ID, session_id, 0);
  }
  void add_reason(chre::fbs::Reason reason) {
    fbb_.AddElement<uint8_t>(EndpointSessionClosed::VT_REASON, static_cast<uint8_t>(reason), 0);
  }
  explicit EndpointSessionClosedBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  EndpointSessionClosedBuilder &operator=(const EndpointSessionClosedBuilder &);
  flatbuffers::Offset<EndpointSessionClosed> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<EndpointSessionClosed>(end);
    return o;
  }
};

inline flatbuffers::Offset<EndpointSessionClosed> CreateEndpointSessionClosed(
    flatbuffers::FlatBufferBuilder &_fbb,
    int64_t host_hub_id = 0,
    uint16_t session_id = 0,
    chre::fbs::Reason reason = chre::fbs::Reason::UNSPECIFIED) {
  EndpointSessionClosedBuilder builder_(_fbb);
  builder_.add_host_hub_id(host_hub_id);
  builder_.add_session_id(session_id);
  builder_.add_reason(reason);
  return builder_.Finish();
}

flatbuffers::Offset<EndpointSessionClosed> CreateEndpointSessionClosed(flatbuffers::FlatBufferBuilder &_fbb, const EndpointSessionClosedT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct EndpointSessionMessageT : public flatbuffers::NativeTable {
  typedef EndpointSessionMessage TableType;
  int64_t host_hub_id;
  uint16_t session_id;
  uint32_t type;
  uint32_t permissions;
  std::vector<uint8_t> data;
  uint32_t flags;
  uint32_t sequence_number;
  EndpointSessionMessageT()
      : host_hub_id(0),
        session_id(0),
        type(0),
        permissions(0),
        flags(0),
        sequence_number(0) {
  }
};

struct EndpointSessionMessage FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef EndpointSessionMessageT NativeTableType;
  typedef EndpointSessionMessageBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_HOST_HUB_ID = 4,
    VT_SESSION_ID = 6,
    VT_TYPE = 8,
    VT_PERMISSIONS = 10,
    VT_DATA = 12,
    VT_FLAGS = 14,
    VT_SEQUENCE_NUMBER = 16
  };
  int64_t host_hub_id() const {
    return GetField<int64_t>(VT_HOST_HUB_ID, 0);
  }
  bool mutate_host_hub_id(int64_t _host_hub_id) {
    return SetField<int64_t>(VT_HOST_HUB_ID, _host_hub_id, 0);
  }
  /// Id of session this message is being sent within
  uint16_t session_id() const {
    return GetField<uint16_t>(VT_SESSION_ID, 0);
  }
  bool mutate_session_id(uint16_t _session_id) {
    return SetField<uint16_t>(VT_SESSION_ID, _session_id, 0);
  }
  /// Type of the message, specific to the Session protocol
  uint32_t type() const {
    return GetField<uint32_t>(VT_TYPE, 0);
  }
  bool mutate_type(uint32_t _type) {
    return SetField<uint32_t>(VT_TYPE, _type, 0);
  }
  /// Values from CHRE_MESSAGE_PERMISSION_*. Permissions required to read the
  /// message.
  uint32_t permissions() const {
    return GetField<uint32_t>(VT_PERMISSIONS, 0);
  }
  bool mutate_permissions(uint32_t _permissions) {
    return SetField<uint32_t>(VT_PERMISSIONS, _permissions, 0);
  }
  const flatbuffers::Vector<uint8_t> *data() const {
    return GetPointer<const flatbuffers::Vector<uint8_t> *>(VT_DATA);
  }
  flatbuffers::Vector<uint8_t> *mutable_data() {
    return GetPointer<flatbuffers::Vector<uint8_t> *>(VT_DATA);
  }
  /// Bitmask of additional flags applied to the message:
  /// - 0x1: Message delivery status required within 1s
  uint32_t flags() const {
    return GetField<uint32_t>(VT_FLAGS, 0);
  }
  bool mutate_flags(uint32_t _flags) {
    return SetField<uint32_t>(VT_FLAGS, _flags, 0);
  }
  uint32_t sequence_number() const {
    return GetField<uint32_t>(VT_SEQUENCE_NUMBER, 0);
  }
  bool mutate_sequence_number(uint32_t _sequence_number) {
    return SetField<uint32_t>(VT_SEQUENCE_NUMBER, _sequence_number, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int64_t>(verifier, VT_HOST_HUB_ID) &&
           VerifyField<uint16_t>(verifier, VT_SESSION_ID) &&
           VerifyField<uint32_t>(verifier, VT_TYPE) &&
           VerifyField<uint32_t>(verifier, VT_PERMISSIONS) &&
           VerifyOffset(verifier, VT_DATA) &&
           verifier.VerifyVector(data()) &&
           VerifyField<uint32_t>(verifier, VT_FLAGS) &&
           VerifyField<uint32_t>(verifier, VT_SEQUENCE_NUMBER) &&
           verifier.EndTable();
  }
  EndpointSessionMessageT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(EndpointSessionMessageT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<EndpointSessionMessage> Pack(flatbuffers::FlatBufferBuilder &_fbb, const EndpointSessionMessageT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct EndpointSessionMessageBuilder {
  typedef EndpointSessionMessage Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_host_hub_id(int64_t host_hub_id) {
    fbb_.AddElement<int64_t>(EndpointSessionMessage::VT_HOST_HUB_ID, host_hub_id, 0);
  }
  void add_session_id(uint16_t session_id) {
    fbb_.AddElement<uint16_t>(EndpointSessionMessage::VT_SESSION_ID, session_id, 0);
  }
  void add_type(uint32_t type) {
    fbb_.AddElement<uint32_t>(EndpointSessionMessage::VT_TYPE, type, 0);
  }
  void add_permissions(uint32_t permissions) {
    fbb_.AddElement<uint32_t>(EndpointSessionMessage::VT_PERMISSIONS, permissions, 0);
  }
  void add_data(flatbuffers::Offset<flatbuffers::Vector<uint8_t>> data) {
    fbb_.AddOffset(EndpointSessionMessage::VT_DATA, data);
  }
  void add_flags(uint32_t flags) {
    fbb_.AddElement<uint32_t>(EndpointSessionMessage::VT_FLAGS, flags, 0);
  }
  void add_sequence_number(uint32_t sequence_number) {
    fbb_.AddElement<uint32_t>(EndpointSessionMessage::VT_SEQUENCE_NUMBER, sequence_number, 0);
  }
  explicit EndpointSessionMessageBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  EndpointSessionMessageBuilder &operator=(const EndpointSessionMessageBuilder &);
  flatbuffers::Offset<EndpointSessionMessage> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<EndpointSessionMessage>(end);
    return o;
  }
};

inline flatbuffers::Offset<EndpointSessionMessage> CreateEndpointSessionMessage(
    flatbuffers::FlatBufferBuilder &_fbb,
    int64_t host_hub_id = 0,
    uint16_t session_id = 0,
    uint32_t type = 0,
    uint32_t permissions = 0,
    flatbuffers::Offset<flatbuffers::Vector<uint8_t>> data = 0,
    uint32_t flags = 0,
    uint32_t sequence_number = 0) {
  EndpointSessionMessageBuilder builder_(_fbb);
  builder_.add_host_hub_id(host_hub_id);
  builder_.add_sequence_number(sequence_number);
  builder_.add_flags(flags);
  builder_.add_data(data);
  builder_.add_permissions(permissions);
  builder_.add_type(type);
  builder_.add_session_id(session_id);
  return builder_.Finish();
}

inline flatbuffers::Offset<EndpointSessionMessage> CreateEndpointSessionMessageDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    int64_t host_hub_id = 0,
    uint16_t session_id = 0,
    uint32_t type = 0,
    uint32_t permissions = 0,
    const std::vector<uint8_t> *data = nullptr,
    uint32_t flags = 0,
    uint32_t sequence_number = 0) {
  auto data__ = data ? _fbb.CreateVector<uint8_t>(*data) : 0;
  return chre::fbs::CreateEndpointSessionMessage(
      _fbb,
      host_hub_id,
      session_id,
      type,
      permissions,
      data__,
      flags,
      sequence_number);
}

flatbuffers::Offset<EndpointSessionMessage> CreateEndpointSessionMessage(flatbuffers::FlatBufferBuilder &_fbb, const EndpointSessionMessageT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct EndpointSessionMessageDeliveryStatusT : public flatbuffers::NativeTable {
  typedef EndpointSessionMessageDeliveryStatus TableType;
  int64_t host_hub_id;
  uint16_t session_id;
  std::unique_ptr<chre::fbs::MessageDeliveryStatusT> status;
  EndpointSessionMessageDeliveryStatusT()
      : host_hub_id(0),
        session_id(0) {
  }
};

struct EndpointSessionMessageDeliveryStatus FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef EndpointSessionMessageDeliveryStatusT NativeTableType;
  typedef EndpointSessionMessageDeliveryStatusBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_HOST_HUB_ID = 4,
    VT_SESSION_ID = 6,
    VT_STATUS = 8
  };
  int64_t host_hub_id() const {
    return GetField<int64_t>(VT_HOST_HUB_ID, 0);
  }
  bool mutate_host_hub_id(int64_t _host_hub_id) {
    return SetField<int64_t>(VT_HOST_HUB_ID, _host_hub_id, 0);
  }
  /// Id of session the message was sent within
  uint16_t session_id() const {
    return GetField<uint16_t>(VT_SESSION_ID, 0);
  }
  bool mutate_session_id(uint16_t _session_id) {
    return SetField<uint16_t>(VT_SESSION_ID, _session_id, 0);
  }
  const chre::fbs::MessageDeliveryStatus *status() const {
    return GetPointer<const chre::fbs::MessageDeliveryStatus *>(VT_STATUS);
  }
  chre::fbs::MessageDeliveryStatus *mutable_status() {
    return GetPointer<chre::fbs::MessageDeliveryStatus *>(VT_STATUS);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int64_t>(verifier, VT_HOST_HUB_ID) &&
           VerifyField<uint16_t>(verifier, VT_SESSION_ID) &&
           VerifyOffset(verifier, VT_STATUS) &&
           verifier.VerifyTable(status()) &&
           verifier.EndTable();
  }
  EndpointSessionMessageDeliveryStatusT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(EndpointSessionMessageDeliveryStatusT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<EndpointSessionMessageDeliveryStatus> Pack(flatbuffers::FlatBufferBuilder &_fbb, const EndpointSessionMessageDeliveryStatusT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct EndpointSessionMessageDeliveryStatusBuilder {
  typedef EndpointSessionMessageDeliveryStatus Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_host_hub_id(int64_t host_hub_id) {
    fbb_.AddElement<int64_t>(EndpointSessionMessageDeliveryStatus::VT_HOST_HUB_ID, host_hub_id, 0);
  }
  void add_session_id(uint16_t session_id) {
    fbb_.AddElement<uint16_t>(EndpointSessionMessageDeliveryStatus::VT_SESSION_ID, session_id, 0);
  }
  void add_status(flatbuffers::Offset<chre::fbs::MessageDeliveryStatus> status) {
    fbb_.AddOffset(EndpointSessionMessageDeliveryStatus::VT_STATUS, status);
  }
  explicit EndpointSessionMessageDeliveryStatusBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  EndpointSessionMessageDeliveryStatusBuilder &operator=(const EndpointSessionMessageDeliveryStatusBuilder &);
  flatbuffers::Offset<EndpointSessionMessageDeliveryStatus> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<EndpointSessionMessageDeliveryStatus>(end);
    return o;
  }
};

inline flatbuffers::Offset<EndpointSessionMessageDeliveryStatus> CreateEndpointSessionMessageDeliveryStatus(
    flatbuffers::FlatBufferBuilder &_fbb,
    int64_t host_hub_id = 0,
    uint16_t session_id = 0,
    flatbuffers::Offset<chre::fbs::MessageDeliveryStatus> status = 0) {
  EndpointSessionMessageDeliveryStatusBuilder builder_(_fbb);
  builder_.add_host_hub_id(host_hub_id);
  builder_.add_status(status);
  builder_.add_session_id(session_id);
  return builder_.Finish();
}

flatbuffers::Offset<EndpointSessionMessageDeliveryStatus> CreateEndpointSessionMessageDeliveryStatus(flatbuffers::FlatBufferBuilder &_fbb, const EndpointSessionMessageDeliveryStatusT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct MessageContainerT : public flatbuffers::NativeTable {
  typedef MessageContainer TableType;
  chre::fbs::ChreMessageUnion message;
  std::unique_ptr<chre::fbs::HostAddress> host_addr;
  MessageContainerT() {
  }
};

/// The top-level container that encapsulates all possible messages. Note that
/// per FlatBuffers requirements, we can't use a union as the top-level
/// structure (root type), so we must wrap it in a table.
struct MessageContainer FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef MessageContainerT NativeTableType;
  typedef MessageContainerBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_MESSAGE_TYPE = 4,
    VT_MESSAGE = 6,
    VT_HOST_ADDR = 8
  };
  chre::fbs::ChreMessage message_type() const {
    return static_cast<chre::fbs::ChreMessage>(GetField<uint8_t>(VT_MESSAGE_TYPE, 0));
  }
  const void *message() const {
    return GetPointer<const void *>(VT_MESSAGE);
  }
  template<typename T> const T *message_as() const;
  const chre::fbs::NanoappMessage *message_as_NanoappMessage() const {
    return message_type() == chre::fbs::ChreMessage::NanoappMessage ? static_cast<const chre::fbs::NanoappMessage *>(message()) : nullptr;
  }
  const chre::fbs::HubInfoRequest *message_as_HubInfoRequest() const {
    return message_type() == chre::fbs::ChreMessage::HubInfoRequest ? static_cast<const chre::fbs::HubInfoRequest *>(message()) : nullptr;
  }
  const chre::fbs::HubInfoResponse *message_as_HubInfoResponse() const {
    return message_type() == chre::fbs::ChreMessage::HubInfoResponse ? static_cast<const chre::fbs::HubInfoResponse *>(message()) : nullptr;
  }
  const chre::fbs::NanoappListRequest *message_as_NanoappListRequest() const {
    return message_type() == chre::fbs::ChreMessage::NanoappListRequest ? static_cast<const chre::fbs::NanoappListRequest *>(message()) : nullptr;
  }
  const chre::fbs::NanoappListResponse *message_as_NanoappListResponse() const {
    return message_type() == chre::fbs::ChreMessage::NanoappListResponse ? static_cast<const chre::fbs::NanoappListResponse *>(message()) : nullptr;
  }
  const chre::fbs::LoadNanoappRequest *message_as_LoadNanoappRequest() const {
    return message_type() == chre::fbs::ChreMessage::LoadNanoappRequest ? static_cast<const chre::fbs::LoadNanoappRequest *>(message()) : nullptr;
  }
  const chre::fbs::LoadNanoappResponse *message_as_LoadNanoappResponse() const {
    return message_type() == chre::fbs::ChreMessage::LoadNanoappResponse ? static_cast<const chre::fbs::LoadNanoappResponse *>(message()) : nullptr;
  }
  const chre::fbs::UnloadNanoappRequest *message_as_UnloadNanoappRequest() const {
    return message_type() == chre::fbs::ChreMessage::UnloadNanoappRequest ? static_cast<const chre::fbs::UnloadNanoappRequest *>(message()) : nullptr;
  }
  const chre::fbs::UnloadNanoappResponse *message_as_UnloadNanoappResponse() const {
    return message_type() == chre::fbs::ChreMessage::UnloadNanoappResponse ? static_cast<const chre::fbs::UnloadNanoappResponse *>(message()) : nullptr;
  }
  const chre::fbs::LogMessage *message_as_LogMessage() const {
    return message_type() == chre::fbs::ChreMessage::LogMessage ? static_cast<const chre::fbs::LogMessage *>(message()) : nullptr;
  }
  const chre::fbs::TimeSyncMessage *message_as_TimeSyncMessage() const {
    return message_type() == chre::fbs::ChreMessage::TimeSyncMessage ? static_cast<const chre::fbs::TimeSyncMessage *>(message()) : nullptr;
  }
  const chre::fbs::DebugDumpRequest *message_as_DebugDumpRequest() const {
    return message_type() == chre::fbs::ChreMessage::DebugDumpRequest ? static_cast<const chre::fbs::DebugDumpRequest *>(message()) : nullptr;
  }
  const chre::fbs::DebugDumpData *message_as_DebugDumpData() const {
    return message_type() == chre::fbs::ChreMessage::DebugDumpData ? static_cast<const chre::fbs::DebugDumpData *>(message()) : nullptr;
  }
  const chre::fbs::DebugDumpResponse *message_as_DebugDumpResponse() const {
    return message_type() == chre::fbs::ChreMessage::DebugDumpResponse ? static_cast<const chre::fbs::DebugDumpResponse *>(message()) : nullptr;
  }
  const chre::fbs::TimeSyncRequest *message_as_TimeSyncRequest() const {
    return message_type() == chre::fbs::ChreMessage::TimeSyncRequest ? static_cast<const chre::fbs::TimeSyncRequest *>(message()) : nullptr;
  }
  const chre::fbs::LowPowerMicAccessRequest *message_as_LowPowerMicAccessRequest() const {
    return message_type() == chre::fbs::ChreMessage::LowPowerMicAccessRequest ? static_cast<const chre::fbs::LowPowerMicAccessRequest *>(message()) : nullptr;
  }
  const chre::fbs::LowPowerMicAccessRelease *message_as_LowPowerMicAccessRelease() const {
    return message_type() == chre::fbs::ChreMessage::LowPowerMicAccessRelease ? static_cast<const chre::fbs::LowPowerMicAccessRelease *>(message()) : nullptr;
  }
  const chre::fbs::SettingChangeMessage *message_as_SettingChangeMessage() const {
    return message_type() == chre::fbs::ChreMessage::SettingChangeMessage ? static_cast<const chre::fbs::SettingChangeMessage *>(message()) : nullptr;
  }
  const chre::fbs::LogMessageV2 *message_as_LogMessageV2() const {
    return message_type() == chre::fbs::ChreMessage::LogMessageV2 ? static_cast<const chre::fbs::LogMessageV2 *>(message()) : nullptr;
  }
  const chre::fbs::SelfTestRequest *message_as_SelfTestRequest() const {
    return message_type() == chre::fbs::ChreMessage::SelfTestRequest ? static_cast<const chre::fbs::SelfTestRequest *>(message()) : nullptr;
  }
  const chre::fbs::SelfTestResponse *message_as_SelfTestResponse() const {
    return message_type() == chre::fbs::ChreMessage::SelfTestResponse ? static_cast<const chre::fbs::SelfTestResponse *>(message()) : nullptr;
  }
  const chre::fbs::HostEndpointConnected *message_as_HostEndpointConnected() const {
    return message_type() == chre::fbs::ChreMessage::HostEndpointConnected ? static_cast<const chre::fbs::HostEndpointConnected *>(message()) : nullptr;
  }
  const chre::fbs::HostEndpointDisconnected *message_as_HostEndpointDisconnected() const {
    return message_type() == chre::fbs::ChreMessage::HostEndpointDisconnected ? static_cast<const chre::fbs::HostEndpointDisconnected *>(message()) : nullptr;
  }
  const chre::fbs::MetricLog *message_as_MetricLog() const {
    return message_type() == chre::fbs::ChreMessage::MetricLog ? static_cast<const chre::fbs::MetricLog *>(message()) : nullptr;
  }
  const chre::fbs::BatchedMetricLog *message_as_BatchedMetricLog() const {
    return message_type() == chre::fbs::ChreMessage::BatchedMetricLog ? static_cast<const chre::fbs::BatchedMetricLog *>(message()) : nullptr;
  }
  const chre::fbs::NanConfigurationRequest *message_as_NanConfigurationRequest() const {
    return message_type() == chre::fbs::ChreMessage::NanConfigurationRequest ? static_cast<const chre::fbs::NanConfigurationRequest *>(message()) : nullptr;
  }
  const chre::fbs::NanConfigurationUpdate *message_as_NanConfigurationUpdate() const {
    return message_type() == chre::fbs::ChreMessage::NanConfigurationUpdate ? static_cast<const chre::fbs::NanConfigurationUpdate *>(message()) : nullptr;
  }
  const chre::fbs::DebugConfiguration *message_as_DebugConfiguration() const {
    return message_type() == chre::fbs::ChreMessage::DebugConfiguration ? static_cast<const chre::fbs::DebugConfiguration *>(message()) : nullptr;
  }
  const chre::fbs::PulseRequest *message_as_PulseRequest() const {
    return message_type() == chre::fbs::ChreMessage::PulseRequest ? static_cast<const chre::fbs::PulseRequest *>(message()) : nullptr;
  }
  const chre::fbs::PulseResponse *message_as_PulseResponse() const {
    return message_type() == chre::fbs::ChreMessage::PulseResponse ? static_cast<const chre::fbs::PulseResponse *>(message()) : nullptr;
  }
  const chre::fbs::NanoappTokenDatabaseInfo *message_as_NanoappTokenDatabaseInfo() const {
    return message_type() == chre::fbs::ChreMessage::NanoappTokenDatabaseInfo ? static_cast<const chre::fbs::NanoappTokenDatabaseInfo *>(message()) : nullptr;
  }
  const chre::fbs::MessageDeliveryStatus *message_as_MessageDeliveryStatus() const {
    return message_type() == chre::fbs::ChreMessage::MessageDeliveryStatus ? static_cast<const chre::fbs::MessageDeliveryStatus *>(message()) : nullptr;
  }
  const chre::fbs::BtSocketOpen *message_as_BtSocketOpen() const {
    return message_type() == chre::fbs::ChreMessage::BtSocketOpen ? static_cast<const chre::fbs::BtSocketOpen *>(message()) : nullptr;
  }
  const chre::fbs::BtSocketOpenResponse *message_as_BtSocketOpenResponse() const {
    return message_type() == chre::fbs::ChreMessage::BtSocketOpenResponse ? static_cast<const chre::fbs::BtSocketOpenResponse *>(message()) : nullptr;
  }
  const chre::fbs::BtSocketClose *message_as_BtSocketClose() const {
    return message_type() == chre::fbs::ChreMessage::BtSocketClose ? static_cast<const chre::fbs::BtSocketClose *>(message()) : nullptr;
  }
  const chre::fbs::BtSocketCloseResponse *message_as_BtSocketCloseResponse() const {
    return message_type() == chre::fbs::ChreMessage::BtSocketCloseResponse ? static_cast<const chre::fbs::BtSocketCloseResponse *>(message()) : nullptr;
  }
  const chre::fbs::GetMessageHubsAndEndpointsRequest *message_as_GetMessageHubsAndEndpointsRequest() const {
    return message_type() == chre::fbs::ChreMessage::GetMessageHubsAndEndpointsRequest ? static_cast<const chre::fbs::GetMessageHubsAndEndpointsRequest *>(message()) : nullptr;
  }
  const chre::fbs::GetMessageHubsAndEndpointsResponse *message_as_GetMessageHubsAndEndpointsResponse() const {
    return message_type() == chre::fbs::ChreMessage::GetMessageHubsAndEndpointsResponse ? static_cast<const chre::fbs::GetMessageHubsAndEndpointsResponse *>(message()) : nullptr;
  }
  const chre::fbs::RegisterMessageHub *message_as_RegisterMessageHub() const {
    return message_type() == chre::fbs::ChreMessage::RegisterMessageHub ? static_cast<const chre::fbs::RegisterMessageHub *>(message()) : nullptr;
  }
  const chre::fbs::UnregisterMessageHub *message_as_UnregisterMessageHub() const {
    return message_type() == chre::fbs::ChreMessage::UnregisterMessageHub ? static_cast<const chre::fbs::UnregisterMessageHub *>(message()) : nullptr;
  }
  const chre::fbs::RegisterEndpoint *message_as_RegisterEndpoint() const {
    return message_type() == chre::fbs::ChreMessage::RegisterEndpoint ? static_cast<const chre::fbs::RegisterEndpoint *>(message()) : nullptr;
  }
  const chre::fbs::UnregisterEndpoint *message_as_UnregisterEndpoint() const {
    return message_type() == chre::fbs::ChreMessage::UnregisterEndpoint ? static_cast<const chre::fbs::UnregisterEndpoint *>(message()) : nullptr;
  }
  const chre::fbs::OpenEndpointSessionRequest *message_as_OpenEndpointSessionRequest() const {
    return message_type() == chre::fbs::ChreMessage::OpenEndpointSessionRequest ? static_cast<const chre::fbs::OpenEndpointSessionRequest *>(message()) : nullptr;
  }
  const chre::fbs::EndpointSessionOpened *message_as_EndpointSessionOpened() const {
    return message_type() == chre::fbs::ChreMessage::EndpointSessionOpened ? static_cast<const chre::fbs::EndpointSessionOpened *>(message()) : nullptr;
  }
  const chre::fbs::EndpointSessionClosed *message_as_EndpointSessionClosed() const {
    return message_type() == chre::fbs::ChreMessage::EndpointSessionClosed ? static_cast<const chre::fbs::EndpointSessionClosed *>(message()) : nullptr;
  }
  const chre::fbs::EndpointSessionMessage *message_as_EndpointSessionMessage() const {
    return message_type() == chre::fbs::ChreMessage::EndpointSessionMessage ? static_cast<const chre::fbs::EndpointSessionMessage *>(message()) : nullptr;
  }
  const chre::fbs::EndpointSessionMessageDeliveryStatus *message_as_EndpointSessionMessageDeliveryStatus() const {
    return message_type() == chre::fbs::ChreMessage::EndpointSessionMessageDeliveryStatus ? static_cast<const chre::fbs::EndpointSessionMessageDeliveryStatus *>(message()) : nullptr;
  }
  const chre::fbs::BtSocketCapabilitiesRequest *message_as_BtSocketCapabilitiesRequest() const {
    return message_type() == chre::fbs::ChreMessage::BtSocketCapabilitiesRequest ? static_cast<const chre::fbs::BtSocketCapabilitiesRequest *>(message()) : nullptr;
  }
  const chre::fbs::BtSocketCapabilitiesResponse *message_as_BtSocketCapabilitiesResponse() const {
    return message_type() == chre::fbs::ChreMessage::BtSocketCapabilitiesResponse ? static_cast<const chre::fbs::BtSocketCapabilitiesResponse *>(message()) : nullptr;
  }
  const chre::fbs::AddServiceToEndpoint *message_as_AddServiceToEndpoint() const {
    return message_type() == chre::fbs::ChreMessage::AddServiceToEndpoint ? static_cast<const chre::fbs::AddServiceToEndpoint *>(message()) : nullptr;
  }
  const chre::fbs::EndpointReady *message_as_EndpointReady() const {
    return message_type() == chre::fbs::ChreMessage::EndpointReady ? static_cast<const chre::fbs::EndpointReady *>(message()) : nullptr;
  }
  void *mutable_message() {
    return GetPointer<void *>(VT_MESSAGE);
  }
  /// The originating or destination client ID on the host side, used to direct
  /// responses only to the client that sent the request. Although initially
  /// populated by the requesting client, this is enforced to be the correct
  /// value by the entity guarding access to CHRE.
  /// This is wrapped in a struct to ensure that it is always included when
  /// encoding the message, so it can be mutated by the host daemon.
  const chre::fbs::HostAddress *host_addr() const {
    return GetStruct<const chre::fbs::HostAddress *>(VT_HOST_ADDR);
  }
  chre::fbs::HostAddress *mutable_host_addr() {
    return GetStruct<chre::fbs::HostAddress *>(VT_HOST_ADDR);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint8_t>(verifier, VT_MESSAGE_TYPE) &&
           VerifyOffsetRequired(verifier, VT_MESSAGE) &&
           VerifyChreMessage(verifier, message(), message_type()) &&
           VerifyFieldRequired<chre::fbs::HostAddress>(verifier, VT_HOST_ADDR) &&
           verifier.EndTable();
  }
  MessageContainerT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(MessageContainerT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<MessageContainer> Pack(flatbuffers::FlatBufferBuilder &_fbb, const MessageContainerT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

template<> inline const chre::fbs::NanoappMessage *MessageContainer::message_as<chre::fbs::NanoappMessage>() const {
  return message_as_NanoappMessage();
}

template<> inline const chre::fbs::HubInfoRequest *MessageContainer::message_as<chre::fbs::HubInfoRequest>() const {
  return message_as_HubInfoRequest();
}

template<> inline const chre::fbs::HubInfoResponse *MessageContainer::message_as<chre::fbs::HubInfoResponse>() const {
  return message_as_HubInfoResponse();
}

template<> inline const chre::fbs::NanoappListRequest *MessageContainer::message_as<chre::fbs::NanoappListRequest>() const {
  return message_as_NanoappListRequest();
}

template<> inline const chre::fbs::NanoappListResponse *MessageContainer::message_as<chre::fbs::NanoappListResponse>() const {
  return message_as_NanoappListResponse();
}

template<> inline const chre::fbs::LoadNanoappRequest *MessageContainer::message_as<chre::fbs::LoadNanoappRequest>() const {
  return message_as_LoadNanoappRequest();
}

template<> inline const chre::fbs::LoadNanoappResponse *MessageContainer::message_as<chre::fbs::LoadNanoappResponse>() const {
  return message_as_LoadNanoappResponse();
}

template<> inline const chre::fbs::UnloadNanoappRequest *MessageContainer::message_as<chre::fbs::UnloadNanoappRequest>() const {
  return message_as_UnloadNanoappRequest();
}

template<> inline const chre::fbs::UnloadNanoappResponse *MessageContainer::message_as<chre::fbs::UnloadNanoappResponse>() const {
  return message_as_UnloadNanoappResponse();
}

template<> inline const chre::fbs::LogMessage *MessageContainer::message_as<chre::fbs::LogMessage>() const {
  return message_as_LogMessage();
}

template<> inline const chre::fbs::TimeSyncMessage *MessageContainer::message_as<chre::fbs::TimeSyncMessage>() const {
  return message_as_TimeSyncMessage();
}

template<> inline const chre::fbs::DebugDumpRequest *MessageContainer::message_as<chre::fbs::DebugDumpRequest>() const {
  return message_as_DebugDumpRequest();
}

template<> inline const chre::fbs::DebugDumpData *MessageContainer::message_as<chre::fbs::DebugDumpData>() const {
  return message_as_DebugDumpData();
}

template<> inline const chre::fbs::DebugDumpResponse *MessageContainer::message_as<chre::fbs::DebugDumpResponse>() const {
  return message_as_DebugDumpResponse();
}

template<> inline const chre::fbs::TimeSyncRequest *MessageContainer::message_as<chre::fbs::TimeSyncRequest>() const {
  return message_as_TimeSyncRequest();
}

template<> inline const chre::fbs::LowPowerMicAccessRequest *MessageContainer::message_as<chre::fbs::LowPowerMicAccessRequest>() const {
  return message_as_LowPowerMicAccessRequest();
}

template<> inline const chre::fbs::LowPowerMicAccessRelease *MessageContainer::message_as<chre::fbs::LowPowerMicAccessRelease>() const {
  return message_as_LowPowerMicAccessRelease();
}

template<> inline const chre::fbs::SettingChangeMessage *MessageContainer::message_as<chre::fbs::SettingChangeMessage>() const {
  return message_as_SettingChangeMessage();
}

template<> inline const chre::fbs::LogMessageV2 *MessageContainer::message_as<chre::fbs::LogMessageV2>() const {
  return message_as_LogMessageV2();
}

template<> inline const chre::fbs::SelfTestRequest *MessageContainer::message_as<chre::fbs::SelfTestRequest>() const {
  return message_as_SelfTestRequest();
}

template<> inline const chre::fbs::SelfTestResponse *MessageContainer::message_as<chre::fbs::SelfTestResponse>() const {
  return message_as_SelfTestResponse();
}

template<> inline const chre::fbs::HostEndpointConnected *MessageContainer::message_as<chre::fbs::HostEndpointConnected>() const {
  return message_as_HostEndpointConnected();
}

template<> inline const chre::fbs::HostEndpointDisconnected *MessageContainer::message_as<chre::fbs::HostEndpointDisconnected>() const {
  return message_as_HostEndpointDisconnected();
}

template<> inline const chre::fbs::MetricLog *MessageContainer::message_as<chre::fbs::MetricLog>() const {
  return message_as_MetricLog();
}

template<> inline const chre::fbs::BatchedMetricLog *MessageContainer::message_as<chre::fbs::BatchedMetricLog>() const {
  return message_as_BatchedMetricLog();
}

template<> inline const chre::fbs::NanConfigurationRequest *MessageContainer::message_as<chre::fbs::NanConfigurationRequest>() const {
  return message_as_NanConfigurationRequest();
}

template<> inline const chre::fbs::NanConfigurationUpdate *MessageContainer::message_as<chre::fbs::NanConfigurationUpdate>() const {
  return message_as_NanConfigurationUpdate();
}

template<> inline const chre::fbs::DebugConfiguration *MessageContainer::message_as<chre::fbs::DebugConfiguration>() const {
  return message_as_DebugConfiguration();
}

template<> inline const chre::fbs::PulseRequest *MessageContainer::message_as<chre::fbs::PulseRequest>() const {
  return message_as_PulseRequest();
}

template<> inline const chre::fbs::PulseResponse *MessageContainer::message_as<chre::fbs::PulseResponse>() const {
  return message_as_PulseResponse();
}

template<> inline const chre::fbs::NanoappTokenDatabaseInfo *MessageContainer::message_as<chre::fbs::NanoappTokenDatabaseInfo>() const {
  return message_as_NanoappTokenDatabaseInfo();
}

template<> inline const chre::fbs::MessageDeliveryStatus *MessageContainer::message_as<chre::fbs::MessageDeliveryStatus>() const {
  return message_as_MessageDeliveryStatus();
}

template<> inline const chre::fbs::BtSocketOpen *MessageContainer::message_as<chre::fbs::BtSocketOpen>() const {
  return message_as_BtSocketOpen();
}

template<> inline const chre::fbs::BtSocketOpenResponse *MessageContainer::message_as<chre::fbs::BtSocketOpenResponse>() const {
  return message_as_BtSocketOpenResponse();
}

template<> inline const chre::fbs::BtSocketClose *MessageContainer::message_as<chre::fbs::BtSocketClose>() const {
  return message_as_BtSocketClose();
}

template<> inline const chre::fbs::BtSocketCloseResponse *MessageContainer::message_as<chre::fbs::BtSocketCloseResponse>() const {
  return message_as_BtSocketCloseResponse();
}

template<> inline const chre::fbs::GetMessageHubsAndEndpointsRequest *MessageContainer::message_as<chre::fbs::GetMessageHubsAndEndpointsRequest>() const {
  return message_as_GetMessageHubsAndEndpointsRequest();
}

template<> inline const chre::fbs::GetMessageHubsAndEndpointsResponse *MessageContainer::message_as<chre::fbs::GetMessageHubsAndEndpointsResponse>() const {
  return message_as_GetMessageHubsAndEndpointsResponse();
}

template<> inline const chre::fbs::RegisterMessageHub *MessageContainer::message_as<chre::fbs::RegisterMessageHub>() const {
  return message_as_RegisterMessageHub();
}

template<> inline const chre::fbs::UnregisterMessageHub *MessageContainer::message_as<chre::fbs::UnregisterMessageHub>() const {
  return message_as_UnregisterMessageHub();
}

template<> inline const chre::fbs::RegisterEndpoint *MessageContainer::message_as<chre::fbs::RegisterEndpoint>() const {
  return message_as_RegisterEndpoint();
}

template<> inline const chre::fbs::UnregisterEndpoint *MessageContainer::message_as<chre::fbs::UnregisterEndpoint>() const {
  return message_as_UnregisterEndpoint();
}

template<> inline const chre::fbs::OpenEndpointSessionRequest *MessageContainer::message_as<chre::fbs::OpenEndpointSessionRequest>() const {
  return message_as_OpenEndpointSessionRequest();
}

template<> inline const chre::fbs::EndpointSessionOpened *MessageContainer::message_as<chre::fbs::EndpointSessionOpened>() const {
  return message_as_EndpointSessionOpened();
}

template<> inline const chre::fbs::EndpointSessionClosed *MessageContainer::message_as<chre::fbs::EndpointSessionClosed>() const {
  return message_as_EndpointSessionClosed();
}

template<> inline const chre::fbs::EndpointSessionMessage *MessageContainer::message_as<chre::fbs::EndpointSessionMessage>() const {
  return message_as_EndpointSessionMessage();
}

template<> inline const chre::fbs::EndpointSessionMessageDeliveryStatus *MessageContainer::message_as<chre::fbs::EndpointSessionMessageDeliveryStatus>() const {
  return message_as_EndpointSessionMessageDeliveryStatus();
}

template<> inline const chre::fbs::BtSocketCapabilitiesRequest *MessageContainer::message_as<chre::fbs::BtSocketCapabilitiesRequest>() const {
  return message_as_BtSocketCapabilitiesRequest();
}

template<> inline const chre::fbs::BtSocketCapabilitiesResponse *MessageContainer::message_as<chre::fbs::BtSocketCapabilitiesResponse>() const {
  return message_as_BtSocketCapabilitiesResponse();
}

template<> inline const chre::fbs::AddServiceToEndpoint *MessageContainer::message_as<chre::fbs::AddServiceToEndpoint>() const {
  return message_as_AddServiceToEndpoint();
}

template<> inline const chre::fbs::EndpointReady *MessageContainer::message_as<chre::fbs::EndpointReady>() const {
  return message_as_EndpointReady();
}

struct MessageContainerBuilder {
  typedef MessageContainer Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_message_type(chre::fbs::ChreMessage message_type) {
    fbb_.AddElement<uint8_t>(MessageContainer::VT_MESSAGE_TYPE, static_cast<uint8_t>(message_type), 0);
  }
  void add_message(flatbuffers::Offset<void> message) {
    fbb_.AddOffset(MessageContainer::VT_MESSAGE, message);
  }
  void add_host_addr(const chre::fbs::HostAddress *host_addr) {
    fbb_.AddStruct(MessageContainer::VT_HOST_ADDR, host_addr);
  }
  explicit MessageContainerBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  MessageContainerBuilder &operator=(const MessageContainerBuilder &);
  flatbuffers::Offset<MessageContainer> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<MessageContainer>(end);
    fbb_.Required(o, MessageContainer::VT_MESSAGE);
    fbb_.Required(o, MessageContainer::VT_HOST_ADDR);
    return o;
  }
};

inline flatbuffers::Offset<MessageContainer> CreateMessageContainer(
    flatbuffers::FlatBufferBuilder &_fbb,
    chre::fbs::ChreMessage message_type = chre::fbs::ChreMessage::NONE,
    flatbuffers::Offset<void> message = 0,
    const chre::fbs::HostAddress *host_addr = 0) {
  MessageContainerBuilder builder_(_fbb);
  builder_.add_host_addr(host_addr);
  builder_.add_message(message);
  builder_.add_message_type(message_type);
  return builder_.Finish();
}

flatbuffers::Offset<MessageContainer> CreateMessageContainer(flatbuffers::FlatBufferBuilder &_fbb, const MessageContainerT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

inline NanoappMessageT *NanoappMessage::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  std::unique_ptr<chre::fbs::NanoappMessageT> _o = std::unique_ptr<chre::fbs::NanoappMessageT>(new NanoappMessageT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void NanoappMessage::UnPackTo(NanoappMessageT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = app_id(); _o->app_id = _e; }
  { auto _e = message_type(); _o->message_type = _e; }
  { auto _e = host_endpoint(); _o->host_endpoint = _e; }
  { auto _e = message(); if (_e) { _o->message.resize(_e->size()); for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->message[_i] = _e->Get(_i); } } }
  { auto _e = message_permissions(); _o->message_permissions = _e; }
  { auto _e = permissions(); _o->permissions = _e; }
  { auto _e = woke_host(); _o->woke_host = _e; }
  { auto _e = is_reliable(); _o->is_reliable = _e; }
  { auto _e = message_sequence_number(); _o->message_sequence_number = _e; }
}

inline flatbuffers::Offset<NanoappMessage> NanoappMessage::Pack(flatbuffers::FlatBufferBuilder &_fbb, const NanoappMessageT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateNanoappMessage(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<NanoappMessage> CreateNanoappMessage(flatbuffers::FlatBufferBuilder &_fbb, const NanoappMessageT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const NanoappMessageT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _app_id = _o->app_id;
  auto _message_type = _o->message_type;
  auto _host_endpoint = _o->host_endpoint;
  auto _message = _fbb.CreateVector(_o->message);
  auto _message_permissions = _o->message_permissions;
  auto _permissions = _o->permissions;
  auto _woke_host = _o->woke_host;
  auto _is_reliable = _o->is_reliable;
  auto _message_sequence_number = _o->message_sequence_number;
  return chre::fbs::CreateNanoappMessage(
      _fbb,
      _app_id,
      _message_type,
      _host_endpoint,
      _message,
      _message_permissions,
      _permissions,
      _woke_host,
      _is_reliable,
      _message_sequence_number);
}

inline MessageDeliveryStatusT *MessageDeliveryStatus::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  std::unique_ptr<chre::fbs::MessageDeliveryStatusT> _o = std::unique_ptr<chre::fbs::MessageDeliveryStatusT>(new MessageDeliveryStatusT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void MessageDeliveryStatus::UnPackTo(MessageDeliveryStatusT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = message_sequence_number(); _o->message_sequence_number = _e; }
  { auto _e = error_code(); _o->error_code = _e; }
}

inline flatbuffers::Offset<MessageDeliveryStatus> MessageDeliveryStatus::Pack(flatbuffers::FlatBufferBuilder &_fbb, const MessageDeliveryStatusT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateMessageDeliveryStatus(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<MessageDeliveryStatus> CreateMessageDeliveryStatus(flatbuffers::FlatBufferBuilder &_fbb, const MessageDeliveryStatusT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const MessageDeliveryStatusT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _message_sequence_number = _o->message_sequence_number;
  auto _error_code = _o->error_code;
  return chre::fbs::CreateMessageDeliveryStatus(
      _fbb,
      _message_sequence_number,
      _error_code);
}

inline HubInfoRequestT *HubInfoRequest::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  std::unique_ptr<chre::fbs::HubInfoRequestT> _o = std::unique_ptr<chre::fbs::HubInfoRequestT>(new HubInfoRequestT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void HubInfoRequest::UnPackTo(HubInfoRequestT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
}

inline flatbuffers::Offset<HubInfoRequest> HubInfoRequest::Pack(flatbuffers::FlatBufferBuilder &_fbb, const HubInfoRequestT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateHubInfoRequest(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<HubInfoRequest> CreateHubInfoRequest(flatbuffers::FlatBufferBuilder &_fbb, const HubInfoRequestT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const HubInfoRequestT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  return chre::fbs::CreateHubInfoRequest(
      _fbb);
}

inline HubInfoResponseT *HubInfoResponse::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  std::unique_ptr<chre::fbs::HubInfoResponseT> _o = std::unique_ptr<chre::fbs::HubInfoResponseT>(new HubInfoResponseT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void HubInfoResponse::UnPackTo(HubInfoResponseT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = name(); if (_e) { _o->name.resize(_e->size()); for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->name[_i] = _e->Get(_i); } } }
  { auto _e = vendor(); if (_e) { _o->vendor.resize(_e->size()); for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->vendor[_i] = _e->Get(_i); } } }
  { auto _e = toolchain(); if (_e) { _o->toolchain.resize(_e->size()); for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->toolchain[_i] = _e->Get(_i); } } }
  { auto _e = platform_version(); _o->platform_version = _e; }
  { auto _e = toolchain_version(); _o->toolchain_version = _e; }
  { auto _e = peak_mips(); _o->peak_mips = _e; }
  { auto _e = stopped_power(); _o->stopped_power = _e; }
  { auto _e = sleep_power(); _o->sleep_power = _e; }
  { auto _e = peak_power(); _o->peak_power = _e; }
  { auto _e = max_msg_len(); _o->max_msg_len = _e; }
  { auto _e = platform_id(); _o->platform_id = _e; }
  { auto _e = chre_platform_version(); _o->chre_platform_version = _e; }
  { auto _e = supports_reliable_messages(); _o->supports_reliable_messages = _e; }
}

inline flatbuffers::Offset<HubInfoResponse> HubInfoResponse::Pack(flatbuffers::FlatBufferBuilder &_fbb, const HubInfoResponseT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateHubInfoResponse(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<HubInfoResponse> CreateHubInfoResponse(flatbuffers::FlatBufferBuilder &_fbb, const HubInfoResponseT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const HubInfoResponseT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _name = _o->name.size() ? _fbb.CreateVector(_o->name) : 0;
  auto _vendor = _o->vendor.size() ? _fbb.CreateVector(_o->vendor) : 0;
  auto _toolchain = _o->toolchain.size() ? _fbb.CreateVector(_o->toolchain) : 0;
  auto _platform_version = _o->platform_version;
  auto _toolchain_version = _o->toolchain_version;
  auto _peak_mips = _o->peak_mips;
  auto _stopped_power = _o->stopped_power;
  auto _sleep_power = _o->sleep_power;
  auto _peak_power = _o->peak_power;
  auto _max_msg_len = _o->max_msg_len;
  auto _platform_id = _o->platform_id;
  auto _chre_platform_version = _o->chre_platform_version;
  auto _supports_reliable_messages = _o->supports_reliable_messages;
  return chre::fbs::CreateHubInfoResponse(
      _fbb,
      _name,
      _vendor,
      _toolchain,
      _platform_version,
      _toolchain_version,
      _peak_mips,
      _stopped_power,
      _sleep_power,
      _peak_power,
      _max_msg_len,
      _platform_id,
      _chre_platform_version,
      _supports_reliable_messages);
}

inline NanoappListRequestT *NanoappListRequest::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  std::unique_ptr<chre::fbs::NanoappListRequestT> _o = std::unique_ptr<chre::fbs::NanoappListRequestT>(new NanoappListRequestT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void NanoappListRequest::UnPackTo(NanoappListRequestT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
}

inline flatbuffers::Offset<NanoappListRequest> NanoappListRequest::Pack(flatbuffers::FlatBufferBuilder &_fbb, const NanoappListRequestT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateNanoappListRequest(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<NanoappListRequest> CreateNanoappListRequest(flatbuffers::FlatBufferBuilder &_fbb, const NanoappListRequestT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const NanoappListRequestT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  return chre::fbs::CreateNanoappListRequest(
      _fbb);
}

inline NanoappRpcServiceT *NanoappRpcService::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  std::unique_ptr<chre::fbs::NanoappRpcServiceT> _o = std::unique_ptr<chre::fbs::NanoappRpcServiceT>(new NanoappRpcServiceT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void NanoappRpcService::UnPackTo(NanoappRpcServiceT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = id(); _o->id = _e; }
  { auto _e = version(); _o->version = _e; }
}

inline flatbuffers::Offset<NanoappRpcService> NanoappRpcService::Pack(flatbuffers::FlatBufferBuilder &_fbb, const NanoappRpcServiceT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateNanoappRpcService(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<NanoappRpcService> CreateNanoappRpcService(flatbuffers::FlatBufferBuilder &_fbb, const NanoappRpcServiceT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const NanoappRpcServiceT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _id = _o->id;
  auto _version = _o->version;
  return chre::fbs::CreateNanoappRpcService(
      _fbb,
      _id,
      _version);
}

inline NanoappListEntryT *NanoappListEntry::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  std::unique_ptr<chre::fbs::NanoappListEntryT> _o = std::unique_ptr<chre::fbs::NanoappListEntryT>(new NanoappListEntryT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void NanoappListEntry::UnPackTo(NanoappListEntryT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = app_id(); _o->app_id = _e; }
  { auto _e = version(); _o->version = _e; }
  { auto _e = enabled(); _o->enabled = _e; }
  { auto _e = is_system(); _o->is_system = _e; }
  { auto _e = permissions(); _o->permissions = _e; }
  { auto _e = rpc_services(); if (_e) { _o->rpc_services.resize(_e->size()); for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->rpc_services[_i] = std::unique_ptr<chre::fbs::NanoappRpcServiceT>(_e->Get(_i)->UnPack(_resolver)); } } }
}

inline flatbuffers::Offset<NanoappListEntry> NanoappListEntry::Pack(flatbuffers::FlatBufferBuilder &_fbb, const NanoappListEntryT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateNanoappListEntry(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<NanoappListEntry> CreateNanoappListEntry(flatbuffers::FlatBufferBuilder &_fbb, const NanoappListEntryT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const NanoappListEntryT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _app_id = _o->app_id;
  auto _version = _o->version;
  auto _enabled = _o->enabled;
  auto _is_system = _o->is_system;
  auto _permissions = _o->permissions;
  auto _rpc_services = _o->rpc_services.size() ? _fbb.CreateVector<flatbuffers::Offset<chre::fbs::NanoappRpcService>> (_o->rpc_services.size(), [](size_t i, _VectorArgs *__va) { return CreateNanoappRpcService(*__va->__fbb, __va->__o->rpc_services[i].get(), __va->__rehasher); }, &_va ) : 0;
  return chre::fbs::CreateNanoappListEntry(
      _fbb,
      _app_id,
      _version,
      _enabled,
      _is_system,
      _permissions,
      _rpc_services);
}

inline NanoappListResponseT *NanoappListResponse::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  std::unique_ptr<chre::fbs::NanoappListResponseT> _o = std::unique_ptr<chre::fbs::NanoappListResponseT>(new NanoappListResponseT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void NanoappListResponse::UnPackTo(NanoappListResponseT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = nanoapps(); if (_e) { _o->nanoapps.resize(_e->size()); for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->nanoapps[_i] = std::unique_ptr<chre::fbs::NanoappListEntryT>(_e->Get(_i)->UnPack(_resolver)); } } }
}

inline flatbuffers::Offset<NanoappListResponse> NanoappListResponse::Pack(flatbuffers::FlatBufferBuilder &_fbb, const NanoappListResponseT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateNanoappListResponse(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<NanoappListResponse> CreateNanoappListResponse(flatbuffers::FlatBufferBuilder &_fbb, const NanoappListResponseT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const NanoappListResponseT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _nanoapps = _fbb.CreateVector<flatbuffers::Offset<chre::fbs::NanoappListEntry>> (_o->nanoapps.size(), [](size_t i, _VectorArgs *__va) { return CreateNanoappListEntry(*__va->__fbb, __va->__o->nanoapps[i].get(), __va->__rehasher); }, &_va );
  return chre::fbs::CreateNanoappListResponse(
      _fbb,
      _nanoapps);
}

inline LoadNanoappRequestT *LoadNanoappRequest::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  std::unique_ptr<chre::fbs::LoadNanoappRequestT> _o = std::unique_ptr<chre::fbs::LoadNanoappRequestT>(new LoadNanoappRequestT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void LoadNanoappRequest::UnPackTo(LoadNanoappRequestT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = transaction_id(); _o->transaction_id = _e; }
  { auto _e = app_id(); _o->app_id = _e; }
  { auto _e = app_version(); _o->app_version = _e; }
  { auto _e = target_api_version(); _o->target_api_version = _e; }
  { auto _e = app_binary(); if (_e) { _o->app_binary.resize(_e->size()); for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->app_binary[_i] = _e->Get(_i); } } }
  { auto _e = fragment_id(); _o->fragment_id = _e; }
  { auto _e = total_app_size(); _o->total_app_size = _e; }
  { auto _e = app_binary_file_name(); if (_e) { _o->app_binary_file_name.resize(_e->size()); for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->app_binary_file_name[_i] = _e->Get(_i); } } }
  { auto _e = app_flags(); _o->app_flags = _e; }
  { auto _e = respond_before_start(); _o->respond_before_start = _e; }
}

inline flatbuffers::Offset<LoadNanoappRequest> LoadNanoappRequest::Pack(flatbuffers::FlatBufferBuilder &_fbb, const LoadNanoappRequestT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateLoadNanoappRequest(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<LoadNanoappRequest> CreateLoadNanoappRequest(flatbuffers::FlatBufferBuilder &_fbb, const LoadNanoappRequestT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const LoadNanoappRequestT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _transaction_id = _o->transaction_id;
  auto _app_id = _o->app_id;
  auto _app_version = _o->app_version;
  auto _target_api_version = _o->target_api_version;
  auto _app_binary = _fbb.CreateVector(_o->app_binary);
  auto _fragment_id = _o->fragment_id;
  auto _total_app_size = _o->total_app_size;
  auto _app_binary_file_name = _o->app_binary_file_name.size() ? _fbb.CreateVector(_o->app_binary_file_name) : 0;
  auto _app_flags = _o->app_flags;
  auto _respond_before_start = _o->respond_before_start;
  return chre::fbs::CreateLoadNanoappRequest(
      _fbb,
      _transaction_id,
      _app_id,
      _app_version,
      _target_api_version,
      _app_binary,
      _fragment_id,
      _total_app_size,
      _app_binary_file_name,
      _app_flags,
      _respond_before_start);
}

inline LoadNanoappResponseT *LoadNanoappResponse::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  std::unique_ptr<chre::fbs::LoadNanoappResponseT> _o = std::unique_ptr<chre::fbs::LoadNanoappResponseT>(new LoadNanoappResponseT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void LoadNanoappResponse::UnPackTo(LoadNanoappResponseT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = transaction_id(); _o->transaction_id = _e; }
  { auto _e = success(); _o->success = _e; }
  { auto _e = fragment_id(); _o->fragment_id = _e; }
}

inline flatbuffers::Offset<LoadNanoappResponse> LoadNanoappResponse::Pack(flatbuffers::FlatBufferBuilder &_fbb, const LoadNanoappResponseT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateLoadNanoappResponse(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<LoadNanoappResponse> CreateLoadNanoappResponse(flatbuffers::FlatBufferBuilder &_fbb, const LoadNanoappResponseT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const LoadNanoappResponseT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _transaction_id = _o->transaction_id;
  auto _success = _o->success;
  auto _fragment_id = _o->fragment_id;
  return chre::fbs::CreateLoadNanoappResponse(
      _fbb,
      _transaction_id,
      _success,
      _fragment_id);
}

inline NanoappTokenDatabaseInfoT *NanoappTokenDatabaseInfo::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  std::unique_ptr<chre::fbs::NanoappTokenDatabaseInfoT> _o = std::unique_ptr<chre::fbs::NanoappTokenDatabaseInfoT>(new NanoappTokenDatabaseInfoT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void NanoappTokenDatabaseInfo::UnPackTo(NanoappTokenDatabaseInfoT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = instance_id(); _o->instance_id = _e; }
  { auto _e = app_id(); _o->app_id = _e; }
  { auto _e = database_offset_bytes(); _o->database_offset_bytes = _e; }
  { auto _e = database_size_bytes(); _o->database_size_bytes = _e; }
}

inline flatbuffers::Offset<NanoappTokenDatabaseInfo> NanoappTokenDatabaseInfo::Pack(flatbuffers::FlatBufferBuilder &_fbb, const NanoappTokenDatabaseInfoT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateNanoappTokenDatabaseInfo(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<NanoappTokenDatabaseInfo> CreateNanoappTokenDatabaseInfo(flatbuffers::FlatBufferBuilder &_fbb, const NanoappTokenDatabaseInfoT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const NanoappTokenDatabaseInfoT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _instance_id = _o->instance_id;
  auto _app_id = _o->app_id;
  auto _database_offset_bytes = _o->database_offset_bytes;
  auto _database_size_bytes = _o->database_size_bytes;
  return chre::fbs::CreateNanoappTokenDatabaseInfo(
      _fbb,
      _instance_id,
      _app_id,
      _database_offset_bytes,
      _database_size_bytes);
}

inline UnloadNanoappRequestT *UnloadNanoappRequest::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  std::unique_ptr<chre::fbs::UnloadNanoappRequestT> _o = std::unique_ptr<chre::fbs::UnloadNanoappRequestT>(new UnloadNanoappRequestT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void UnloadNanoappRequest::UnPackTo(UnloadNanoappRequestT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = transaction_id(); _o->transaction_id = _e; }
  { auto _e = app_id(); _o->app_id = _e; }
  { auto _e = allow_system_nanoapp_unload(); _o->allow_system_nanoapp_unload = _e; }
}

inline flatbuffers::Offset<UnloadNanoappRequest> UnloadNanoappRequest::Pack(flatbuffers::FlatBufferBuilder &_fbb, const UnloadNanoappRequestT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateUnloadNanoappRequest(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<UnloadNanoappRequest> CreateUnloadNanoappRequest(flatbuffers::FlatBufferBuilder &_fbb, const UnloadNanoappRequestT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const UnloadNanoappRequestT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _transaction_id = _o->transaction_id;
  auto _app_id = _o->app_id;
  auto _allow_system_nanoapp_unload = _o->allow_system_nanoapp_unload;
  return chre::fbs::CreateUnloadNanoappRequest(
      _fbb,
      _transaction_id,
      _app_id,
      _allow_system_nanoapp_unload);
}

inline UnloadNanoappResponseT *UnloadNanoappResponse::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  std::unique_ptr<chre::fbs::UnloadNanoappResponseT> _o = std::unique_ptr<chre::fbs::UnloadNanoappResponseT>(new UnloadNanoappResponseT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void UnloadNanoappResponse::UnPackTo(UnloadNanoappResponseT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = transaction_id(); _o->transaction_id = _e; }
  { auto _e = success(); _o->success = _e; }
}

inline flatbuffers::Offset<UnloadNanoappResponse> UnloadNanoappResponse::Pack(flatbuffers::FlatBufferBuilder &_fbb, const UnloadNanoappResponseT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateUnloadNanoappResponse(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<UnloadNanoappResponse> CreateUnloadNanoappResponse(flatbuffers::FlatBufferBuilder &_fbb, const UnloadNanoappResponseT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const UnloadNanoappResponseT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _transaction_id = _o->transaction_id;
  auto _success = _o->success;
  return chre::fbs::CreateUnloadNanoappResponse(
      _fbb,
      _transaction_id,
      _success);
}

inline LogMessageT *LogMessage::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  std::unique_ptr<chre::fbs::LogMessageT> _o = std::unique_ptr<chre::fbs::LogMessageT>(new LogMessageT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void LogMessage::UnPackTo(LogMessageT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = buffer(); if (_e) { _o->buffer.resize(_e->size()); for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->buffer[_i] = _e->Get(_i); } } }
}

inline flatbuffers::Offset<LogMessage> LogMessage::Pack(flatbuffers::FlatBufferBuilder &_fbb, const LogMessageT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateLogMessage(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<LogMessage> CreateLogMessage(flatbuffers::FlatBufferBuilder &_fbb, const LogMessageT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const LogMessageT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _buffer = _o->buffer.size() ? _fbb.CreateVector(_o->buffer) : 0;
  return chre::fbs::CreateLogMessage(
      _fbb,
      _buffer);
}

inline TimeSyncMessageT *TimeSyncMessage::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  std::unique_ptr<chre::fbs::TimeSyncMessageT> _o = std::unique_ptr<chre::fbs::TimeSyncMessageT>(new TimeSyncMessageT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void TimeSyncMessage::UnPackTo(TimeSyncMessageT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = offset(); _o->offset = _e; }
}

inline flatbuffers::Offset<TimeSyncMessage> TimeSyncMessage::Pack(flatbuffers::FlatBufferBuilder &_fbb, const TimeSyncMessageT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateTimeSyncMessage(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<TimeSyncMessage> CreateTimeSyncMessage(flatbuffers::FlatBufferBuilder &_fbb, const TimeSyncMessageT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const TimeSyncMessageT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _offset = _o->offset;
  return chre::fbs::CreateTimeSyncMessage(
      _fbb,
      _offset);
}

inline DebugDumpRequestT *DebugDumpRequest::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  std::unique_ptr<chre::fbs::DebugDumpRequestT> _o = std::unique_ptr<chre::fbs::DebugDumpRequestT>(new DebugDumpRequestT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void DebugDumpRequest::UnPackTo(DebugDumpRequestT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
}

inline flatbuffers::Offset<DebugDumpRequest> DebugDumpRequest::Pack(flatbuffers::FlatBufferBuilder &_fbb, const DebugDumpRequestT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateDebugDumpRequest(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<DebugDumpRequest> CreateDebugDumpRequest(flatbuffers::FlatBufferBuilder &_fbb, const DebugDumpRequestT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const DebugDumpRequestT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  return chre::fbs::CreateDebugDumpRequest(
      _fbb);
}

inline DebugDumpDataT *DebugDumpData::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  std::unique_ptr<chre::fbs::DebugDumpDataT> _o = std::unique_ptr<chre::fbs::DebugDumpDataT>(new DebugDumpDataT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void DebugDumpData::UnPackTo(DebugDumpDataT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = debug_str(); if (_e) { _o->debug_str.resize(_e->size()); for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->debug_str[_i] = _e->Get(_i); } } }
}

inline flatbuffers::Offset<DebugDumpData> DebugDumpData::Pack(flatbuffers::FlatBufferBuilder &_fbb, const DebugDumpDataT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateDebugDumpData(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<DebugDumpData> CreateDebugDumpData(flatbuffers::FlatBufferBuilder &_fbb, const DebugDumpDataT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const DebugDumpDataT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _debug_str = _o->debug_str.size() ? _fbb.CreateVector(_o->debug_str) : 0;
  return chre::fbs::CreateDebugDumpData(
      _fbb,
      _debug_str);
}

inline DebugDumpResponseT *DebugDumpResponse::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  std::unique_ptr<chre::fbs::DebugDumpResponseT> _o = std::unique_ptr<chre::fbs::DebugDumpResponseT>(new DebugDumpResponseT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void DebugDumpResponse::UnPackTo(DebugDumpResponseT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = success(); _o->success = _e; }
  { auto _e = data_count(); _o->data_count = _e; }
}

inline flatbuffers::Offset<DebugDumpResponse> DebugDumpResponse::Pack(flatbuffers::FlatBufferBuilder &_fbb, const DebugDumpResponseT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateDebugDumpResponse(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<DebugDumpResponse> CreateDebugDumpResponse(flatbuffers::FlatBufferBuilder &_fbb, const DebugDumpResponseT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const DebugDumpResponseT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _success = _o->success;
  auto _data_count = _o->data_count;
  return chre::fbs::CreateDebugDumpResponse(
      _fbb,
      _success,
      _data_count);
}

inline TimeSyncRequestT *TimeSyncRequest::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  std::unique_ptr<chre::fbs::TimeSyncRequestT> _o = std::unique_ptr<chre::fbs::TimeSyncRequestT>(new TimeSyncRequestT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void TimeSyncRequest::UnPackTo(TimeSyncRequestT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
}

inline flatbuffers::Offset<TimeSyncRequest> TimeSyncRequest::Pack(flatbuffers::FlatBufferBuilder &_fbb, const TimeSyncRequestT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateTimeSyncRequest(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<TimeSyncRequest> CreateTimeSyncRequest(flatbuffers::FlatBufferBuilder &_fbb, const TimeSyncRequestT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const TimeSyncRequestT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  return chre::fbs::CreateTimeSyncRequest(
      _fbb);
}

inline LowPowerMicAccessRequestT *LowPowerMicAccessRequest::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  std::unique_ptr<chre::fbs::LowPowerMicAccessRequestT> _o = std::unique_ptr<chre::fbs::LowPowerMicAccessRequestT>(new LowPowerMicAccessRequestT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void LowPowerMicAccessRequest::UnPackTo(LowPowerMicAccessRequestT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
}

inline flatbuffers::Offset<LowPowerMicAccessRequest> LowPowerMicAccessRequest::Pack(flatbuffers::FlatBufferBuilder &_fbb, const LowPowerMicAccessRequestT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateLowPowerMicAccessRequest(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<LowPowerMicAccessRequest> CreateLowPowerMicAccessRequest(flatbuffers::FlatBufferBuilder &_fbb, const LowPowerMicAccessRequestT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const LowPowerMicAccessRequestT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  return chre::fbs::CreateLowPowerMicAccessRequest(
      _fbb);
}

inline LowPowerMicAccessReleaseT *LowPowerMicAccessRelease::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  std::unique_ptr<chre::fbs::LowPowerMicAccessReleaseT> _o = std::unique_ptr<chre::fbs::LowPowerMicAccessReleaseT>(new LowPowerMicAccessReleaseT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void LowPowerMicAccessRelease::UnPackTo(LowPowerMicAccessReleaseT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
}

inline flatbuffers::Offset<LowPowerMicAccessRelease> LowPowerMicAccessRelease::Pack(flatbuffers::FlatBufferBuilder &_fbb, const LowPowerMicAccessReleaseT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateLowPowerMicAccessRelease(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<LowPowerMicAccessRelease> CreateLowPowerMicAccessRelease(flatbuffers::FlatBufferBuilder &_fbb, const LowPowerMicAccessReleaseT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const LowPowerMicAccessReleaseT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  return chre::fbs::CreateLowPowerMicAccessRelease(
      _fbb);
}

inline SettingChangeMessageT *SettingChangeMessage::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  std::unique_ptr<chre::fbs::SettingChangeMessageT> _o = std::unique_ptr<chre::fbs::SettingChangeMessageT>(new SettingChangeMessageT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void SettingChangeMessage::UnPackTo(SettingChangeMessageT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = setting(); _o->setting = _e; }
  { auto _e = state(); _o->state = _e; }
}

inline flatbuffers::Offset<SettingChangeMessage> SettingChangeMessage::Pack(flatbuffers::FlatBufferBuilder &_fbb, const SettingChangeMessageT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateSettingChangeMessage(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<SettingChangeMessage> CreateSettingChangeMessage(flatbuffers::FlatBufferBuilder &_fbb, const SettingChangeMessageT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const SettingChangeMessageT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _setting = _o->setting;
  auto _state = _o->state;
  return chre::fbs::CreateSettingChangeMessage(
      _fbb,
      _setting,
      _state);
}

inline LogMessageV2T *LogMessageV2::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  std::unique_ptr<chre::fbs::LogMessageV2T> _o = std::unique_ptr<chre::fbs::LogMessageV2T>(new LogMessageV2T());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void LogMessageV2::UnPackTo(LogMessageV2T *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = buffer(); if (_e) { _o->buffer.resize(_e->size()); for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->buffer[_i] = _e->Get(_i); } } }
  { auto _e = num_logs_dropped(); _o->num_logs_dropped = _e; }
}

inline flatbuffers::Offset<LogMessageV2> LogMessageV2::Pack(flatbuffers::FlatBufferBuilder &_fbb, const LogMessageV2T* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateLogMessageV2(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<LogMessageV2> CreateLogMessageV2(flatbuffers::FlatBufferBuilder &_fbb, const LogMessageV2T *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const LogMessageV2T* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _buffer = _o->buffer.size() ? _fbb.CreateVector(_o->buffer) : 0;
  auto _num_logs_dropped = _o->num_logs_dropped;
  return chre::fbs::CreateLogMessageV2(
      _fbb,
      _buffer,
      _num_logs_dropped);
}

inline SelfTestRequestT *SelfTestRequest::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  std::unique_ptr<chre::fbs::SelfTestRequestT> _o = std::unique_ptr<chre::fbs::SelfTestRequestT>(new SelfTestRequestT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void SelfTestRequest::UnPackTo(SelfTestRequestT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
}

inline flatbuffers::Offset<SelfTestRequest> SelfTestRequest::Pack(flatbuffers::FlatBufferBuilder &_fbb, const SelfTestRequestT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateSelfTestRequest(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<SelfTestRequest> CreateSelfTestRequest(flatbuffers::FlatBufferBuilder &_fbb, const SelfTestRequestT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const SelfTestRequestT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  return chre::fbs::CreateSelfTestRequest(
      _fbb);
}

inline SelfTestResponseT *SelfTestResponse::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  std::unique_ptr<chre::fbs::SelfTestResponseT> _o = std::unique_ptr<chre::fbs::SelfTestResponseT>(new SelfTestResponseT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void SelfTestResponse::UnPackTo(SelfTestResponseT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = success(); _o->success = _e; }
}

inline flatbuffers::Offset<SelfTestResponse> SelfTestResponse::Pack(flatbuffers::FlatBufferBuilder &_fbb, const SelfTestResponseT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateSelfTestResponse(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<SelfTestResponse> CreateSelfTestResponse(flatbuffers::FlatBufferBuilder &_fbb, const SelfTestResponseT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const SelfTestResponseT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _success = _o->success;
  return chre::fbs::CreateSelfTestResponse(
      _fbb,
      _success);
}

inline HostEndpointConnectedT *HostEndpointConnected::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  std::unique_ptr<chre::fbs::HostEndpointConnectedT> _o = std::unique_ptr<chre::fbs::HostEndpointConnectedT>(new HostEndpointConnectedT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void HostEndpointConnected::UnPackTo(HostEndpointConnectedT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = host_endpoint(); _o->host_endpoint = _e; }
  { auto _e = type(); _o->type = _e; }
  { auto _e = package_name(); if (_e) { _o->package_name.resize(_e->size()); for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->package_name[_i] = _e->Get(_i); } } }
  { auto _e = attribution_tag(); if (_e) { _o->attribution_tag.resize(_e->size()); for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->attribution_tag[_i] = _e->Get(_i); } } }
}

inline flatbuffers::Offset<HostEndpointConnected> HostEndpointConnected::Pack(flatbuffers::FlatBufferBuilder &_fbb, const HostEndpointConnectedT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateHostEndpointConnected(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<HostEndpointConnected> CreateHostEndpointConnected(flatbuffers::FlatBufferBuilder &_fbb, const HostEndpointConnectedT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const HostEndpointConnectedT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _host_endpoint = _o->host_endpoint;
  auto _type = _o->type;
  auto _package_name = _o->package_name.size() ? _fbb.CreateVector(_o->package_name) : 0;
  auto _attribution_tag = _o->attribution_tag.size() ? _fbb.CreateVector(_o->attribution_tag) : 0;
  return chre::fbs::CreateHostEndpointConnected(
      _fbb,
      _host_endpoint,
      _type,
      _package_name,
      _attribution_tag);
}

inline HostEndpointDisconnectedT *HostEndpointDisconnected::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  std::unique_ptr<chre::fbs::HostEndpointDisconnectedT> _o = std::unique_ptr<chre::fbs::HostEndpointDisconnectedT>(new HostEndpointDisconnectedT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void HostEndpointDisconnected::UnPackTo(HostEndpointDisconnectedT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = host_endpoint(); _o->host_endpoint = _e; }
}

inline flatbuffers::Offset<HostEndpointDisconnected> HostEndpointDisconnected::Pack(flatbuffers::FlatBufferBuilder &_fbb, const HostEndpointDisconnectedT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateHostEndpointDisconnected(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<HostEndpointDisconnected> CreateHostEndpointDisconnected(flatbuffers::FlatBufferBuilder &_fbb, const HostEndpointDisconnectedT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const HostEndpointDisconnectedT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _host_endpoint = _o->host_endpoint;
  return chre::fbs::CreateHostEndpointDisconnected(
      _fbb,
      _host_endpoint);
}

inline MetricLogT *MetricLog::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  std::unique_ptr<chre::fbs::MetricLogT> _o = std::unique_ptr<chre::fbs::MetricLogT>(new MetricLogT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void MetricLog::UnPackTo(MetricLogT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = id(); _o->id = _e; }
  { auto _e = encoded_metric(); if (_e) { _o->encoded_metric.resize(_e->size()); for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->encoded_metric[_i] = _e->Get(_i); } } }
}

inline flatbuffers::Offset<MetricLog> MetricLog::Pack(flatbuffers::FlatBufferBuilder &_fbb, const MetricLogT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateMetricLog(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<MetricLog> CreateMetricLog(flatbuffers::FlatBufferBuilder &_fbb, const MetricLogT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const MetricLogT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _id = _o->id;
  auto _encoded_metric = _o->encoded_metric.size() ? _fbb.CreateVector(_o->encoded_metric) : 0;
  return chre::fbs::CreateMetricLog(
      _fbb,
      _id,
      _encoded_metric);
}

inline BatchedMetricLogT *BatchedMetricLog::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  std::unique_ptr<chre::fbs::BatchedMetricLogT> _o = std::unique_ptr<chre::fbs::BatchedMetricLogT>(new BatchedMetricLogT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void BatchedMetricLog::UnPackTo(BatchedMetricLogT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = metrics(); if (_e) { _o->metrics.resize(_e->size()); for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->metrics[_i] = std::unique_ptr<chre::fbs::MetricLogT>(_e->Get(_i)->UnPack(_resolver)); } } }
}

inline flatbuffers::Offset<BatchedMetricLog> BatchedMetricLog::Pack(flatbuffers::FlatBufferBuilder &_fbb, const BatchedMetricLogT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateBatchedMetricLog(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<BatchedMetricLog> CreateBatchedMetricLog(flatbuffers::FlatBufferBuilder &_fbb, const BatchedMetricLogT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const BatchedMetricLogT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _metrics = _o->metrics.size() ? _fbb.CreateVector<flatbuffers::Offset<chre::fbs::MetricLog>> (_o->metrics.size(), [](size_t i, _VectorArgs *__va) { return CreateMetricLog(*__va->__fbb, __va->__o->metrics[i].get(), __va->__rehasher); }, &_va ) : 0;
  return chre::fbs::CreateBatchedMetricLog(
      _fbb,
      _metrics);
}

inline NanConfigurationRequestT *NanConfigurationRequest::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  std::unique_ptr<chre::fbs::NanConfigurationRequestT> _o = std::unique_ptr<chre::fbs::NanConfigurationRequestT>(new NanConfigurationRequestT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void NanConfigurationRequest::UnPackTo(NanConfigurationRequestT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = enable(); _o->enable = _e; }
}

inline flatbuffers::Offset<NanConfigurationRequest> NanConfigurationRequest::Pack(flatbuffers::FlatBufferBuilder &_fbb, const NanConfigurationRequestT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateNanConfigurationRequest(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<NanConfigurationRequest> CreateNanConfigurationRequest(flatbuffers::FlatBufferBuilder &_fbb, const NanConfigurationRequestT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const NanConfigurationRequestT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _enable = _o->enable;
  return chre::fbs::CreateNanConfigurationRequest(
      _fbb,
      _enable);
}

inline NanConfigurationUpdateT *NanConfigurationUpdate::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  std::unique_ptr<chre::fbs::NanConfigurationUpdateT> _o = std::unique_ptr<chre::fbs::NanConfigurationUpdateT>(new NanConfigurationUpdateT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void NanConfigurationUpdate::UnPackTo(NanConfigurationUpdateT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = enabled(); _o->enabled = _e; }
}

inline flatbuffers::Offset<NanConfigurationUpdate> NanConfigurationUpdate::Pack(flatbuffers::FlatBufferBuilder &_fbb, const NanConfigurationUpdateT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateNanConfigurationUpdate(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<NanConfigurationUpdate> CreateNanConfigurationUpdate(flatbuffers::FlatBufferBuilder &_fbb, const NanConfigurationUpdateT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const NanConfigurationUpdateT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _enabled = _o->enabled;
  return chre::fbs::CreateNanConfigurationUpdate(
      _fbb,
      _enabled);
}

inline DebugConfigurationT *DebugConfiguration::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  std::unique_ptr<chre::fbs::DebugConfigurationT> _o = std::unique_ptr<chre::fbs::DebugConfigurationT>(new DebugConfigurationT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void DebugConfiguration::UnPackTo(DebugConfigurationT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = health_monitor_failure_crash(); _o->health_monitor_failure_crash = _e; }
}

inline flatbuffers::Offset<DebugConfiguration> DebugConfiguration::Pack(flatbuffers::FlatBufferBuilder &_fbb, const DebugConfigurationT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateDebugConfiguration(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<DebugConfiguration> CreateDebugConfiguration(flatbuffers::FlatBufferBuilder &_fbb, const DebugConfigurationT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const DebugConfigurationT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _health_monitor_failure_crash = _o->health_monitor_failure_crash;
  return chre::fbs::CreateDebugConfiguration(
      _fbb,
      _health_monitor_failure_crash);
}

inline PulseRequestT *PulseRequest::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  std::unique_ptr<chre::fbs::PulseRequestT> _o = std::unique_ptr<chre::fbs::PulseRequestT>(new PulseRequestT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void PulseRequest::UnPackTo(PulseRequestT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
}

inline flatbuffers::Offset<PulseRequest> PulseRequest::Pack(flatbuffers::FlatBufferBuilder &_fbb, const PulseRequestT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreatePulseRequest(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<PulseRequest> CreatePulseRequest(flatbuffers::FlatBufferBuilder &_fbb, const PulseRequestT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const PulseRequestT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  return chre::fbs::CreatePulseRequest(
      _fbb);
}

inline PulseResponseT *PulseResponse::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  std::unique_ptr<chre::fbs::PulseResponseT> _o = std::unique_ptr<chre::fbs::PulseResponseT>(new PulseResponseT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void PulseResponse::UnPackTo(PulseResponseT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
}

inline flatbuffers::Offset<PulseResponse> PulseResponse::Pack(flatbuffers::FlatBufferBuilder &_fbb, const PulseResponseT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreatePulseResponse(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<PulseResponse> CreatePulseResponse(flatbuffers::FlatBufferBuilder &_fbb, const PulseResponseT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const PulseResponseT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  return chre::fbs::CreatePulseResponse(
      _fbb);
}

inline LeCocChannelInfoT *LeCocChannelInfo::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  std::unique_ptr<chre::fbs::LeCocChannelInfoT> _o = std::unique_ptr<chre::fbs::LeCocChannelInfoT>(new LeCocChannelInfoT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void LeCocChannelInfo::UnPackTo(LeCocChannelInfoT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = localCid(); _o->localCid = _e; }
  { auto _e = remoteCid(); _o->remoteCid = _e; }
  { auto _e = psm(); _o->psm = _e; }
  { auto _e = localMtu(); _o->localMtu = _e; }
  { auto _e = remoteMtu(); _o->remoteMtu = _e; }
  { auto _e = localMps(); _o->localMps = _e; }
  { auto _e = remoteMps(); _o->remoteMps = _e; }
  { auto _e = initialRxCredits(); _o->initialRxCredits = _e; }
  { auto _e = initialTxCredits(); _o->initialTxCredits = _e; }
}

inline flatbuffers::Offset<LeCocChannelInfo> LeCocChannelInfo::Pack(flatbuffers::FlatBufferBuilder &_fbb, const LeCocChannelInfoT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateLeCocChannelInfo(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<LeCocChannelInfo> CreateLeCocChannelInfo(flatbuffers::FlatBufferBuilder &_fbb, const LeCocChannelInfoT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const LeCocChannelInfoT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _localCid = _o->localCid;
  auto _remoteCid = _o->remoteCid;
  auto _psm = _o->psm;
  auto _localMtu = _o->localMtu;
  auto _remoteMtu = _o->remoteMtu;
  auto _localMps = _o->localMps;
  auto _remoteMps = _o->remoteMps;
  auto _initialRxCredits = _o->initialRxCredits;
  auto _initialTxCredits = _o->initialTxCredits;
  return chre::fbs::CreateLeCocChannelInfo(
      _fbb,
      _localCid,
      _remoteCid,
      _psm,
      _localMtu,
      _remoteMtu,
      _localMps,
      _remoteMps,
      _initialRxCredits,
      _initialTxCredits);
}

inline BtSocketOpenT *BtSocketOpen::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  std::unique_ptr<chre::fbs::BtSocketOpenT> _o = std::unique_ptr<chre::fbs::BtSocketOpenT>(new BtSocketOpenT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void BtSocketOpen::UnPackTo(BtSocketOpenT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = socketId(); _o->socketId = _e; }
  { auto _e = name(); if (_e) { _o->name.resize(_e->size()); for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->name[_i] = _e->Get(_i); } } }
  { auto _e = aclConnectionHandle(); _o->aclConnectionHandle = _e; }
  { auto _e = channelInfo_type(); _o->channelInfo.type = _e; }
  { auto _e = channelInfo(); if (_e) _o->channelInfo.value = chre::fbs::ChannelInfoUnion::UnPack(_e, channelInfo_type(), _resolver); }
  { auto _e = hubId(); _o->hubId = _e; }
  { auto _e = endpointId(); _o->endpointId = _e; }
}

inline flatbuffers::Offset<BtSocketOpen> BtSocketOpen::Pack(flatbuffers::FlatBufferBuilder &_fbb, const BtSocketOpenT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateBtSocketOpen(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<BtSocketOpen> CreateBtSocketOpen(flatbuffers::FlatBufferBuilder &_fbb, const BtSocketOpenT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const BtSocketOpenT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _socketId = _o->socketId;
  auto _name = _o->name.size() ? _fbb.CreateVector(_o->name) : 0;
  auto _aclConnectionHandle = _o->aclConnectionHandle;
  auto _channelInfo_type = _o->channelInfo.type;
  auto _channelInfo = _o->channelInfo.Pack(_fbb);
  auto _hubId = _o->hubId;
  auto _endpointId = _o->endpointId;
  return chre::fbs::CreateBtSocketOpen(
      _fbb,
      _socketId,
      _name,
      _aclConnectionHandle,
      _channelInfo_type,
      _channelInfo,
      _hubId,
      _endpointId);
}

inline BtSocketOpenResponseT *BtSocketOpenResponse::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  std::unique_ptr<chre::fbs::BtSocketOpenResponseT> _o = std::unique_ptr<chre::fbs::BtSocketOpenResponseT>(new BtSocketOpenResponseT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void BtSocketOpenResponse::UnPackTo(BtSocketOpenResponseT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = socketId(); _o->socketId = _e; }
  { auto _e = status(); _o->status = _e; }
  { auto _e = reason(); if (_e) { _o->reason.resize(_e->size()); for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->reason[_i] = _e->Get(_i); } } }
}

inline flatbuffers::Offset<BtSocketOpenResponse> BtSocketOpenResponse::Pack(flatbuffers::FlatBufferBuilder &_fbb, const BtSocketOpenResponseT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateBtSocketOpenResponse(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<BtSocketOpenResponse> CreateBtSocketOpenResponse(flatbuffers::FlatBufferBuilder &_fbb, const BtSocketOpenResponseT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const BtSocketOpenResponseT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _socketId = _o->socketId;
  auto _status = _o->status;
  auto _reason = _o->reason.size() ? _fbb.CreateVector(_o->reason) : 0;
  return chre::fbs::CreateBtSocketOpenResponse(
      _fbb,
      _socketId,
      _status,
      _reason);
}

inline BtSocketCloseT *BtSocketClose::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  std::unique_ptr<chre::fbs::BtSocketCloseT> _o = std::unique_ptr<chre::fbs::BtSocketCloseT>(new BtSocketCloseT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void BtSocketClose::UnPackTo(BtSocketCloseT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = socketId(); _o->socketId = _e; }
  { auto _e = reason(); if (_e) { _o->reason.resize(_e->size()); for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->reason[_i] = _e->Get(_i); } } }
}

inline flatbuffers::Offset<BtSocketClose> BtSocketClose::Pack(flatbuffers::FlatBufferBuilder &_fbb, const BtSocketCloseT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateBtSocketClose(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<BtSocketClose> CreateBtSocketClose(flatbuffers::FlatBufferBuilder &_fbb, const BtSocketCloseT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const BtSocketCloseT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _socketId = _o->socketId;
  auto _reason = _o->reason.size() ? _fbb.CreateVector(_o->reason) : 0;
  return chre::fbs::CreateBtSocketClose(
      _fbb,
      _socketId,
      _reason);
}

inline BtSocketCloseResponseT *BtSocketCloseResponse::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  std::unique_ptr<chre::fbs::BtSocketCloseResponseT> _o = std::unique_ptr<chre::fbs::BtSocketCloseResponseT>(new BtSocketCloseResponseT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void BtSocketCloseResponse::UnPackTo(BtSocketCloseResponseT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = socketId(); _o->socketId = _e; }
}

inline flatbuffers::Offset<BtSocketCloseResponse> BtSocketCloseResponse::Pack(flatbuffers::FlatBufferBuilder &_fbb, const BtSocketCloseResponseT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateBtSocketCloseResponse(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<BtSocketCloseResponse> CreateBtSocketCloseResponse(flatbuffers::FlatBufferBuilder &_fbb, const BtSocketCloseResponseT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const BtSocketCloseResponseT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _socketId = _o->socketId;
  return chre::fbs::CreateBtSocketCloseResponse(
      _fbb,
      _socketId);
}

inline BtSocketCapabilitiesRequestT *BtSocketCapabilitiesRequest::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  std::unique_ptr<chre::fbs::BtSocketCapabilitiesRequestT> _o = std::unique_ptr<chre::fbs::BtSocketCapabilitiesRequestT>(new BtSocketCapabilitiesRequestT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void BtSocketCapabilitiesRequest::UnPackTo(BtSocketCapabilitiesRequestT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
}

inline flatbuffers::Offset<BtSocketCapabilitiesRequest> BtSocketCapabilitiesRequest::Pack(flatbuffers::FlatBufferBuilder &_fbb, const BtSocketCapabilitiesRequestT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateBtSocketCapabilitiesRequest(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<BtSocketCapabilitiesRequest> CreateBtSocketCapabilitiesRequest(flatbuffers::FlatBufferBuilder &_fbb, const BtSocketCapabilitiesRequestT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const BtSocketCapabilitiesRequestT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  return chre::fbs::CreateBtSocketCapabilitiesRequest(
      _fbb);
}

inline BtSocketLeCocCapabilitiesT *BtSocketLeCocCapabilities::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  std::unique_ptr<chre::fbs::BtSocketLeCocCapabilitiesT> _o = std::unique_ptr<chre::fbs::BtSocketLeCocCapabilitiesT>(new BtSocketLeCocCapabilitiesT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void BtSocketLeCocCapabilities::UnPackTo(BtSocketLeCocCapabilitiesT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = numberOfSupportedSockets(); _o->numberOfSupportedSockets = _e; }
  { auto _e = mtu(); _o->mtu = _e; }
}

inline flatbuffers::Offset<BtSocketLeCocCapabilities> BtSocketLeCocCapabilities::Pack(flatbuffers::FlatBufferBuilder &_fbb, const BtSocketLeCocCapabilitiesT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateBtSocketLeCocCapabilities(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<BtSocketLeCocCapabilities> CreateBtSocketLeCocCapabilities(flatbuffers::FlatBufferBuilder &_fbb, const BtSocketLeCocCapabilitiesT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const BtSocketLeCocCapabilitiesT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _numberOfSupportedSockets = _o->numberOfSupportedSockets;
  auto _mtu = _o->mtu;
  return chre::fbs::CreateBtSocketLeCocCapabilities(
      _fbb,
      _numberOfSupportedSockets,
      _mtu);
}

inline BtSocketRfcommCapabilitiesT *BtSocketRfcommCapabilities::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  std::unique_ptr<chre::fbs::BtSocketRfcommCapabilitiesT> _o = std::unique_ptr<chre::fbs::BtSocketRfcommCapabilitiesT>(new BtSocketRfcommCapabilitiesT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void BtSocketRfcommCapabilities::UnPackTo(BtSocketRfcommCapabilitiesT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = numberOfSupportedSockets(); _o->numberOfSupportedSockets = _e; }
  { auto _e = maxFrameSize(); _o->maxFrameSize = _e; }
}

inline flatbuffers::Offset<BtSocketRfcommCapabilities> BtSocketRfcommCapabilities::Pack(flatbuffers::FlatBufferBuilder &_fbb, const BtSocketRfcommCapabilitiesT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateBtSocketRfcommCapabilities(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<BtSocketRfcommCapabilities> CreateBtSocketRfcommCapabilities(flatbuffers::FlatBufferBuilder &_fbb, const BtSocketRfcommCapabilitiesT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const BtSocketRfcommCapabilitiesT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _numberOfSupportedSockets = _o->numberOfSupportedSockets;
  auto _maxFrameSize = _o->maxFrameSize;
  return chre::fbs::CreateBtSocketRfcommCapabilities(
      _fbb,
      _numberOfSupportedSockets,
      _maxFrameSize);
}

inline BtSocketCapabilitiesResponseT *BtSocketCapabilitiesResponse::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  std::unique_ptr<chre::fbs::BtSocketCapabilitiesResponseT> _o = std::unique_ptr<chre::fbs::BtSocketCapabilitiesResponseT>(new BtSocketCapabilitiesResponseT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void BtSocketCapabilitiesResponse::UnPackTo(BtSocketCapabilitiesResponseT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = leCocCapabilities(); if (_e) _o->leCocCapabilities = std::unique_ptr<chre::fbs::BtSocketLeCocCapabilitiesT>(_e->UnPack(_resolver)); }
  { auto _e = rfcommCapabilities(); if (_e) _o->rfcommCapabilities = std::unique_ptr<chre::fbs::BtSocketRfcommCapabilitiesT>(_e->UnPack(_resolver)); }
}

inline flatbuffers::Offset<BtSocketCapabilitiesResponse> BtSocketCapabilitiesResponse::Pack(flatbuffers::FlatBufferBuilder &_fbb, const BtSocketCapabilitiesResponseT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateBtSocketCapabilitiesResponse(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<BtSocketCapabilitiesResponse> CreateBtSocketCapabilitiesResponse(flatbuffers::FlatBufferBuilder &_fbb, const BtSocketCapabilitiesResponseT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const BtSocketCapabilitiesResponseT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _leCocCapabilities = _o->leCocCapabilities ? CreateBtSocketLeCocCapabilities(_fbb, _o->leCocCapabilities.get(), _rehasher) : 0;
  auto _rfcommCapabilities = _o->rfcommCapabilities ? CreateBtSocketRfcommCapabilities(_fbb, _o->rfcommCapabilities.get(), _rehasher) : 0;
  return chre::fbs::CreateBtSocketCapabilitiesResponse(
      _fbb,
      _leCocCapabilities,
      _rfcommCapabilities);
}

inline VendorHubInfoT *VendorHubInfo::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  std::unique_ptr<chre::fbs::VendorHubInfoT> _o = std::unique_ptr<chre::fbs::VendorHubInfoT>(new VendorHubInfoT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void VendorHubInfo::UnPackTo(VendorHubInfoT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = name(); if (_e) { _o->name.resize(_e->size()); for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->name[_i] = _e->Get(_i); } } }
  { auto _e = version(); _o->version = _e; }
  { auto _e = extended_info(); if (_e) { _o->extended_info.resize(_e->size()); for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->extended_info[_i] = _e->Get(_i); } } }
}

inline flatbuffers::Offset<VendorHubInfo> VendorHubInfo::Pack(flatbuffers::FlatBufferBuilder &_fbb, const VendorHubInfoT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateVendorHubInfo(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<VendorHubInfo> CreateVendorHubInfo(flatbuffers::FlatBufferBuilder &_fbb, const VendorHubInfoT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const VendorHubInfoT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _name = _o->name.size() ? _fbb.CreateVector(_o->name) : 0;
  auto _version = _o->version;
  auto _extended_info = _o->extended_info.size() ? _fbb.CreateVector(_o->extended_info) : 0;
  return chre::fbs::CreateVendorHubInfo(
      _fbb,
      _name,
      _version,
      _extended_info);
}

inline MessageHubT *MessageHub::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  std::unique_ptr<chre::fbs::MessageHubT> _o = std::unique_ptr<chre::fbs::MessageHubT>(new MessageHubT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void MessageHub::UnPackTo(MessageHubT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = id(); _o->id = _e; }
  { auto _e = details_type(); _o->details.type = _e; }
  { auto _e = details(); if (_e) _o->details.value = chre::fbs::MessageHubDetailsUnion::UnPack(_e, details_type(), _resolver); }
}

inline flatbuffers::Offset<MessageHub> MessageHub::Pack(flatbuffers::FlatBufferBuilder &_fbb, const MessageHubT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateMessageHub(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<MessageHub> CreateMessageHub(flatbuffers::FlatBufferBuilder &_fbb, const MessageHubT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const MessageHubT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _id = _o->id;
  auto _details_type = _o->details.type;
  auto _details = _o->details.Pack(_fbb);
  return chre::fbs::CreateMessageHub(
      _fbb,
      _id,
      _details_type,
      _details);
}

inline RegisterMessageHubT *RegisterMessageHub::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  std::unique_ptr<chre::fbs::RegisterMessageHubT> _o = std::unique_ptr<chre::fbs::RegisterMessageHubT>(new RegisterMessageHubT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void RegisterMessageHub::UnPackTo(RegisterMessageHubT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = hub(); if (_e) _o->hub = std::unique_ptr<chre::fbs::MessageHubT>(_e->UnPack(_resolver)); }
}

inline flatbuffers::Offset<RegisterMessageHub> RegisterMessageHub::Pack(flatbuffers::FlatBufferBuilder &_fbb, const RegisterMessageHubT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateRegisterMessageHub(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<RegisterMessageHub> CreateRegisterMessageHub(flatbuffers::FlatBufferBuilder &_fbb, const RegisterMessageHubT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const RegisterMessageHubT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _hub = _o->hub ? CreateMessageHub(_fbb, _o->hub.get(), _rehasher) : 0;
  return chre::fbs::CreateRegisterMessageHub(
      _fbb,
      _hub);
}

inline UnregisterMessageHubT *UnregisterMessageHub::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  std::unique_ptr<chre::fbs::UnregisterMessageHubT> _o = std::unique_ptr<chre::fbs::UnregisterMessageHubT>(new UnregisterMessageHubT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void UnregisterMessageHub::UnPackTo(UnregisterMessageHubT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = id(); _o->id = _e; }
}

inline flatbuffers::Offset<UnregisterMessageHub> UnregisterMessageHub::Pack(flatbuffers::FlatBufferBuilder &_fbb, const UnregisterMessageHubT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateUnregisterMessageHub(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<UnregisterMessageHub> CreateUnregisterMessageHub(flatbuffers::FlatBufferBuilder &_fbb, const UnregisterMessageHubT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const UnregisterMessageHubT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _id = _o->id;
  return chre::fbs::CreateUnregisterMessageHub(
      _fbb,
      _id);
}

inline EndpointIdT *EndpointId::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  std::unique_ptr<chre::fbs::EndpointIdT> _o = std::unique_ptr<chre::fbs::EndpointIdT>(new EndpointIdT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void EndpointId::UnPackTo(EndpointIdT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = hubId(); _o->hubId = _e; }
  { auto _e = id(); _o->id = _e; }
}

inline flatbuffers::Offset<EndpointId> EndpointId::Pack(flatbuffers::FlatBufferBuilder &_fbb, const EndpointIdT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateEndpointId(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<EndpointId> CreateEndpointId(flatbuffers::FlatBufferBuilder &_fbb, const EndpointIdT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const EndpointIdT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _hubId = _o->hubId;
  auto _id = _o->id;
  return chre::fbs::CreateEndpointId(
      _fbb,
      _hubId,
      _id);
}

inline ServiceT *Service::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  std::unique_ptr<chre::fbs::ServiceT> _o = std::unique_ptr<chre::fbs::ServiceT>(new ServiceT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void Service::UnPackTo(ServiceT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = format(); _o->format = _e; }
  { auto _e = descriptor(); if (_e) { _o->descriptor.resize(_e->size()); for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->descriptor[_i] = _e->Get(_i); } } }
  { auto _e = major_version(); _o->major_version = _e; }
  { auto _e = minor_version(); _o->minor_version = _e; }
}

inline flatbuffers::Offset<Service> Service::Pack(flatbuffers::FlatBufferBuilder &_fbb, const ServiceT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateService(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<Service> CreateService(flatbuffers::FlatBufferBuilder &_fbb, const ServiceT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const ServiceT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _format = _o->format;
  auto _descriptor = _o->descriptor.size() ? _fbb.CreateVector(_o->descriptor) : 0;
  auto _major_version = _o->major_version;
  auto _minor_version = _o->minor_version;
  return chre::fbs::CreateService(
      _fbb,
      _format,
      _descriptor,
      _major_version,
      _minor_version);
}

inline EndpointInfoT *EndpointInfo::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  std::unique_ptr<chre::fbs::EndpointInfoT> _o = std::unique_ptr<chre::fbs::EndpointInfoT>(new EndpointInfoT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void EndpointInfo::UnPackTo(EndpointInfoT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = id(); if (_e) _o->id = std::unique_ptr<chre::fbs::EndpointIdT>(_e->UnPack(_resolver)); }
  { auto _e = type(); _o->type = _e; }
  { auto _e = name(); if (_e) { _o->name.resize(_e->size()); for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->name[_i] = _e->Get(_i); } } }
  { auto _e = version(); _o->version = _e; }
  { auto _e = required_permissions(); _o->required_permissions = _e; }
  { auto _e = services(); if (_e) { _o->services.resize(_e->size()); for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->services[_i] = std::unique_ptr<chre::fbs::ServiceT>(_e->Get(_i)->UnPack(_resolver)); } } }
}

inline flatbuffers::Offset<EndpointInfo> EndpointInfo::Pack(flatbuffers::FlatBufferBuilder &_fbb, const EndpointInfoT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateEndpointInfo(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<EndpointInfo> CreateEndpointInfo(flatbuffers::FlatBufferBuilder &_fbb, const EndpointInfoT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const EndpointInfoT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _id = _o->id ? CreateEndpointId(_fbb, _o->id.get(), _rehasher) : 0;
  auto _type = _o->type;
  auto _name = _o->name.size() ? _fbb.CreateVector(_o->name) : 0;
  auto _version = _o->version;
  auto _required_permissions = _o->required_permissions;
  auto _services = _o->services.size() ? _fbb.CreateVector<flatbuffers::Offset<chre::fbs::Service>> (_o->services.size(), [](size_t i, _VectorArgs *__va) { return CreateService(*__va->__fbb, __va->__o->services[i].get(), __va->__rehasher); }, &_va ) : 0;
  return chre::fbs::CreateEndpointInfo(
      _fbb,
      _id,
      _type,
      _name,
      _version,
      _required_permissions,
      _services);
}

inline RegisterEndpointT *RegisterEndpoint::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  std::unique_ptr<chre::fbs::RegisterEndpointT> _o = std::unique_ptr<chre::fbs::RegisterEndpointT>(new RegisterEndpointT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void RegisterEndpoint::UnPackTo(RegisterEndpointT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = endpoint(); if (_e) _o->endpoint = std::unique_ptr<chre::fbs::EndpointInfoT>(_e->UnPack(_resolver)); }
}

inline flatbuffers::Offset<RegisterEndpoint> RegisterEndpoint::Pack(flatbuffers::FlatBufferBuilder &_fbb, const RegisterEndpointT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateRegisterEndpoint(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<RegisterEndpoint> CreateRegisterEndpoint(flatbuffers::FlatBufferBuilder &_fbb, const RegisterEndpointT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const RegisterEndpointT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _endpoint = _o->endpoint ? CreateEndpointInfo(_fbb, _o->endpoint.get(), _rehasher) : 0;
  return chre::fbs::CreateRegisterEndpoint(
      _fbb,
      _endpoint);
}

inline AddServiceToEndpointT *AddServiceToEndpoint::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  std::unique_ptr<chre::fbs::AddServiceToEndpointT> _o = std::unique_ptr<chre::fbs::AddServiceToEndpointT>(new AddServiceToEndpointT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void AddServiceToEndpoint::UnPackTo(AddServiceToEndpointT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = endpoint(); if (_e) _o->endpoint = std::unique_ptr<chre::fbs::EndpointIdT>(_e->UnPack(_resolver)); }
  { auto _e = service(); if (_e) _o->service = std::unique_ptr<chre::fbs::ServiceT>(_e->UnPack(_resolver)); }
}

inline flatbuffers::Offset<AddServiceToEndpoint> AddServiceToEndpoint::Pack(flatbuffers::FlatBufferBuilder &_fbb, const AddServiceToEndpointT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateAddServiceToEndpoint(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<AddServiceToEndpoint> CreateAddServiceToEndpoint(flatbuffers::FlatBufferBuilder &_fbb, const AddServiceToEndpointT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const AddServiceToEndpointT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _endpoint = _o->endpoint ? CreateEndpointId(_fbb, _o->endpoint.get(), _rehasher) : 0;
  auto _service = _o->service ? CreateService(_fbb, _o->service.get(), _rehasher) : 0;
  return chre::fbs::CreateAddServiceToEndpoint(
      _fbb,
      _endpoint,
      _service);
}

inline EndpointReadyT *EndpointReady::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  std::unique_ptr<chre::fbs::EndpointReadyT> _o = std::unique_ptr<chre::fbs::EndpointReadyT>(new EndpointReadyT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void EndpointReady::UnPackTo(EndpointReadyT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = endpoint(); if (_e) _o->endpoint = std::unique_ptr<chre::fbs::EndpointIdT>(_e->UnPack(_resolver)); }
}

inline flatbuffers::Offset<EndpointReady> EndpointReady::Pack(flatbuffers::FlatBufferBuilder &_fbb, const EndpointReadyT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateEndpointReady(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<EndpointReady> CreateEndpointReady(flatbuffers::FlatBufferBuilder &_fbb, const EndpointReadyT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const EndpointReadyT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _endpoint = _o->endpoint ? CreateEndpointId(_fbb, _o->endpoint.get(), _rehasher) : 0;
  return chre::fbs::CreateEndpointReady(
      _fbb,
      _endpoint);
}

inline UnregisterEndpointT *UnregisterEndpoint::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  std::unique_ptr<chre::fbs::UnregisterEndpointT> _o = std::unique_ptr<chre::fbs::UnregisterEndpointT>(new UnregisterEndpointT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void UnregisterEndpoint::UnPackTo(UnregisterEndpointT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = endpoint(); if (_e) _o->endpoint = std::unique_ptr<chre::fbs::EndpointIdT>(_e->UnPack(_resolver)); }
}

inline flatbuffers::Offset<UnregisterEndpoint> UnregisterEndpoint::Pack(flatbuffers::FlatBufferBuilder &_fbb, const UnregisterEndpointT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateUnregisterEndpoint(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<UnregisterEndpoint> CreateUnregisterEndpoint(flatbuffers::FlatBufferBuilder &_fbb, const UnregisterEndpointT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const UnregisterEndpointT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _endpoint = _o->endpoint ? CreateEndpointId(_fbb, _o->endpoint.get(), _rehasher) : 0;
  return chre::fbs::CreateUnregisterEndpoint(
      _fbb,
      _endpoint);
}

inline GetMessageHubsAndEndpointsRequestT *GetMessageHubsAndEndpointsRequest::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  std::unique_ptr<chre::fbs::GetMessageHubsAndEndpointsRequestT> _o = std::unique_ptr<chre::fbs::GetMessageHubsAndEndpointsRequestT>(new GetMessageHubsAndEndpointsRequestT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void GetMessageHubsAndEndpointsRequest::UnPackTo(GetMessageHubsAndEndpointsRequestT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
}

inline flatbuffers::Offset<GetMessageHubsAndEndpointsRequest> GetMessageHubsAndEndpointsRequest::Pack(flatbuffers::FlatBufferBuilder &_fbb, const GetMessageHubsAndEndpointsRequestT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateGetMessageHubsAndEndpointsRequest(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<GetMessageHubsAndEndpointsRequest> CreateGetMessageHubsAndEndpointsRequest(flatbuffers::FlatBufferBuilder &_fbb, const GetMessageHubsAndEndpointsRequestT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const GetMessageHubsAndEndpointsRequestT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  return chre::fbs::CreateGetMessageHubsAndEndpointsRequest(
      _fbb);
}

inline GetMessageHubsAndEndpointsResponseT *GetMessageHubsAndEndpointsResponse::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  std::unique_ptr<chre::fbs::GetMessageHubsAndEndpointsResponseT> _o = std::unique_ptr<chre::fbs::GetMessageHubsAndEndpointsResponseT>(new GetMessageHubsAndEndpointsResponseT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void GetMessageHubsAndEndpointsResponse::UnPackTo(GetMessageHubsAndEndpointsResponseT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = hubs(); if (_e) { _o->hubs.resize(_e->size()); for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->hubs[_i] = std::unique_ptr<chre::fbs::MessageHubT>(_e->Get(_i)->UnPack(_resolver)); } } }
  { auto _e = endpoints(); if (_e) { _o->endpoints.resize(_e->size()); for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->endpoints[_i] = std::unique_ptr<chre::fbs::EndpointInfoT>(_e->Get(_i)->UnPack(_resolver)); } } }
}

inline flatbuffers::Offset<GetMessageHubsAndEndpointsResponse> GetMessageHubsAndEndpointsResponse::Pack(flatbuffers::FlatBufferBuilder &_fbb, const GetMessageHubsAndEndpointsResponseT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateGetMessageHubsAndEndpointsResponse(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<GetMessageHubsAndEndpointsResponse> CreateGetMessageHubsAndEndpointsResponse(flatbuffers::FlatBufferBuilder &_fbb, const GetMessageHubsAndEndpointsResponseT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const GetMessageHubsAndEndpointsResponseT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _hubs = _o->hubs.size() ? _fbb.CreateVector<flatbuffers::Offset<chre::fbs::MessageHub>> (_o->hubs.size(), [](size_t i, _VectorArgs *__va) { return CreateMessageHub(*__va->__fbb, __va->__o->hubs[i].get(), __va->__rehasher); }, &_va ) : 0;
  auto _endpoints = _o->endpoints.size() ? _fbb.CreateVector<flatbuffers::Offset<chre::fbs::EndpointInfo>> (_o->endpoints.size(), [](size_t i, _VectorArgs *__va) { return CreateEndpointInfo(*__va->__fbb, __va->__o->endpoints[i].get(), __va->__rehasher); }, &_va ) : 0;
  return chre::fbs::CreateGetMessageHubsAndEndpointsResponse(
      _fbb,
      _hubs,
      _endpoints);
}

inline OpenEndpointSessionRequestT *OpenEndpointSessionRequest::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  std::unique_ptr<chre::fbs::OpenEndpointSessionRequestT> _o = std::unique_ptr<chre::fbs::OpenEndpointSessionRequestT>(new OpenEndpointSessionRequestT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void OpenEndpointSessionRequest::UnPackTo(OpenEndpointSessionRequestT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = host_hub_id(); _o->host_hub_id = _e; }
  { auto _e = session_id(); _o->session_id = _e; }
  { auto _e = fromEndpoint(); if (_e) _o->fromEndpoint = std::unique_ptr<chre::fbs::EndpointIdT>(_e->UnPack(_resolver)); }
  { auto _e = toEndpoint(); if (_e) _o->toEndpoint = std::unique_ptr<chre::fbs::EndpointIdT>(_e->UnPack(_resolver)); }
  { auto _e = serviceDescriptor(); if (_e) { _o->serviceDescriptor.resize(_e->size()); for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->serviceDescriptor[_i] = _e->Get(_i); } } }
}

inline flatbuffers::Offset<OpenEndpointSessionRequest> OpenEndpointSessionRequest::Pack(flatbuffers::FlatBufferBuilder &_fbb, const OpenEndpointSessionRequestT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateOpenEndpointSessionRequest(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<OpenEndpointSessionRequest> CreateOpenEndpointSessionRequest(flatbuffers::FlatBufferBuilder &_fbb, const OpenEndpointSessionRequestT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const OpenEndpointSessionRequestT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _host_hub_id = _o->host_hub_id;
  auto _session_id = _o->session_id;
  auto _fromEndpoint = _o->fromEndpoint ? CreateEndpointId(_fbb, _o->fromEndpoint.get(), _rehasher) : 0;
  auto _toEndpoint = _o->toEndpoint ? CreateEndpointId(_fbb, _o->toEndpoint.get(), _rehasher) : 0;
  auto _serviceDescriptor = _o->serviceDescriptor.size() ? _fbb.CreateVector(_o->serviceDescriptor) : 0;
  return chre::fbs::CreateOpenEndpointSessionRequest(
      _fbb,
      _host_hub_id,
      _session_id,
      _fromEndpoint,
      _toEndpoint,
      _serviceDescriptor);
}

inline EndpointSessionOpenedT *EndpointSessionOpened::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  std::unique_ptr<chre::fbs::EndpointSessionOpenedT> _o = std::unique_ptr<chre::fbs::EndpointSessionOpenedT>(new EndpointSessionOpenedT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void EndpointSessionOpened::UnPackTo(EndpointSessionOpenedT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = host_hub_id(); _o->host_hub_id = _e; }
  { auto _e = session_id(); _o->session_id = _e; }
}

inline flatbuffers::Offset<EndpointSessionOpened> EndpointSessionOpened::Pack(flatbuffers::FlatBufferBuilder &_fbb, const EndpointSessionOpenedT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateEndpointSessionOpened(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<EndpointSessionOpened> CreateEndpointSessionOpened(flatbuffers::FlatBufferBuilder &_fbb, const EndpointSessionOpenedT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const EndpointSessionOpenedT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _host_hub_id = _o->host_hub_id;
  auto _session_id = _o->session_id;
  return chre::fbs::CreateEndpointSessionOpened(
      _fbb,
      _host_hub_id,
      _session_id);
}

inline EndpointSessionClosedT *EndpointSessionClosed::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  std::unique_ptr<chre::fbs::EndpointSessionClosedT> _o = std::unique_ptr<chre::fbs::EndpointSessionClosedT>(new EndpointSessionClosedT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void EndpointSessionClosed::UnPackTo(EndpointSessionClosedT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = host_hub_id(); _o->host_hub_id = _e; }
  { auto _e = session_id(); _o->session_id = _e; }
  { auto _e = reason(); _o->reason = _e; }
}

inline flatbuffers::Offset<EndpointSessionClosed> EndpointSessionClosed::Pack(flatbuffers::FlatBufferBuilder &_fbb, const EndpointSessionClosedT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateEndpointSessionClosed(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<EndpointSessionClosed> CreateEndpointSessionClosed(flatbuffers::FlatBufferBuilder &_fbb, const EndpointSessionClosedT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const EndpointSessionClosedT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _host_hub_id = _o->host_hub_id;
  auto _session_id = _o->session_id;
  auto _reason = _o->reason;
  return chre::fbs::CreateEndpointSessionClosed(
      _fbb,
      _host_hub_id,
      _session_id,
      _reason);
}

inline EndpointSessionMessageT *EndpointSessionMessage::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  std::unique_ptr<chre::fbs::EndpointSessionMessageT> _o = std::unique_ptr<chre::fbs::EndpointSessionMessageT>(new EndpointSessionMessageT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void EndpointSessionMessage::UnPackTo(EndpointSessionMessageT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = host_hub_id(); _o->host_hub_id = _e; }
  { auto _e = session_id(); _o->session_id = _e; }
  { auto _e = type(); _o->type = _e; }
  { auto _e = permissions(); _o->permissions = _e; }
  { auto _e = data(); if (_e) { _o->data.resize(_e->size()); for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->data[_i] = _e->Get(_i); } } }
  { auto _e = flags(); _o->flags = _e; }
  { auto _e = sequence_number(); _o->sequence_number = _e; }
}

inline flatbuffers::Offset<EndpointSessionMessage> EndpointSessionMessage::Pack(flatbuffers::FlatBufferBuilder &_fbb, const EndpointSessionMessageT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateEndpointSessionMessage(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<EndpointSessionMessage> CreateEndpointSessionMessage(flatbuffers::FlatBufferBuilder &_fbb, const EndpointSessionMessageT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const EndpointSessionMessageT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _host_hub_id = _o->host_hub_id;
  auto _session_id = _o->session_id;
  auto _type = _o->type;
  auto _permissions = _o->permissions;
  auto _data = _o->data.size() ? _fbb.CreateVector(_o->data) : 0;
  auto _flags = _o->flags;
  auto _sequence_number = _o->sequence_number;
  return chre::fbs::CreateEndpointSessionMessage(
      _fbb,
      _host_hub_id,
      _session_id,
      _type,
      _permissions,
      _data,
      _flags,
      _sequence_number);
}

inline EndpointSessionMessageDeliveryStatusT *EndpointSessionMessageDeliveryStatus::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  std::unique_ptr<chre::fbs::EndpointSessionMessageDeliveryStatusT> _o = std::unique_ptr<chre::fbs::EndpointSessionMessageDeliveryStatusT>(new EndpointSessionMessageDeliveryStatusT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void EndpointSessionMessageDeliveryStatus::UnPackTo(EndpointSessionMessageDeliveryStatusT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = host_hub_id(); _o->host_hub_id = _e; }
  { auto _e = session_id(); _o->session_id = _e; }
  { auto _e = status(); if (_e) _o->status = std::unique_ptr<chre::fbs::MessageDeliveryStatusT>(_e->UnPack(_resolver)); }
}

inline flatbuffers::Offset<EndpointSessionMessageDeliveryStatus> EndpointSessionMessageDeliveryStatus::Pack(flatbuffers::FlatBufferBuilder &_fbb, const EndpointSessionMessageDeliveryStatusT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateEndpointSessionMessageDeliveryStatus(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<EndpointSessionMessageDeliveryStatus> CreateEndpointSessionMessageDeliveryStatus(flatbuffers::FlatBufferBuilder &_fbb, const EndpointSessionMessageDeliveryStatusT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const EndpointSessionMessageDeliveryStatusT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _host_hub_id = _o->host_hub_id;
  auto _session_id = _o->session_id;
  auto _status = _o->status ? CreateMessageDeliveryStatus(_fbb, _o->status.get(), _rehasher) : 0;
  return chre::fbs::CreateEndpointSessionMessageDeliveryStatus(
      _fbb,
      _host_hub_id,
      _session_id,
      _status);
}

inline MessageContainerT *MessageContainer::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  std::unique_ptr<chre::fbs::MessageContainerT> _o = std::unique_ptr<chre::fbs::MessageContainerT>(new MessageContainerT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void MessageContainer::UnPackTo(MessageContainerT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = message_type(); _o->message.type = _e; }
  { auto _e = message(); if (_e) _o->message.value = chre::fbs::ChreMessageUnion::UnPack(_e, message_type(), _resolver); }
  { auto _e = host_addr(); if (_e) _o->host_addr = std::unique_ptr<chre::fbs::HostAddress>(new chre::fbs::HostAddress(*_e)); }
}

inline flatbuffers::Offset<MessageContainer> MessageContainer::Pack(flatbuffers::FlatBufferBuilder &_fbb, const MessageContainerT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateMessageContainer(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<MessageContainer> CreateMessageContainer(flatbuffers::FlatBufferBuilder &_fbb, const MessageContainerT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const MessageContainerT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _message_type = _o->message.type;
  auto _message = _o->message.Pack(_fbb);
  auto _host_addr = _o->host_addr ? _o->host_addr.get() : 0;
  return chre::fbs::CreateMessageContainer(
      _fbb,
      _message_type,
      _message,
      _host_addr);
}

inline bool VerifyChannelInfo(flatbuffers::Verifier &verifier, const void *obj, ChannelInfo type) {
  switch (type) {
    case ChannelInfo::NONE: {
      return true;
    }
    case ChannelInfo::LeCocChannelInfo: {
      auto ptr = reinterpret_cast<const chre::fbs::LeCocChannelInfo *>(obj);
      return verifier.VerifyTable(ptr);
    }
    default: return true;
  }
}

inline bool VerifyChannelInfoVector(flatbuffers::Verifier &verifier, const flatbuffers::Vector<flatbuffers::Offset<void>> *values, const flatbuffers::Vector<uint8_t> *types) {
  if (!values || !types) return !values && !types;
  if (values->size() != types->size()) return false;
  for (flatbuffers::uoffset_t i = 0; i < values->size(); ++i) {
    if (!VerifyChannelInfo(
        verifier,  values->Get(i), types->GetEnum<ChannelInfo>(i))) {
      return false;
    }
  }
  return true;
}

inline void *ChannelInfoUnion::UnPack(const void *obj, ChannelInfo type, const flatbuffers::resolver_function_t *resolver) {
  switch (type) {
    case ChannelInfo::LeCocChannelInfo: {
      auto ptr = reinterpret_cast<const chre::fbs::LeCocChannelInfo *>(obj);
      return ptr->UnPack(resolver);
    }
    default: return nullptr;
  }
}

inline flatbuffers::Offset<void> ChannelInfoUnion::Pack(flatbuffers::FlatBufferBuilder &_fbb, const flatbuffers::rehasher_function_t *_rehasher) const {
  switch (type) {
    case ChannelInfo::LeCocChannelInfo: {
      auto ptr = reinterpret_cast<const chre::fbs::LeCocChannelInfoT *>(value);
      return CreateLeCocChannelInfo(_fbb, ptr, _rehasher).Union();
    }
    default: return 0;
  }
}

inline ChannelInfoUnion::ChannelInfoUnion(const ChannelInfoUnion &u) : type(u.type), value(nullptr) {
  switch (type) {
    case ChannelInfo::LeCocChannelInfo: {
      value = new chre::fbs::LeCocChannelInfoT(*reinterpret_cast<chre::fbs::LeCocChannelInfoT *>(u.value));
      break;
    }
    default:
      break;
  }
}

inline void ChannelInfoUnion::Reset() {
  switch (type) {
    case ChannelInfo::LeCocChannelInfo: {
      auto ptr = reinterpret_cast<chre::fbs::LeCocChannelInfoT *>(value);
      delete ptr;
      break;
    }
    default: break;
  }
  value = nullptr;
  type = ChannelInfo::NONE;
}

inline bool VerifyMessageHubDetails(flatbuffers::Verifier &verifier, const void *obj, MessageHubDetails type) {
  switch (type) {
    case MessageHubDetails::NONE: {
      return true;
    }
    case MessageHubDetails::HubInfoResponse: {
      auto ptr = reinterpret_cast<const chre::fbs::HubInfoResponse *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case MessageHubDetails::VendorHubInfo: {
      auto ptr = reinterpret_cast<const chre::fbs::VendorHubInfo *>(obj);
      return verifier.VerifyTable(ptr);
    }
    default: return true;
  }
}

inline bool VerifyMessageHubDetailsVector(flatbuffers::Verifier &verifier, const flatbuffers::Vector<flatbuffers::Offset<void>> *values, const flatbuffers::Vector<uint8_t> *types) {
  if (!values || !types) return !values && !types;
  if (values->size() != types->size()) return false;
  for (flatbuffers::uoffset_t i = 0; i < values->size(); ++i) {
    if (!VerifyMessageHubDetails(
        verifier,  values->Get(i), types->GetEnum<MessageHubDetails>(i))) {
      return false;
    }
  }
  return true;
}

inline void *MessageHubDetailsUnion::UnPack(const void *obj, MessageHubDetails type, const flatbuffers::resolver_function_t *resolver) {
  switch (type) {
    case MessageHubDetails::HubInfoResponse: {
      auto ptr = reinterpret_cast<const chre::fbs::HubInfoResponse *>(obj);
      return ptr->UnPack(resolver);
    }
    case MessageHubDetails::VendorHubInfo: {
      auto ptr = reinterpret_cast<const chre::fbs::VendorHubInfo *>(obj);
      return ptr->UnPack(resolver);
    }
    default: return nullptr;
  }
}

inline flatbuffers::Offset<void> MessageHubDetailsUnion::Pack(flatbuffers::FlatBufferBuilder &_fbb, const flatbuffers::rehasher_function_t *_rehasher) const {
  switch (type) {
    case MessageHubDetails::HubInfoResponse: {
      auto ptr = reinterpret_cast<const chre::fbs::HubInfoResponseT *>(value);
      return CreateHubInfoResponse(_fbb, ptr, _rehasher).Union();
    }
    case MessageHubDetails::VendorHubInfo: {
      auto ptr = reinterpret_cast<const chre::fbs::VendorHubInfoT *>(value);
      return CreateVendorHubInfo(_fbb, ptr, _rehasher).Union();
    }
    default: return 0;
  }
}

inline MessageHubDetailsUnion::MessageHubDetailsUnion(const MessageHubDetailsUnion &u) : type(u.type), value(nullptr) {
  switch (type) {
    case MessageHubDetails::HubInfoResponse: {
      value = new chre::fbs::HubInfoResponseT(*reinterpret_cast<chre::fbs::HubInfoResponseT *>(u.value));
      break;
    }
    case MessageHubDetails::VendorHubInfo: {
      value = new chre::fbs::VendorHubInfoT(*reinterpret_cast<chre::fbs::VendorHubInfoT *>(u.value));
      break;
    }
    default:
      break;
  }
}

inline void MessageHubDetailsUnion::Reset() {
  switch (type) {
    case MessageHubDetails::HubInfoResponse: {
      auto ptr = reinterpret_cast<chre::fbs::HubInfoResponseT *>(value);
      delete ptr;
      break;
    }
    case MessageHubDetails::VendorHubInfo: {
      auto ptr = reinterpret_cast<chre::fbs::VendorHubInfoT *>(value);
      delete ptr;
      break;
    }
    default: break;
  }
  value = nullptr;
  type = MessageHubDetails::NONE;
}

inline bool VerifyChreMessage(flatbuffers::Verifier &verifier, const void *obj, ChreMessage type) {
  switch (type) {
    case ChreMessage::NONE: {
      return true;
    }
    case ChreMessage::NanoappMessage: {
      auto ptr = reinterpret_cast<const chre::fbs::NanoappMessage *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case ChreMessage::HubInfoRequest: {
      auto ptr = reinterpret_cast<const chre::fbs::HubInfoRequest *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case ChreMessage::HubInfoResponse: {
      auto ptr = reinterpret_cast<const chre::fbs::HubInfoResponse *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case ChreMessage::NanoappListRequest: {
      auto ptr = reinterpret_cast<const chre::fbs::NanoappListRequest *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case ChreMessage::NanoappListResponse: {
      auto ptr = reinterpret_cast<const chre::fbs::NanoappListResponse *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case ChreMessage::LoadNanoappRequest: {
      auto ptr = reinterpret_cast<const chre::fbs::LoadNanoappRequest *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case ChreMessage::LoadNanoappResponse: {
      auto ptr = reinterpret_cast<const chre::fbs::LoadNanoappResponse *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case ChreMessage::UnloadNanoappRequest: {
      auto ptr = reinterpret_cast<const chre::fbs::UnloadNanoappRequest *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case ChreMessage::UnloadNanoappResponse: {
      auto ptr = reinterpret_cast<const chre::fbs::UnloadNanoappResponse *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case ChreMessage::LogMessage: {
      auto ptr = reinterpret_cast<const chre::fbs::LogMessage *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case ChreMessage::TimeSyncMessage: {
      auto ptr = reinterpret_cast<const chre::fbs::TimeSyncMessage *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case ChreMessage::DebugDumpRequest: {
      auto ptr = reinterpret_cast<const chre::fbs::DebugDumpRequest *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case ChreMessage::DebugDumpData: {
      auto ptr = reinterpret_cast<const chre::fbs::DebugDumpData *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case ChreMessage::DebugDumpResponse: {
      auto ptr = reinterpret_cast<const chre::fbs::DebugDumpResponse *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case ChreMessage::TimeSyncRequest: {
      auto ptr = reinterpret_cast<const chre::fbs::TimeSyncRequest *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case ChreMessage::LowPowerMicAccessRequest: {
      auto ptr = reinterpret_cast<const chre::fbs::LowPowerMicAccessRequest *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case ChreMessage::LowPowerMicAccessRelease: {
      auto ptr = reinterpret_cast<const chre::fbs::LowPowerMicAccessRelease *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case ChreMessage::SettingChangeMessage: {
      auto ptr = reinterpret_cast<const chre::fbs::SettingChangeMessage *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case ChreMessage::LogMessageV2: {
      auto ptr = reinterpret_cast<const chre::fbs::LogMessageV2 *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case ChreMessage::SelfTestRequest: {
      auto ptr = reinterpret_cast<const chre::fbs::SelfTestRequest *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case ChreMessage::SelfTestResponse: {
      auto ptr = reinterpret_cast<const chre::fbs::SelfTestResponse *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case ChreMessage::HostEndpointConnected: {
      auto ptr = reinterpret_cast<const chre::fbs::HostEndpointConnected *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case ChreMessage::HostEndpointDisconnected: {
      auto ptr = reinterpret_cast<const chre::fbs::HostEndpointDisconnected *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case ChreMessage::MetricLog: {
      auto ptr = reinterpret_cast<const chre::fbs::MetricLog *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case ChreMessage::BatchedMetricLog: {
      auto ptr = reinterpret_cast<const chre::fbs::BatchedMetricLog *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case ChreMessage::NanConfigurationRequest: {
      auto ptr = reinterpret_cast<const chre::fbs::NanConfigurationRequest *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case ChreMessage::NanConfigurationUpdate: {
      auto ptr = reinterpret_cast<const chre::fbs::NanConfigurationUpdate *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case ChreMessage::DebugConfiguration: {
      auto ptr = reinterpret_cast<const chre::fbs::DebugConfiguration *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case ChreMessage::PulseRequest: {
      auto ptr = reinterpret_cast<const chre::fbs::PulseRequest *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case ChreMessage::PulseResponse: {
      auto ptr = reinterpret_cast<const chre::fbs::PulseResponse *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case ChreMessage::NanoappTokenDatabaseInfo: {
      auto ptr = reinterpret_cast<const chre::fbs::NanoappTokenDatabaseInfo *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case ChreMessage::MessageDeliveryStatus: {
      auto ptr = reinterpret_cast<const chre::fbs::MessageDeliveryStatus *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case ChreMessage::BtSocketOpen: {
      auto ptr = reinterpret_cast<const chre::fbs::BtSocketOpen *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case ChreMessage::BtSocketOpenResponse: {
      auto ptr = reinterpret_cast<const chre::fbs::BtSocketOpenResponse *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case ChreMessage::BtSocketClose: {
      auto ptr = reinterpret_cast<const chre::fbs::BtSocketClose *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case ChreMessage::BtSocketCloseResponse: {
      auto ptr = reinterpret_cast<const chre::fbs::BtSocketCloseResponse *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case ChreMessage::GetMessageHubsAndEndpointsRequest: {
      auto ptr = reinterpret_cast<const chre::fbs::GetMessageHubsAndEndpointsRequest *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case ChreMessage::GetMessageHubsAndEndpointsResponse: {
      auto ptr = reinterpret_cast<const chre::fbs::GetMessageHubsAndEndpointsResponse *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case ChreMessage::RegisterMessageHub: {
      auto ptr = reinterpret_cast<const chre::fbs::RegisterMessageHub *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case ChreMessage::UnregisterMessageHub: {
      auto ptr = reinterpret_cast<const chre::fbs::UnregisterMessageHub *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case ChreMessage::RegisterEndpoint: {
      auto ptr = reinterpret_cast<const chre::fbs::RegisterEndpoint *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case ChreMessage::UnregisterEndpoint: {
      auto ptr = reinterpret_cast<const chre::fbs::UnregisterEndpoint *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case ChreMessage::OpenEndpointSessionRequest: {
      auto ptr = reinterpret_cast<const chre::fbs::OpenEndpointSessionRequest *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case ChreMessage::EndpointSessionOpened: {
      auto ptr = reinterpret_cast<const chre::fbs::EndpointSessionOpened *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case ChreMessage::EndpointSessionClosed: {
      auto ptr = reinterpret_cast<const chre::fbs::EndpointSessionClosed *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case ChreMessage::EndpointSessionMessage: {
      auto ptr = reinterpret_cast<const chre::fbs::EndpointSessionMessage *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case ChreMessage::EndpointSessionMessageDeliveryStatus: {
      auto ptr = reinterpret_cast<const chre::fbs::EndpointSessionMessageDeliveryStatus *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case ChreMessage::BtSocketCapabilitiesRequest: {
      auto ptr = reinterpret_cast<const chre::fbs::BtSocketCapabilitiesRequest *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case ChreMessage::BtSocketCapabilitiesResponse: {
      auto ptr = reinterpret_cast<const chre::fbs::BtSocketCapabilitiesResponse *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case ChreMessage::AddServiceToEndpoint: {
      auto ptr = reinterpret_cast<const chre::fbs::AddServiceToEndpoint *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case ChreMessage::EndpointReady: {
      auto ptr = reinterpret_cast<const chre::fbs::EndpointReady *>(obj);
      return verifier.VerifyTable(ptr);
    }
    default: return true;
  }
}

inline bool VerifyChreMessageVector(flatbuffers::Verifier &verifier, const flatbuffers::Vector<flatbuffers::Offset<void>> *values, const flatbuffers::Vector<uint8_t> *types) {
  if (!values || !types) return !values && !types;
  if (values->size() != types->size()) return false;
  for (flatbuffers::uoffset_t i = 0; i < values->size(); ++i) {
    if (!VerifyChreMessage(
        verifier,  values->Get(i), types->GetEnum<ChreMessage>(i))) {
      return false;
    }
  }
  return true;
}

inline void *ChreMessageUnion::UnPack(const void *obj, ChreMessage type, const flatbuffers::resolver_function_t *resolver) {
  switch (type) {
    case ChreMessage::NanoappMessage: {
      auto ptr = reinterpret_cast<const chre::fbs::NanoappMessage *>(obj);
      return ptr->UnPack(resolver);
    }
    case ChreMessage::HubInfoRequest: {
      auto ptr = reinterpret_cast<const chre::fbs::HubInfoRequest *>(obj);
      return ptr->UnPack(resolver);
    }
    case ChreMessage::HubInfoResponse: {
      auto ptr = reinterpret_cast<const chre::fbs::HubInfoResponse *>(obj);
      return ptr->UnPack(resolver);
    }
    case ChreMessage::NanoappListRequest: {
      auto ptr = reinterpret_cast<const chre::fbs::NanoappListRequest *>(obj);
      return ptr->UnPack(resolver);
    }
    case ChreMessage::NanoappListResponse: {
      auto ptr = reinterpret_cast<const chre::fbs::NanoappListResponse *>(obj);
      return ptr->UnPack(resolver);
    }
    case ChreMessage::LoadNanoappRequest: {
      auto ptr = reinterpret_cast<const chre::fbs::LoadNanoappRequest *>(obj);
      return ptr->UnPack(resolver);
    }
    case ChreMessage::LoadNanoappResponse: {
      auto ptr = reinterpret_cast<const chre::fbs::LoadNanoappResponse *>(obj);
      return ptr->UnPack(resolver);
    }
    case ChreMessage::UnloadNanoappRequest: {
      auto ptr = reinterpret_cast<const chre::fbs::UnloadNanoappRequest *>(obj);
      return ptr->UnPack(resolver);
    }
    case ChreMessage::UnloadNanoappResponse: {
      auto ptr = reinterpret_cast<const chre::fbs::UnloadNanoappResponse *>(obj);
      return ptr->UnPack(resolver);
    }
    case ChreMessage::LogMessage: {
      auto ptr = reinterpret_cast<const chre::fbs::LogMessage *>(obj);
      return ptr->UnPack(resolver);
    }
    case ChreMessage::TimeSyncMessage: {
      auto ptr = reinterpret_cast<const chre::fbs::TimeSyncMessage *>(obj);
      return ptr->UnPack(resolver);
    }
    case ChreMessage::DebugDumpRequest: {
      auto ptr = reinterpret_cast<const chre::fbs::DebugDumpRequest *>(obj);
      return ptr->UnPack(resolver);
    }
    case ChreMessage::DebugDumpData: {
      auto ptr = reinterpret_cast<const chre::fbs::DebugDumpData *>(obj);
      return ptr->UnPack(resolver);
    }
    case ChreMessage::DebugDumpResponse: {
      auto ptr = reinterpret_cast<const chre::fbs::DebugDumpResponse *>(obj);
      return ptr->UnPack(resolver);
    }
    case ChreMessage::TimeSyncRequest: {
      auto ptr = reinterpret_cast<const chre::fbs::TimeSyncRequest *>(obj);
      return ptr->UnPack(resolver);
    }
    case ChreMessage::LowPowerMicAccessRequest: {
      auto ptr = reinterpret_cast<const chre::fbs::LowPowerMicAccessRequest *>(obj);
      return ptr->UnPack(resolver);
    }
    case ChreMessage::LowPowerMicAccessRelease: {
      auto ptr = reinterpret_cast<const chre::fbs::LowPowerMicAccessRelease *>(obj);
      return ptr->UnPack(resolver);
    }
    case ChreMessage::SettingChangeMessage: {
      auto ptr = reinterpret_cast<const chre::fbs::SettingChangeMessage *>(obj);
      return ptr->UnPack(resolver);
    }
    case ChreMessage::LogMessageV2: {
      auto ptr = reinterpret_cast<const chre::fbs::LogMessageV2 *>(obj);
      return ptr->UnPack(resolver);
    }
    case ChreMessage::SelfTestRequest: {
      auto ptr = reinterpret_cast<const chre::fbs::SelfTestRequest *>(obj);
      return ptr->UnPack(resolver);
    }
    case ChreMessage::SelfTestResponse: {
      auto ptr = reinterpret_cast<const chre::fbs::SelfTestResponse *>(obj);
      return ptr->UnPack(resolver);
    }
    case ChreMessage::HostEndpointConnected: {
      auto ptr = reinterpret_cast<const chre::fbs::HostEndpointConnected *>(obj);
      return ptr->UnPack(resolver);
    }
    case ChreMessage::HostEndpointDisconnected: {
      auto ptr = reinterpret_cast<const chre::fbs::HostEndpointDisconnected *>(obj);
      return ptr->UnPack(resolver);
    }
    case ChreMessage::MetricLog: {
      auto ptr = reinterpret_cast<const chre::fbs::MetricLog *>(obj);
      return ptr->UnPack(resolver);
    }
    case ChreMessage::BatchedMetricLog: {
      auto ptr = reinterpret_cast<const chre::fbs::BatchedMetricLog *>(obj);
      return ptr->UnPack(resolver);
    }
    case ChreMessage::NanConfigurationRequest: {
      auto ptr = reinterpret_cast<const chre::fbs::NanConfigurationRequest *>(obj);
      return ptr->UnPack(resolver);
    }
    case ChreMessage::NanConfigurationUpdate: {
      auto ptr = reinterpret_cast<const chre::fbs::NanConfigurationUpdate *>(obj);
      return ptr->UnPack(resolver);
    }
    case ChreMessage::DebugConfiguration: {
      auto ptr = reinterpret_cast<const chre::fbs::DebugConfiguration *>(obj);
      return ptr->UnPack(resolver);
    }
    case ChreMessage::PulseRequest: {
      auto ptr = reinterpret_cast<const chre::fbs::PulseRequest *>(obj);
      return ptr->UnPack(resolver);
    }
    case ChreMessage::PulseResponse: {
      auto ptr = reinterpret_cast<const chre::fbs::PulseResponse *>(obj);
      return ptr->UnPack(resolver);
    }
    case ChreMessage::NanoappTokenDatabaseInfo: {
      auto ptr = reinterpret_cast<const chre::fbs::NanoappTokenDatabaseInfo *>(obj);
      return ptr->UnPack(resolver);
    }
    case ChreMessage::MessageDeliveryStatus: {
      auto ptr = reinterpret_cast<const chre::fbs::MessageDeliveryStatus *>(obj);
      return ptr->UnPack(resolver);
    }
    case ChreMessage::BtSocketOpen: {
      auto ptr = reinterpret_cast<const chre::fbs::BtSocketOpen *>(obj);
      return ptr->UnPack(resolver);
    }
    case ChreMessage::BtSocketOpenResponse: {
      auto ptr = reinterpret_cast<const chre::fbs::BtSocketOpenResponse *>(obj);
      return ptr->UnPack(resolver);
    }
    case ChreMessage::BtSocketClose: {
      auto ptr = reinterpret_cast<const chre::fbs::BtSocketClose *>(obj);
      return ptr->UnPack(resolver);
    }
    case ChreMessage::BtSocketCloseResponse: {
      auto ptr = reinterpret_cast<const chre::fbs::BtSocketCloseResponse *>(obj);
      return ptr->UnPack(resolver);
    }
    case ChreMessage::GetMessageHubsAndEndpointsRequest: {
      auto ptr = reinterpret_cast<const chre::fbs::GetMessageHubsAndEndpointsRequest *>(obj);
      return ptr->UnPack(resolver);
    }
    case ChreMessage::GetMessageHubsAndEndpointsResponse: {
      auto ptr = reinterpret_cast<const chre::fbs::GetMessageHubsAndEndpointsResponse *>(obj);
      return ptr->UnPack(resolver);
    }
    case ChreMessage::RegisterMessageHub: {
      auto ptr = reinterpret_cast<const chre::fbs::RegisterMessageHub *>(obj);
      return ptr->UnPack(resolver);
    }
    case ChreMessage::UnregisterMessageHub: {
      auto ptr = reinterpret_cast<const chre::fbs::UnregisterMessageHub *>(obj);
      return ptr->UnPack(resolver);
    }
    case ChreMessage::RegisterEndpoint: {
      auto ptr = reinterpret_cast<const chre::fbs::RegisterEndpoint *>(obj);
      return ptr->UnPack(resolver);
    }
    case ChreMessage::UnregisterEndpoint: {
      auto ptr = reinterpret_cast<const chre::fbs::UnregisterEndpoint *>(obj);
      return ptr->UnPack(resolver);
    }
    case ChreMessage::OpenEndpointSessionRequest: {
      auto ptr = reinterpret_cast<const chre::fbs::OpenEndpointSessionRequest *>(obj);
      return ptr->UnPack(resolver);
    }
    case ChreMessage::EndpointSessionOpened: {
      auto ptr = reinterpret_cast<const chre::fbs::EndpointSessionOpened *>(obj);
      return ptr->UnPack(resolver);
    }
    case ChreMessage::EndpointSessionClosed: {
      auto ptr = reinterpret_cast<const chre::fbs::EndpointSessionClosed *>(obj);
      return ptr->UnPack(resolver);
    }
    case ChreMessage::EndpointSessionMessage: {
      auto ptr = reinterpret_cast<const chre::fbs::EndpointSessionMessage *>(obj);
      return ptr->UnPack(resolver);
    }
    case ChreMessage::EndpointSessionMessageDeliveryStatus: {
      auto ptr = reinterpret_cast<const chre::fbs::EndpointSessionMessageDeliveryStatus *>(obj);
      return ptr->UnPack(resolver);
    }
    case ChreMessage::BtSocketCapabilitiesRequest: {
      auto ptr = reinterpret_cast<const chre::fbs::BtSocketCapabilitiesRequest *>(obj);
      return ptr->UnPack(resolver);
    }
    case ChreMessage::BtSocketCapabilitiesResponse: {
      auto ptr = reinterpret_cast<const chre::fbs::BtSocketCapabilitiesResponse *>(obj);
      return ptr->UnPack(resolver);
    }
    case ChreMessage::AddServiceToEndpoint: {
      auto ptr = reinterpret_cast<const chre::fbs::AddServiceToEndpoint *>(obj);
      return ptr->UnPack(resolver);
    }
    case ChreMessage::EndpointReady: {
      auto ptr = reinterpret_cast<const chre::fbs::EndpointReady *>(obj);
      return ptr->UnPack(resolver);
    }
    default: return nullptr;
  }
}

inline flatbuffers::Offset<void> ChreMessageUnion::Pack(flatbuffers::FlatBufferBuilder &_fbb, const flatbuffers::rehasher_function_t *_rehasher) const {
  switch (type) {
    case ChreMessage::NanoappMessage: {
      auto ptr = reinterpret_cast<const chre::fbs::NanoappMessageT *>(value);
      return CreateNanoappMessage(_fbb, ptr, _rehasher).Union();
    }
    case ChreMessage::HubInfoRequest: {
      auto ptr = reinterpret_cast<const chre::fbs::HubInfoRequestT *>(value);
      return CreateHubInfoRequest(_fbb, ptr, _rehasher).Union();
    }
    case ChreMessage::HubInfoResponse: {
      auto ptr = reinterpret_cast<const chre::fbs::HubInfoResponseT *>(value);
      return CreateHubInfoResponse(_fbb, ptr, _rehasher).Union();
    }
    case ChreMessage::NanoappListRequest: {
      auto ptr = reinterpret_cast<const chre::fbs::NanoappListRequestT *>(value);
      return CreateNanoappListRequest(_fbb, ptr, _rehasher).Union();
    }
    case ChreMessage::NanoappListResponse: {
      auto ptr = reinterpret_cast<const chre::fbs::NanoappListResponseT *>(value);
      return CreateNanoappListResponse(_fbb, ptr, _rehasher).Union();
    }
    case ChreMessage::LoadNanoappRequest: {
      auto ptr = reinterpret_cast<const chre::fbs::LoadNanoappRequestT *>(value);
      return CreateLoadNanoappRequest(_fbb, ptr, _rehasher).Union();
    }
    case ChreMessage::LoadNanoappResponse: {
      auto ptr = reinterpret_cast<const chre::fbs::LoadNanoappResponseT *>(value);
      return CreateLoadNanoappResponse(_fbb, ptr, _rehasher).Union();
    }
    case ChreMessage::UnloadNanoappRequest: {
      auto ptr = reinterpret_cast<const chre::fbs::UnloadNanoappRequestT *>(value);
      return CreateUnloadNanoappRequest(_fbb, ptr, _rehasher).Union();
    }
    case ChreMessage::UnloadNanoappResponse: {
      auto ptr = reinterpret_cast<const chre::fbs::UnloadNanoappResponseT *>(value);
      return CreateUnloadNanoappResponse(_fbb, ptr, _rehasher).Union();
    }
    case ChreMessage::LogMessage: {
      auto ptr = reinterpret_cast<const chre::fbs::LogMessageT *>(value);
      return CreateLogMessage(_fbb, ptr, _rehasher).Union();
    }
    case ChreMessage::TimeSyncMessage: {
      auto ptr = reinterpret_cast<const chre::fbs::TimeSyncMessageT *>(value);
      return CreateTimeSyncMessage(_fbb, ptr, _rehasher).Union();
    }
    case ChreMessage::DebugDumpRequest: {
      auto ptr = reinterpret_cast<const chre::fbs::DebugDumpRequestT *>(value);
      return CreateDebugDumpRequest(_fbb, ptr, _rehasher).Union();
    }
    case ChreMessage::DebugDumpData: {
      auto ptr = reinterpret_cast<const chre::fbs::DebugDumpDataT *>(value);
      return CreateDebugDumpData(_fbb, ptr, _rehasher).Union();
    }
    case ChreMessage::DebugDumpResponse: {
      auto ptr = reinterpret_cast<const chre::fbs::DebugDumpResponseT *>(value);
      return CreateDebugDumpResponse(_fbb, ptr, _rehasher).Union();
    }
    case ChreMessage::TimeSyncRequest: {
      auto ptr = reinterpret_cast<const chre::fbs::TimeSyncRequestT *>(value);
      return CreateTimeSyncRequest(_fbb, ptr, _rehasher).Union();
    }
    case ChreMessage::LowPowerMicAccessRequest: {
      auto ptr = reinterpret_cast<const chre::fbs::LowPowerMicAccessRequestT *>(value);
      return CreateLowPowerMicAccessRequest(_fbb, ptr, _rehasher).Union();
    }
    case ChreMessage::LowPowerMicAccessRelease: {
      auto ptr = reinterpret_cast<const chre::fbs::LowPowerMicAccessReleaseT *>(value);
      return CreateLowPowerMicAccessRelease(_fbb, ptr, _rehasher).Union();
    }
    case ChreMessage::SettingChangeMessage: {
      auto ptr = reinterpret_cast<const chre::fbs::SettingChangeMessageT *>(value);
      return CreateSettingChangeMessage(_fbb, ptr, _rehasher).Union();
    }
    case ChreMessage::LogMessageV2: {
      auto ptr = reinterpret_cast<const chre::fbs::LogMessageV2T *>(value);
      return CreateLogMessageV2(_fbb, ptr, _rehasher).Union();
    }
    case ChreMessage::SelfTestRequest: {
      auto ptr = reinterpret_cast<const chre::fbs::SelfTestRequestT *>(value);
      return CreateSelfTestRequest(_fbb, ptr, _rehasher).Union();
    }
    case ChreMessage::SelfTestResponse: {
      auto ptr = reinterpret_cast<const chre::fbs::SelfTestResponseT *>(value);
      return CreateSelfTestResponse(_fbb, ptr, _rehasher).Union();
    }
    case ChreMessage::HostEndpointConnected: {
      auto ptr = reinterpret_cast<const chre::fbs::HostEndpointConnectedT *>(value);
      return CreateHostEndpointConnected(_fbb, ptr, _rehasher).Union();
    }
    case ChreMessage::HostEndpointDisconnected: {
      auto ptr = reinterpret_cast<const chre::fbs::HostEndpointDisconnectedT *>(value);
      return CreateHostEndpointDisconnected(_fbb, ptr, _rehasher).Union();
    }
    case ChreMessage::MetricLog: {
      auto ptr = reinterpret_cast<const chre::fbs::MetricLogT *>(value);
      return CreateMetricLog(_fbb, ptr, _rehasher).Union();
    }
    case ChreMessage::BatchedMetricLog: {
      auto ptr = reinterpret_cast<const chre::fbs::BatchedMetricLogT *>(value);
      return CreateBatchedMetricLog(_fbb, ptr, _rehasher).Union();
    }
    case ChreMessage::NanConfigurationRequest: {
      auto ptr = reinterpret_cast<const chre::fbs::NanConfigurationRequestT *>(value);
      return CreateNanConfigurationRequest(_fbb, ptr, _rehasher).Union();
    }
    case ChreMessage::NanConfigurationUpdate: {
      auto ptr = reinterpret_cast<const chre::fbs::NanConfigurationUpdateT *>(value);
      return CreateNanConfigurationUpdate(_fbb, ptr, _rehasher).Union();
    }
    case ChreMessage::DebugConfiguration: {
      auto ptr = reinterpret_cast<const chre::fbs::DebugConfigurationT *>(value);
      return CreateDebugConfiguration(_fbb, ptr, _rehasher).Union();
    }
    case ChreMessage::PulseRequest: {
      auto ptr = reinterpret_cast<const chre::fbs::PulseRequestT *>(value);
      return CreatePulseRequest(_fbb, ptr, _rehasher).Union();
    }
    case ChreMessage::PulseResponse: {
      auto ptr = reinterpret_cast<const chre::fbs::PulseResponseT *>(value);
      return CreatePulseResponse(_fbb, ptr, _rehasher).Union();
    }
    case ChreMessage::NanoappTokenDatabaseInfo: {
      auto ptr = reinterpret_cast<const chre::fbs::NanoappTokenDatabaseInfoT *>(value);
      return CreateNanoappTokenDatabaseInfo(_fbb, ptr, _rehasher).Union();
    }
    case ChreMessage::MessageDeliveryStatus: {
      auto ptr = reinterpret_cast<const chre::fbs::MessageDeliveryStatusT *>(value);
      return CreateMessageDeliveryStatus(_fbb, ptr, _rehasher).Union();
    }
    case ChreMessage::BtSocketOpen: {
      auto ptr = reinterpret_cast<const chre::fbs::BtSocketOpenT *>(value);
      return CreateBtSocketOpen(_fbb, ptr, _rehasher).Union();
    }
    case ChreMessage::BtSocketOpenResponse: {
      auto ptr = reinterpret_cast<const chre::fbs::BtSocketOpenResponseT *>(value);
      return CreateBtSocketOpenResponse(_fbb, ptr, _rehasher).Union();
    }
    case ChreMessage::BtSocketClose: {
      auto ptr = reinterpret_cast<const chre::fbs::BtSocketCloseT *>(value);
      return CreateBtSocketClose(_fbb, ptr, _rehasher).Union();
    }
    case ChreMessage::BtSocketCloseResponse: {
      auto ptr = reinterpret_cast<const chre::fbs::BtSocketCloseResponseT *>(value);
      return CreateBtSocketCloseResponse(_fbb, ptr, _rehasher).Union();
    }
    case ChreMessage::GetMessageHubsAndEndpointsRequest: {
      auto ptr = reinterpret_cast<const chre::fbs::GetMessageHubsAndEndpointsRequestT *>(value);
      return CreateGetMessageHubsAndEndpointsRequest(_fbb, ptr, _rehasher).Union();
    }
    case ChreMessage::GetMessageHubsAndEndpointsResponse: {
      auto ptr = reinterpret_cast<const chre::fbs::GetMessageHubsAndEndpointsResponseT *>(value);
      return CreateGetMessageHubsAndEndpointsResponse(_fbb, ptr, _rehasher).Union();
    }
    case ChreMessage::RegisterMessageHub: {
      auto ptr = reinterpret_cast<const chre::fbs::RegisterMessageHubT *>(value);
      return CreateRegisterMessageHub(_fbb, ptr, _rehasher).Union();
    }
    case ChreMessage::UnregisterMessageHub: {
      auto ptr = reinterpret_cast<const chre::fbs::UnregisterMessageHubT *>(value);
      return CreateUnregisterMessageHub(_fbb, ptr, _rehasher).Union();
    }
    case ChreMessage::RegisterEndpoint: {
      auto ptr = reinterpret_cast<const chre::fbs::RegisterEndpointT *>(value);
      return CreateRegisterEndpoint(_fbb, ptr, _rehasher).Union();
    }
    case ChreMessage::UnregisterEndpoint: {
      auto ptr = reinterpret_cast<const chre::fbs::UnregisterEndpointT *>(value);
      return CreateUnregisterEndpoint(_fbb, ptr, _rehasher).Union();
    }
    case ChreMessage::OpenEndpointSessionRequest: {
      auto ptr = reinterpret_cast<const chre::fbs::OpenEndpointSessionRequestT *>(value);
      return CreateOpenEndpointSessionRequest(_fbb, ptr, _rehasher).Union();
    }
    case ChreMessage::EndpointSessionOpened: {
      auto ptr = reinterpret_cast<const chre::fbs::EndpointSessionOpenedT *>(value);
      return CreateEndpointSessionOpened(_fbb, ptr, _rehasher).Union();
    }
    case ChreMessage::EndpointSessionClosed: {
      auto ptr = reinterpret_cast<const chre::fbs::EndpointSessionClosedT *>(value);
      return CreateEndpointSessionClosed(_fbb, ptr, _rehasher).Union();
    }
    case ChreMessage::EndpointSessionMessage: {
      auto ptr = reinterpret_cast<const chre::fbs::EndpointSessionMessageT *>(value);
      return CreateEndpointSessionMessage(_fbb, ptr, _rehasher).Union();
    }
    case ChreMessage::EndpointSessionMessageDeliveryStatus: {
      auto ptr = reinterpret_cast<const chre::fbs::EndpointSessionMessageDeliveryStatusT *>(value);
      return CreateEndpointSessionMessageDeliveryStatus(_fbb, ptr, _rehasher).Union();
    }
    case ChreMessage::BtSocketCapabilitiesRequest: {
      auto ptr = reinterpret_cast<const chre::fbs::BtSocketCapabilitiesRequestT *>(value);
      return CreateBtSocketCapabilitiesRequest(_fbb, ptr, _rehasher).Union();
    }
    case ChreMessage::BtSocketCapabilitiesResponse: {
      auto ptr = reinterpret_cast<const chre::fbs::BtSocketCapabilitiesResponseT *>(value);
      return CreateBtSocketCapabilitiesResponse(_fbb, ptr, _rehasher).Union();
    }
    case ChreMessage::AddServiceToEndpoint: {
      auto ptr = reinterpret_cast<const chre::fbs::AddServiceToEndpointT *>(value);
      return CreateAddServiceToEndpoint(_fbb, ptr, _rehasher).Union();
    }
    case ChreMessage::EndpointReady: {
      auto ptr = reinterpret_cast<const chre::fbs::EndpointReadyT *>(value);
      return CreateEndpointReady(_fbb, ptr, _rehasher).Union();
    }
    default: return 0;
  }
}

inline ChreMessageUnion::ChreMessageUnion(const ChreMessageUnion &u) : type(u.type), value(nullptr) {
  switch (type) {
    case ChreMessage::NanoappMessage: {
      value = new chre::fbs::NanoappMessageT(*reinterpret_cast<chre::fbs::NanoappMessageT *>(u.value));
      break;
    }
    case ChreMessage::HubInfoRequest: {
      value = new chre::fbs::HubInfoRequestT(*reinterpret_cast<chre::fbs::HubInfoRequestT *>(u.value));
      break;
    }
    case ChreMessage::HubInfoResponse: {
      value = new chre::fbs::HubInfoResponseT(*reinterpret_cast<chre::fbs::HubInfoResponseT *>(u.value));
      break;
    }
    case ChreMessage::NanoappListRequest: {
      value = new chre::fbs::NanoappListRequestT(*reinterpret_cast<chre::fbs::NanoappListRequestT *>(u.value));
      break;
    }
    case ChreMessage::NanoappListResponse: {
      FLATBUFFERS_ASSERT(false);  // chre::fbs::NanoappListResponseT not copyable.
      break;
    }
    case ChreMessage::LoadNanoappRequest: {
      value = new chre::fbs::LoadNanoappRequestT(*reinterpret_cast<chre::fbs::LoadNanoappRequestT *>(u.value));
      break;
    }
    case ChreMessage::LoadNanoappResponse: {
      value = new chre::fbs::LoadNanoappResponseT(*reinterpret_cast<chre::fbs::LoadNanoappResponseT *>(u.value));
      break;
    }
    case ChreMessage::UnloadNanoappRequest: {
      value = new chre::fbs::UnloadNanoappRequestT(*reinterpret_cast<chre::fbs::UnloadNanoappRequestT *>(u.value));
      break;
    }
    case ChreMessage::UnloadNanoappResponse: {
      value = new chre::fbs::UnloadNanoappResponseT(*reinterpret_cast<chre::fbs::UnloadNanoappResponseT *>(u.value));
      break;
    }
    case ChreMessage::LogMessage: {
      value = new chre::fbs::LogMessageT(*reinterpret_cast<chre::fbs::LogMessageT *>(u.value));
      break;
    }
    case ChreMessage::TimeSyncMessage: {
      value = new chre::fbs::TimeSyncMessageT(*reinterpret_cast<chre::fbs::TimeSyncMessageT *>(u.value));
      break;
    }
    case ChreMessage::DebugDumpRequest: {
      value = new chre::fbs::DebugDumpRequestT(*reinterpret_cast<chre::fbs::DebugDumpRequestT *>(u.value));
      break;
    }
    case ChreMessage::DebugDumpData: {
      value = new chre::fbs::DebugDumpDataT(*reinterpret_cast<chre::fbs::DebugDumpDataT *>(u.value));
      break;
    }
    case ChreMessage::DebugDumpResponse: {
      value = new chre::fbs::DebugDumpResponseT(*reinterpret_cast<chre::fbs::DebugDumpResponseT *>(u.value));
      break;
    }
    case ChreMessage::TimeSyncRequest: {
      value = new chre::fbs::TimeSyncRequestT(*reinterpret_cast<chre::fbs::TimeSyncRequestT *>(u.value));
      break;
    }
    case ChreMessage::LowPowerMicAccessRequest: {
      value = new chre::fbs::LowPowerMicAccessRequestT(*reinterpret_cast<chre::fbs::LowPowerMicAccessRequestT *>(u.value));
      break;
    }
    case ChreMessage::LowPowerMicAccessRelease: {
      value = new chre::fbs::LowPowerMicAccessReleaseT(*reinterpret_cast<chre::fbs::LowPowerMicAccessReleaseT *>(u.value));
      break;
    }
    case ChreMessage::SettingChangeMessage: {
      value = new chre::fbs::SettingChangeMessageT(*reinterpret_cast<chre::fbs::SettingChangeMessageT *>(u.value));
      break;
    }
    case ChreMessage::LogMessageV2: {
      value = new chre::fbs::LogMessageV2T(*reinterpret_cast<chre::fbs::LogMessageV2T *>(u.value));
      break;
    }
    case ChreMessage::SelfTestRequest: {
      value = new chre::fbs::SelfTestRequestT(*reinterpret_cast<chre::fbs::SelfTestRequestT *>(u.value));
      break;
    }
    case ChreMessage::SelfTestResponse: {
      value = new chre::fbs::SelfTestResponseT(*reinterpret_cast<chre::fbs::SelfTestResponseT *>(u.value));
      break;
    }
    case ChreMessage::HostEndpointConnected: {
      value = new chre::fbs::HostEndpointConnectedT(*reinterpret_cast<chre::fbs::HostEndpointConnectedT *>(u.value));
      break;
    }
    case ChreMessage::HostEndpointDisconnected: {
      value = new chre::fbs::HostEndpointDisconnectedT(*reinterpret_cast<chre::fbs::HostEndpointDisconnectedT *>(u.value));
      break;
    }
    case ChreMessage::MetricLog: {
      value = new chre::fbs::MetricLogT(*reinterpret_cast<chre::fbs::MetricLogT *>(u.value));
      break;
    }
    case ChreMessage::BatchedMetricLog: {
      FLATBUFFERS_ASSERT(false);  // chre::fbs::BatchedMetricLogT not copyable.
      break;
    }
    case ChreMessage::NanConfigurationRequest: {
      value = new chre::fbs::NanConfigurationRequestT(*reinterpret_cast<chre::fbs::NanConfigurationRequestT *>(u.value));
      break;
    }
    case ChreMessage::NanConfigurationUpdate: {
      value = new chre::fbs::NanConfigurationUpdateT(*reinterpret_cast<chre::fbs::NanConfigurationUpdateT *>(u.value));
      break;
    }
    case ChreMessage::DebugConfiguration: {
      value = new chre::fbs::DebugConfigurationT(*reinterpret_cast<chre::fbs::DebugConfigurationT *>(u.value));
      break;
    }
    case ChreMessage::PulseRequest: {
      value = new chre::fbs::PulseRequestT(*reinterpret_cast<chre::fbs::PulseRequestT *>(u.value));
      break;
    }
    case ChreMessage::PulseResponse: {
      value = new chre::fbs::PulseResponseT(*reinterpret_cast<chre::fbs::PulseResponseT *>(u.value));
      break;
    }
    case ChreMessage::NanoappTokenDatabaseInfo: {
      value = new chre::fbs::NanoappTokenDatabaseInfoT(*reinterpret_cast<chre::fbs::NanoappTokenDatabaseInfoT *>(u.value));
      break;
    }
    case ChreMessage::MessageDeliveryStatus: {
      value = new chre::fbs::MessageDeliveryStatusT(*reinterpret_cast<chre::fbs::MessageDeliveryStatusT *>(u.value));
      break;
    }
    case ChreMessage::BtSocketOpen: {
      value = new chre::fbs::BtSocketOpenT(*reinterpret_cast<chre::fbs::BtSocketOpenT *>(u.value));
      break;
    }
    case ChreMessage::BtSocketOpenResponse: {
      value = new chre::fbs::BtSocketOpenResponseT(*reinterpret_cast<chre::fbs::BtSocketOpenResponseT *>(u.value));
      break;
    }
    case ChreMessage::BtSocketClose: {
      value = new chre::fbs::BtSocketCloseT(*reinterpret_cast<chre::fbs::BtSocketCloseT *>(u.value));
      break;
    }
    case ChreMessage::BtSocketCloseResponse: {
      value = new chre::fbs::BtSocketCloseResponseT(*reinterpret_cast<chre::fbs::BtSocketCloseResponseT *>(u.value));
      break;
    }
    case ChreMessage::GetMessageHubsAndEndpointsRequest: {
      value = new chre::fbs::GetMessageHubsAndEndpointsRequestT(*reinterpret_cast<chre::fbs::GetMessageHubsAndEndpointsRequestT *>(u.value));
      break;
    }
    case ChreMessage::GetMessageHubsAndEndpointsResponse: {
      FLATBUFFERS_ASSERT(false);  // chre::fbs::GetMessageHubsAndEndpointsResponseT not copyable.
      break;
    }
    case ChreMessage::RegisterMessageHub: {
      FLATBUFFERS_ASSERT(false);  // chre::fbs::RegisterMessageHubT not copyable.
      break;
    }
    case ChreMessage::UnregisterMessageHub: {
      value = new chre::fbs::UnregisterMessageHubT(*reinterpret_cast<chre::fbs::UnregisterMessageHubT *>(u.value));
      break;
    }
    case ChreMessage::RegisterEndpoint: {
      FLATBUFFERS_ASSERT(false);  // chre::fbs::RegisterEndpointT not copyable.
      break;
    }
    case ChreMessage::UnregisterEndpoint: {
      FLATBUFFERS_ASSERT(false);  // chre::fbs::UnregisterEndpointT not copyable.
      break;
    }
    case ChreMessage::OpenEndpointSessionRequest: {
      FLATBUFFERS_ASSERT(false);  // chre::fbs::OpenEndpointSessionRequestT not copyable.
      break;
    }
    case ChreMessage::EndpointSessionOpened: {
      value = new chre::fbs::EndpointSessionOpenedT(*reinterpret_cast<chre::fbs::EndpointSessionOpenedT *>(u.value));
      break;
    }
    case ChreMessage::EndpointSessionClosed: {
      value = new chre::fbs::EndpointSessionClosedT(*reinterpret_cast<chre::fbs::EndpointSessionClosedT *>(u.value));
      break;
    }
    case ChreMessage::EndpointSessionMessage: {
      value = new chre::fbs::EndpointSessionMessageT(*reinterpret_cast<chre::fbs::EndpointSessionMessageT *>(u.value));
      break;
    }
    case ChreMessage::EndpointSessionMessageDeliveryStatus: {
      FLATBUFFERS_ASSERT(false);  // chre::fbs::EndpointSessionMessageDeliveryStatusT not copyable.
      break;
    }
    case ChreMessage::BtSocketCapabilitiesRequest: {
      value = new chre::fbs::BtSocketCapabilitiesRequestT(*reinterpret_cast<chre::fbs::BtSocketCapabilitiesRequestT *>(u.value));
      break;
    }
    case ChreMessage::BtSocketCapabilitiesResponse: {
      FLATBUFFERS_ASSERT(false);  // chre::fbs::BtSocketCapabilitiesResponseT not copyable.
      break;
    }
    case ChreMessage::AddServiceToEndpoint: {
      FLATBUFFERS_ASSERT(false);  // chre::fbs::AddServiceToEndpointT not copyable.
      break;
    }
    case ChreMessage::EndpointReady: {
      FLATBUFFERS_ASSERT(false);  // chre::fbs::EndpointReadyT not copyable.
      break;
    }
    default:
      break;
  }
}

inline void ChreMessageUnion::Reset() {
  switch (type) {
    case ChreMessage::NanoappMessage: {
      auto ptr = reinterpret_cast<chre::fbs::NanoappMessageT *>(value);
      delete ptr;
      break;
    }
    case ChreMessage::HubInfoRequest: {
      auto ptr = reinterpret_cast<chre::fbs::HubInfoRequestT *>(value);
      delete ptr;
      break;
    }
    case ChreMessage::HubInfoResponse: {
      auto ptr = reinterpret_cast<chre::fbs::HubInfoResponseT *>(value);
      delete ptr;
      break;
    }
    case ChreMessage::NanoappListRequest: {
      auto ptr = reinterpret_cast<chre::fbs::NanoappListRequestT *>(value);
      delete ptr;
      break;
    }
    case ChreMessage::NanoappListResponse: {
      auto ptr = reinterpret_cast<chre::fbs::NanoappListResponseT *>(value);
      delete ptr;
      break;
    }
    case ChreMessage::LoadNanoappRequest: {
      auto ptr = reinterpret_cast<chre::fbs::LoadNanoappRequestT *>(value);
      delete ptr;
      break;
    }
    case ChreMessage::LoadNanoappResponse: {
      auto ptr = reinterpret_cast<chre::fbs::LoadNanoappResponseT *>(value);
      delete ptr;
      break;
    }
    case ChreMessage::UnloadNanoappRequest: {
      auto ptr = reinterpret_cast<chre::fbs::UnloadNanoappRequestT *>(value);
      delete ptr;
      break;
    }
    case ChreMessage::UnloadNanoappResponse: {
      auto ptr = reinterpret_cast<chre::fbs::UnloadNanoappResponseT *>(value);
      delete ptr;
      break;
    }
    case ChreMessage::LogMessage: {
      auto ptr = reinterpret_cast<chre::fbs::LogMessageT *>(value);
      delete ptr;
      break;
    }
    case ChreMessage::TimeSyncMessage: {
      auto ptr = reinterpret_cast<chre::fbs::TimeSyncMessageT *>(value);
      delete ptr;
      break;
    }
    case ChreMessage::DebugDumpRequest: {
      auto ptr = reinterpret_cast<chre::fbs::DebugDumpRequestT *>(value);
      delete ptr;
      break;
    }
    case ChreMessage::DebugDumpData: {
      auto ptr = reinterpret_cast<chre::fbs::DebugDumpDataT *>(value);
      delete ptr;
      break;
    }
    case ChreMessage::DebugDumpResponse: {
      auto ptr = reinterpret_cast<chre::fbs::DebugDumpResponseT *>(value);
      delete ptr;
      break;
    }
    case ChreMessage::TimeSyncRequest: {
      auto ptr = reinterpret_cast<chre::fbs::TimeSyncRequestT *>(value);
      delete ptr;
      break;
    }
    case ChreMessage::LowPowerMicAccessRequest: {
      auto ptr = reinterpret_cast<chre::fbs::LowPowerMicAccessRequestT *>(value);
      delete ptr;
      break;
    }
    case ChreMessage::LowPowerMicAccessRelease: {
      auto ptr = reinterpret_cast<chre::fbs::LowPowerMicAccessReleaseT *>(value);
      delete ptr;
      break;
    }
    case ChreMessage::SettingChangeMessage: {
      auto ptr = reinterpret_cast<chre::fbs::SettingChangeMessageT *>(value);
      delete ptr;
      break;
    }
    case ChreMessage::LogMessageV2: {
      auto ptr = reinterpret_cast<chre::fbs::LogMessageV2T *>(value);
      delete ptr;
      break;
    }
    case ChreMessage::SelfTestRequest: {
      auto ptr = reinterpret_cast<chre::fbs::SelfTestRequestT *>(value);
      delete ptr;
      break;
    }
    case ChreMessage::SelfTestResponse: {
      auto ptr = reinterpret_cast<chre::fbs::SelfTestResponseT *>(value);
      delete ptr;
      break;
    }
    case ChreMessage::HostEndpointConnected: {
      auto ptr = reinterpret_cast<chre::fbs::HostEndpointConnectedT *>(value);
      delete ptr;
      break;
    }
    case ChreMessage::HostEndpointDisconnected: {
      auto ptr = reinterpret_cast<chre::fbs::HostEndpointDisconnectedT *>(value);
      delete ptr;
      break;
    }
    case ChreMessage::MetricLog: {
      auto ptr = reinterpret_cast<chre::fbs::MetricLogT *>(value);
      delete ptr;
      break;
    }
    case ChreMessage::BatchedMetricLog: {
      auto ptr = reinterpret_cast<chre::fbs::BatchedMetricLogT *>(value);
      delete ptr;
      break;
    }
    case ChreMessage::NanConfigurationRequest: {
      auto ptr = reinterpret_cast<chre::fbs::NanConfigurationRequestT *>(value);
      delete ptr;
      break;
    }
    case ChreMessage::NanConfigurationUpdate: {
      auto ptr = reinterpret_cast<chre::fbs::NanConfigurationUpdateT *>(value);
      delete ptr;
      break;
    }
    case ChreMessage::DebugConfiguration: {
      auto ptr = reinterpret_cast<chre::fbs::DebugConfigurationT *>(value);
      delete ptr;
      break;
    }
    case ChreMessage::PulseRequest: {
      auto ptr = reinterpret_cast<chre::fbs::PulseRequestT *>(value);
      delete ptr;
      break;
    }
    case ChreMessage::PulseResponse: {
      auto ptr = reinterpret_cast<chre::fbs::PulseResponseT *>(value);
      delete ptr;
      break;
    }
    case ChreMessage::NanoappTokenDatabaseInfo: {
      auto ptr = reinterpret_cast<chre::fbs::NanoappTokenDatabaseInfoT *>(value);
      delete ptr;
      break;
    }
    case ChreMessage::MessageDeliveryStatus: {
      auto ptr = reinterpret_cast<chre::fbs::MessageDeliveryStatusT *>(value);
      delete ptr;
      break;
    }
    case ChreMessage::BtSocketOpen: {
      auto ptr = reinterpret_cast<chre::fbs::BtSocketOpenT *>(value);
      delete ptr;
      break;
    }
    case ChreMessage::BtSocketOpenResponse: {
      auto ptr = reinterpret_cast<chre::fbs::BtSocketOpenResponseT *>(value);
      delete ptr;
      break;
    }
    case ChreMessage::BtSocketClose: {
      auto ptr = reinterpret_cast<chre::fbs::BtSocketCloseT *>(value);
      delete ptr;
      break;
    }
    case ChreMessage::BtSocketCloseResponse: {
      auto ptr = reinterpret_cast<chre::fbs::BtSocketCloseResponseT *>(value);
      delete ptr;
      break;
    }
    case ChreMessage::GetMessageHubsAndEndpointsRequest: {
      auto ptr = reinterpret_cast<chre::fbs::GetMessageHubsAndEndpointsRequestT *>(value);
      delete ptr;
      break;
    }
    case ChreMessage::GetMessageHubsAndEndpointsResponse: {
      auto ptr = reinterpret_cast<chre::fbs::GetMessageHubsAndEndpointsResponseT *>(value);
      delete ptr;
      break;
    }
    case ChreMessage::RegisterMessageHub: {
      auto ptr = reinterpret_cast<chre::fbs::RegisterMessageHubT *>(value);
      delete ptr;
      break;
    }
    case ChreMessage::UnregisterMessageHub: {
      auto ptr = reinterpret_cast<chre::fbs::UnregisterMessageHubT *>(value);
      delete ptr;
      break;
    }
    case ChreMessage::RegisterEndpoint: {
      auto ptr = reinterpret_cast<chre::fbs::RegisterEndpointT *>(value);
      delete ptr;
      break;
    }
    case ChreMessage::UnregisterEndpoint: {
      auto ptr = reinterpret_cast<chre::fbs::UnregisterEndpointT *>(value);
      delete ptr;
      break;
    }
    case ChreMessage::OpenEndpointSessionRequest: {
      auto ptr = reinterpret_cast<chre::fbs::OpenEndpointSessionRequestT *>(value);
      delete ptr;
      break;
    }
    case ChreMessage::EndpointSessionOpened: {
      auto ptr = reinterpret_cast<chre::fbs::EndpointSessionOpenedT *>(value);
      delete ptr;
      break;
    }
    case ChreMessage::EndpointSessionClosed: {
      auto ptr = reinterpret_cast<chre::fbs::EndpointSessionClosedT *>(value);
      delete ptr;
      break;
    }
    case ChreMessage::EndpointSessionMessage: {
      auto ptr = reinterpret_cast<chre::fbs::EndpointSessionMessageT *>(value);
      delete ptr;
      break;
    }
    case ChreMessage::EndpointSessionMessageDeliveryStatus: {
      auto ptr = reinterpret_cast<chre::fbs::EndpointSessionMessageDeliveryStatusT *>(value);
      delete ptr;
      break;
    }
    case ChreMessage::BtSocketCapabilitiesRequest: {
      auto ptr = reinterpret_cast<chre::fbs::BtSocketCapabilitiesRequestT *>(value);
      delete ptr;
      break;
    }
    case ChreMessage::BtSocketCapabilitiesResponse: {
      auto ptr = reinterpret_cast<chre::fbs::BtSocketCapabilitiesResponseT *>(value);
      delete ptr;
      break;
    }
    case ChreMessage::AddServiceToEndpoint: {
      auto ptr = reinterpret_cast<chre::fbs::AddServiceToEndpointT *>(value);
      delete ptr;
      break;
    }
    case ChreMessage::EndpointReady: {
      auto ptr = reinterpret_cast<chre::fbs::EndpointReadyT *>(value);
      delete ptr;
      break;
    }
    default: break;
  }
  value = nullptr;
  type = ChreMessage::NONE;
}

inline const chre::fbs::MessageContainer *GetMessageContainer(const void *buf) {
  return flatbuffers::GetRoot<chre::fbs::MessageContainer>(buf);
}

inline const chre::fbs::MessageContainer *GetSizePrefixedMessageContainer(const void *buf) {
  return flatbuffers::GetSizePrefixedRoot<chre::fbs::MessageContainer>(buf);
}

inline MessageContainer *GetMutableMessageContainer(void *buf) {
  return flatbuffers::GetMutableRoot<MessageContainer>(buf);
}

inline bool VerifyMessageContainerBuffer(
    flatbuffers::Verifier &verifier) {
  return verifier.VerifyBuffer<chre::fbs::MessageContainer>(nullptr);
}

inline bool VerifySizePrefixedMessageContainerBuffer(
    flatbuffers::Verifier &verifier) {
  return verifier.VerifySizePrefixedBuffer<chre::fbs::MessageContainer>(nullptr);
}

inline void FinishMessageContainerBuffer(
    flatbuffers::FlatBufferBuilder &fbb,
    flatbuffers::Offset<chre::fbs::MessageContainer> root) {
  fbb.Finish(root);
}

inline void FinishSizePrefixedMessageContainerBuffer(
    flatbuffers::FlatBufferBuilder &fbb,
    flatbuffers::Offset<chre::fbs::MessageContainer> root) {
  fbb.FinishSizePrefixed(root);
}

inline std::unique_ptr<chre::fbs::MessageContainerT> UnPackMessageContainer(
    const void *buf,
    const flatbuffers::resolver_function_t *res = nullptr) {
  return std::unique_ptr<chre::fbs::MessageContainerT>(GetMessageContainer(buf)->UnPack(res));
}

inline std::unique_ptr<chre::fbs::MessageContainerT> UnPackSizePrefixedMessageContainer(
    const void *buf,
    const flatbuffers::resolver_function_t *res = nullptr) {
  return std::unique_ptr<chre::fbs::MessageContainerT>(GetSizePrefixedMessageContainer(buf)->UnPack(res));
}

}  // namespace fbs
}  // namespace chre

#endif  // FLATBUFFERS_GENERATED_HOSTMESSAGES_CHRE_FBS_H_
